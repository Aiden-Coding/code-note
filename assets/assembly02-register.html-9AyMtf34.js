import{_ as e,o as a,c as p,e as i}from"./app-3RcBQnkC.js";const n={},s=i(`<h1 id="认识一下-x86-的寄存器" tabindex="-1"><a class="header-anchor" href="#认识一下-x86-的寄存器" aria-hidden="true">#</a> 认识一下 x86 的寄存器</h1><ul><li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a><ul><li><a href="#%E8%AE%A4%E8%AF%86%E5%AF%84%E5%AD%98%E5%99%A8">认识寄存器</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8">计算机架构中的寄存器</a></li><li><a href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8">通用寄存器</a><ul><li><a href="#ax-%E5%AF%84%E5%AD%98%E5%99%A8">AX 寄存器</a></li><li><a href="#bx-%E5%AF%84%E5%AD%98%E5%99%A8">BX 寄存器</a></li><li><a href="#cx-%E5%AF%84%E5%AD%98%E5%99%A8">CX 寄存器</a></li><li><a href="#dx-%E5%AF%84%E5%AD%98%E5%99%A8">DX 寄存器</a></li></ul></li><li><a href="#%E7%B4%A2%E5%BC%95%E5%AF%84%E5%AD%98%E5%99%A8">索引寄存器</a></li><li><a href="#%E7%8A%B6%E6%80%81%E5%92%8C%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8">状态和控制寄存器</a></li></ul></li><li><a href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">物理地址</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AE%B5">什么是段</a></li><li><a href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a><ul><li><a href="#cs-%E5%AF%84%E5%AD%98%E5%99%A8">CS 寄存器</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-code-segment">什么是 Code Segment</a></li><li><a href="#ds-%E5%AF%84%E5%AD%98%E5%99%A8">DS 寄存器</a></li><li><a href="#%E6%A0%88">栈</a></li><li><a href="#%E6%A0%88%E5%92%8C-ss-%E5%AF%84%E5%AD%98%E5%99%A8">栈和 SS 寄存器</a></li><li><a href="#%E6%A0%88%E9%A1%B6%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98">栈顶越界问题</a></li></ul></li></ul></li></ul></li></ul><p>下面我们就来介绍一下关于寄存器的相关内容。我们知道，<code>寄存器</code>是 CPU 内部的构造，它主要用于信息和数据的存储。除此之外，CPU 内部还有<code>运算器</code>，负责处理数据；<code>控制器</code>控制其他组件；<code>外部总线</code>连接 CPU 和各种部件，进行数据传输；<code>内部总线</code>负责 CPU 内部各种组件的数据处理。</p><p>那么对于我们所了解的汇编语言来说，我们的主要关注点就是 <code>寄存器</code>。</p><p>为什么会出现寄存器？因为我们知道，程序在内存中装载，由 CPU 对内存中的数据和指令进行提取并执行，CPU 的主要职责就是用来处理数据。那么这个过程势必涉及到从存储器中读取和写入数据，因为它涉及通过控制总线发送数据请求并进入存储器存储单元，通过同一通道获取数据，这个过程非常的繁琐并且会涉及到大量的内存占用，而且有一些常用的内存页存在，其实是没有必要的，因此出现了寄存器，存储在 CPU 内部。</p><h2 id="认识寄存器" tabindex="-1"><a class="header-anchor" href="#认识寄存器" aria-hidden="true">#</a> 认识寄存器</h2><p>寄存器的官方叫法有很多，Wiki 上面的叫法是 <code>Processing Register</code>， 也可以称为 <code>CPU Register</code>，计算机中经常有一个东西包含多种叫法的情况，我们知道咋回事就可以了。</p><p>认识寄存器之前，我们首先先来看一下 CPU 内部的构造。</p><img src="http://www.cxuan.vip/image-20230118153331838.png"><p>CPU 从逻辑上可以分为 3 个模块，分别是控制单元、运算单元和存储单元，这三部分由 CPU 内部总线连接起来。运算单元会和存储单元有很深的交流，比如运算单元计算完成后的数据会在存储单元中存储，存储单元中的数据会在运算单元中进行处理，在这个过程中，控制单元会负责对数据存储和数据处理进行控制。</p><p>几乎所有的冯·诺伊曼结构的 CPU，其工作都可以分为5个阶段：<strong>取指令、指令译码、执行指令、访存取数、结果写回</strong>。</p><ul><li><code>取指令</code>阶段是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址</li><li><code>指令译码</code>阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。</li><li><code>执行指令</code>阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。</li><li><code>访问取数</code>阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</li><li><code>结果写回</code>阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据写回到 CPU 的内部寄存器中，以便被后续的指令快速地存取；</li></ul><h3 id="计算机架构中的寄存器" tabindex="-1"><a class="header-anchor" href="#计算机架构中的寄存器" aria-hidden="true">#</a> 计算机架构中的寄存器</h3><p>寄存器是一块速度非常快的计算机内存，下面是现代计算机中具有存储功能的部件比对，可以看到，寄存器的速度是最快的，同时也是造价最高昂的。</p><p><img src="http://www.cxuan.vip/image-20230119071623979.png" alt=""></p><p>我们以 intel 8086 处理器为例来进行探讨，8086 处理器是 x86 架构的前身。在 8086 后面又衍生出来了 8088 。</p><p>在 8086 CPU 中，地址总线达到 20 根，因此最大寻址能力是 2^20 次幂也就是 1MB 的寻址能力，8088 也是如此。</p><p>在 8086 架构中，所有的内部寄存器、内部以及外部总线都是 16 位宽，可以存储两个字节，因为是完全的 16 位微处理器。8086 处理器有 14 个寄存器，每个寄存器都有一个特有的名称，即</p><p><strong>AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES</strong></p><p>这 14 个寄存器有可能进行具体的划分，按照功能可以分为三种：</p><ul><li>通用寄存器</li><li>控制寄存器</li><li>段寄存器</li></ul><p>下面我们分别介绍一下这几种寄存器。</p><h3 id="通用寄存器" tabindex="-1"><a class="header-anchor" href="#通用寄存器" aria-hidden="true">#</a> 通用寄存器</h3><p>通用寄存器主要有四种 ，即 <strong>AX、BX、CX、DX</strong> 同样的，这四个寄存器也是 16 位的，能存放两个字节。 AX、BX、CX、DX 这四个寄存器一般用来存放数据，也被称为 <code>数据寄存器</code>。它们的结构如下</p><p><img src="http://www.cxuan.vip/image-20230119071717511.png" alt=""></p><p>8086 CPU 的上一代寄存器是 8080 ，它是一类 8 位的 CPU，为了保证兼容性，8086 在 8080 上做了很小的修改，8086 中的通用寄存器 AX、BX、CX、DX 都可以独立使用两个 8 位寄存器来使用。</p><p>在细节方面，AX、BX、CX、DX 可以再向下进行划分</p><ul><li><code>AX(Accumulator Register)</code> ： 累加寄存器，它主要用于输入/输出和大规模的指令运算。</li><li><code>BX(Base Register)</code>：基址寄存器，用来存储基础访问地址。</li><li><code>CX(Count Register)</code>：计数寄存器，CX 寄存器在迭代的操作中会循环计数。</li><li><code>DX(data Register)</code>：数据寄存器，它也用于输入/输出操作。它还与 AX 寄存器以及 DX 一起使用，用于涉及大数值的乘法和除法运算。</li></ul><p>这四种寄存器可以分为高位寄存器和低位寄存器，用作 2 个 8 位数据寄存器，这两个寄存器可以单独使用，也可以一起使用，一起使用就是 AX BX CX DX。</p><ul><li><strong>AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；</strong></li><li><strong>BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；</strong></li><li><strong>CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；</strong></li><li><strong>DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；</strong></li></ul><p>除了上面 AX、BX、CX、DX 寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器 。</p><p>如下图所示。</p><p><img src="http://www.cxuan.vip/image-20230119071916082.png" alt=""></p><p>合起来就是</p><p><img src="http://www.cxuan.vip/image-20230128215334857.png" alt=""></p><p>AX 的低位（0 - 7）位构成了 AL 寄存器，高 8 位（8 - 15）位构成了 AH 寄存器。AH 和 AL 寄存器是可以使用的 8 位寄存器，其他同理。</p><p>在认识了寄存器之后，我们通过一个示例来看一下数据的具体存储方式。</p><p>比如十进制数据 19 ，它在 16 位存储器中所存储的表示如下</p><p><img src="http://www.cxuan.vip/image-20230119072044268.png" alt=""></p><p>寄存器的存储方式是先存储低位，如果低位满足不了就存储高位，如果低位能够满足，高位用 0 补全，在其他低位能满足的情况下，其余位也用 0 补全。</p><p>8086 CPU 可以一次存储两种类型的数据：</p><ul><li><code>字节(byte)</code>： 一个字节由 8 bit 组成，这是一种恒定不变的存储方式</li><li><code>字(word)</code>：字是由指令集或处理器硬件作为单元处理的固定大小的数据，对于 intel 来说，一个字长就是两个字节，字是计算机一个非常重要的特征，针对不同的指令集架构来说，计算机一次处理的数据也是不同的。也就是说，针对不同指令集的机器，一次能处理不用的字长，有字、双字（32位）、四字（64位）等。当然 8086 CPU 可以存储双字。</li></ul><h4 id="ax-寄存器" tabindex="-1"><a class="header-anchor" href="#ax-寄存器" aria-hidden="true">#</a> AX 寄存器</h4><p>我们上面探讨过，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL；在编写汇编程序中，AX 寄存器可以说是使用频率最高的寄存器。</p><p>下面是几段汇编代码</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov ax,20		/* 将 20 送入寄存器 AX*/
mov ah,80   /* 将 80 送入寄存器 AH*/
add ax,10	  /* 将寄存器 AX 中的数值加上 8 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这里注意下：上面代码中出现的是 ax、ah ，而注释中确是 AX、AH ，其实含义是一样的，不区分大小写。</p></blockquote><p>AX、DX 相比于其他通用寄存器来说，有一点比较特殊，AX、DX 具有一种特殊功能的使用，那就是使用 DIV 和 MUL 指令式使用。</p><blockquote><p>DIV 是 8086 CPU 中的<code>除法</code>指令。</p><p>MUL 是 8086 CPU 中的<code>乘法</code>指令。</p></blockquote><h4 id="bx-寄存器" tabindex="-1"><a class="header-anchor" href="#bx-寄存器" aria-hidden="true">#</a> BX 寄存器</h4><p>BX 被称为基址寄存器。同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即有 BH 和 BL。BX 除了具有暂存数据的功能外，还用于 <code>寻址</code>，即寻找物理内存地址。BX 寄存器中存放的数据一般是用来作为<code>偏移地址</code> 使用的，因为偏移地址当然是在基址地址上的偏移了。偏移地址是在段寄存器中存储的，关于段寄存器的介绍，我们后面再说。</p><h4 id="cx-寄存器" tabindex="-1"><a class="header-anchor" href="#cx-寄存器" aria-hidden="true">#</a> CX 寄存器</h4><p>CX 被称为计数寄存器。同样为了适应以前的 8 位 CPU ，而可以将 CX 当做两个独立的 8 位寄存器使用，即有 CH 和 CL。除此之外，CX 也是有其专门的用途的，如果当在汇编指令中使用循环 LOOP 指令时，可以通过 CX 来指定需要循环的次数，每次执行循环 LOOP 时候，CPU 会做两件事</p><ul><li><p>一件事是计数器自动减 1，即 CX = CX - 1。</p></li><li><p>还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令 。</p></li></ul><h4 id="dx-寄存器" tabindex="-1"><a class="header-anchor" href="#dx-寄存器" aria-hidden="true">#</a> DX 寄存器</h4><p>DX 也是被称为数据寄存器，能够暂存一般性数据，通常用于实现数据的累加操作。同样为了适应以前的 8 位 CPU ，DX 的用途其实在前面介绍 AX 寄存器时便已经有所介绍了，那就是支持 MUL 和 DIV 指令。同时也支持数值溢出等。</p><p>###段寄存器</p><p>CPU 包含四个段寄存器，用作程序指令，数据或栈的基础位置。实际上，对 IBM PC 上所有内存的引用都包含一个段寄存器作为基本位置。</p><p>段寄存器主要包含：</p><ul><li><code>CS(Code Segment)</code> ： 代码寄存器，程序代码的基础位置。</li><li><code>DS(Data Segment)</code>： 数据寄存器，变量的基本位置。</li><li><code>SS(Stack Segment)</code>： 栈寄存器，栈的基础位置。</li><li><code>ES(Extra Segment)</code>： 其他寄存器，内存中变量的其他基本位置。</li></ul><h3 id="索引寄存器" tabindex="-1"><a class="header-anchor" href="#索引寄存器" aria-hidden="true">#</a> 索引寄存器</h3><p>索引寄存器主要包含段地址的偏移量，索引寄存器主要分为：</p><ul><li><code>BP(Base Pointer)</code>：基础指针，它是栈寄存器上的偏移量，用来定位栈上变量。</li><li><code>SP(Stack Pointer)</code>: 栈指针，它是栈寄存器上的偏移量，用来定位栈顶。</li><li><code>SI(Source Index)</code>: 变址寄存器，用来拷贝源字符串。</li><li><code>DI(Destination Index)</code>: 目标变址寄存器，用来复制到目标字符串。</li></ul><h3 id="状态和控制寄存器" tabindex="-1"><a class="header-anchor" href="#状态和控制寄存器" aria-hidden="true">#</a> 状态和控制寄存器</h3><p>就剩下两种寄存器还没聊了，这两种寄存器是指令指针寄存器和标志寄存器：</p><ul><li><code>IP(Instruction Pointer)</code>： 指令指针寄存器，它是从 Code Segment 代码寄存器处的偏移来存储执行的下一条指令</li><li><code>FLAG</code> : Flag 寄存器用于存储当前进程的状态，这些状态有： <ul><li>位置 (Direction)：用于数据块的传输方向，是向上传输还是向下传输</li><li>中断标志位 (Interrupt) ：1 - 允许；0 - 禁止</li><li>陷入位 (Trap) ：确定每条指令执行完成后，CPU 是否应该停止。1 - 开启，0 - 关闭</li><li>进位 (Carry) : 设置最后一个无符号算术运算是否带有进位</li><li>溢出 (Overflow) : 设置最后一个有符号运算是否溢出</li><li>符号 (Sign) : 如果最后一次算术运算为负，则设置 1 =负，0 =正</li><li>零位 (Zero) : 如果最后一次算术运算结果为零，1 = 零</li><li>辅助进位 (Aux Carry) ：用于第三位到第四位的进位</li><li>奇偶校验 (Parity) : 用于奇偶校验</li></ul></li></ul><p>大致介绍完基本的寄存器之后，我们来认识一个很重要的概念：物理地址。</p><h2 id="物理地址" tabindex="-1"><a class="header-anchor" href="#物理地址" aria-hidden="true">#</a> 物理地址</h2><p>我们大家都知道， CPU 访问内存时，需要知道访问内存的具体地址，内存单元是内存的基本单位，每一个内存单元在内存中都有唯一的地址，这个地址即是 <code>物理地址</code>。而 CPU 和内存之间的交互有三条总线，即数据总线、控制总线和地址总线。</p><img src="http://www.cxuan.vip/image-20230120105116070.png" style="zoom:50%;"><p>CPU 通过地址总线将物理地址送入存储器，那么 CPU 是如何形成的物理地址呢？这将是我们接下来的讨论重点。</p><p>现在，我们先来讨论一下和 8086 CPU 有关的结构问题。</p><p>cxuan 和你聊了这么久，你应该知道 8086 CPU 是 16 位的 CPU 了，那么，什么是 16 位的 CPU 呢？</p><p>你可能大致听过这个回答，16 位 CPU 指的是 CPU 一次能处理的数据是 16 位的，能回答这个问题代表你的底层还不错，但是不够全面，其实，16 位的 CPU 指的是</p><ul><li>CPU 内部的运算器一次最多能处理 16 位的数据</li></ul><blockquote><p>运算器其实就是 ALU，运算控制单元，它是 CPU 内部的三大核心器件之一，主要负责数据的运算。</p></blockquote><ul><li>寄存器的最大宽度为 16 位</li></ul><blockquote><p>这个寄存器的最大宽度值得就是通用寄存器能处理的二进制数的最大位数</p></blockquote><ul><li>寄存器和运算器之间的通路为 16 位</li></ul><blockquote><p>这个指的是寄存器和运算器之间的总线，一次能传输 16 位的数据</p></blockquote><p>好了，现在你应该知道为什么叫做 16 位 CPU 了吧。</p><p>在你知道上面这个问题的答案之后，我们下面就来聊一聊如何计算物理地址。</p><p>8086 CPU 有 20 位地址总线，每一条总线都可以传输一位的地址，所以 8086 CPU 可以传送 20 位地址，也就是说，8086 CPU 可以达到 2^20 次幂的寻址能力，也就是 1MB。8086 CPU 又是 16 位的结构，从 8086 CPU 的结构看，它只能传输 16 位的地址，也就是 2^16 次幂也就是 64 KB，那么它如何达到 1MB 的寻址能力呢？</p><p>原来，8086 CPU 的内部采用两个 16 位地址合成的方式来传输一个 20 位的物理地址，如下图所示</p><img src="http://www.cxuan.vip/image-20230120105203593.png" style="zoom:50%;"><p>叙述一下上图描述的过程</p><p>CPU 中相关组件提供两个地址：段地址和偏移地址，这两个地址都是 16 位的，他们经由<code>地址加法器</code>变为 20 位的物理地址，这个地址即是输入输出控制电路传递给内存的物理地址，由此完成物理地址的转换。</p><p>地址加法器采用 <strong>物理地址 = 段地址 * 16 + 偏移地址</strong> 的方法用段地址和偏移地址合成物理地址。</p><p>下面是地址加法器的工作流程</p><p><img src="http://www.cxuan.vip/image-20230120123243525.png" alt=""></p><p>其实段地址 * 16 ，就是左移 4 位。在上面的叙述中，物理地址 = 段地址 * 16 + 偏移地址，其实就是<strong>基础地址 + 偏移地址 = 物理地址</strong> 寻址模式的一种具体实现方案。基础地址其实就等于段地址 * 16。</p><p>你可能不太清楚 <code>段</code> 的概念，下面我们就来探讨一下。</p><h3 id="什么是段" tabindex="-1"><a class="header-anchor" href="#什么是段" aria-hidden="true">#</a> 什么是段</h3><p>段这个概念经常出现在操作系统中，比如在内存管理中，操作系统会把不同的数据分成 <code>段</code>来存储，比如 <strong>代码段、数据段、bss 段、rodata 段</strong> 等。</p><p>但是这些的划分并不是内存干的，cxuan 告诉你是谁干的，这其实是幕后 Boss CPU 搞的，内存当作了声讨的对象。</p><p>其实，内存没有进行分段，分段完全是由 CPU 搞的，上面聊过的通过基础地址 + 偏移地址 = 物理地址的方式给出内存单元的物理地址，使得我们可以分段管理 CPU。</p><p>如图所示</p><p><img src="http://www.cxuan.vip/image-20230121085124315.png" alt=""></p><p>这是两个 16 KB 的程序分别被装载进内存的示意图，可以看到，这两个程序的段地址的大小都是 16380。</p><blockquote><p>这里需要注意一点， 8086 CPU 段地址的计算方式是段地址 * 16，所以，16 位的寻址能力是 2^16 次方，所以一个段的长度是 64 KB。</p></blockquote><h3 id="段寄存器" tabindex="-1"><a class="header-anchor" href="#段寄存器" aria-hidden="true">#</a> 段寄存器</h3><p>我们在合成物理地址的那张图提到了 <code>相关部件</code> 的概念，这个相关部件其实就是<code>段寄存器</code>，即 <strong>CS、DS、SS、ES</strong> 。8086 的 CPU 在访问内存时，由这四个寄存器提供内存单元的段地址。</p><h4 id="cs-寄存器" tabindex="-1"><a class="header-anchor" href="#cs-寄存器" aria-hidden="true">#</a> CS 寄存器</h4><p>要聊 CS 寄存器，那么 IP 寄存器是你绕不过去的曾经。CS 和 IP 都是 8086 CPU 非常重要的寄存器，它们会指出 CPU 当前需要读取指令的地址。</p><blockquote><p>CS 的全称是 Code Segment，即代码寄存器；而 IP 的全称是 Instruction Pointer ，即指令指针。现在知道这两个为什么一起出现了吧！</p></blockquote><p>在 8086 CPU 中，由 <code>CS:IP</code> 指向的内容当作指令执行。如下图所示</p><p><img src="http://www.cxuan.vip/image-20230121090419136.png" alt=""></p><p>说明一下上图</p><p>在 CPU 内部，由 CS、IP 提供的段地址和偏移地址，被送入加法器中被转换为物理地址，输入输出控制电路负责输入/输出数据，指令缓冲器负责缓冲指令，指令执行器负责执行指令。在内存中有一段连续存储的区域，区域内部存储的是机器码、外面是地址和汇编指令。</p><p>上面这幅图的段地址和偏移地址分别是 2000 和 0000，当这两个地址进入地址加法器后，会由地址加法器负责将这两个地址转换为物理地址。</p><p><img src="http://www.cxuan.vip/image-20230121090703510.png" alt=""></p><p>然后地址加法器负责将指令输送到输入输出控制电路中</p><p><img src="http://www.cxuan.vip/image-20230121090710503.png" alt=""></p><p>输入输出控制电路将 20 位的地址总线送到内存中。</p><p><img src="http://www.cxuan.vip/image-20230121090719845.png" alt=""></p><p>然后取出对应的数据，也就是 <strong>B8、23、01</strong>，图中的 B8、BB 都是操作数。</p><p><img src="http://www.cxuan.vip/image-20230121090736384.png" alt=""></p><p>控制输入/输出电路会将 B8 23 01 送入指令缓存器中。</p><p><img src="http://www.cxuan.vip/image-20230121090745556.png" alt=""></p><p>此时这个指令就已经具备执行条件，此时 IP 也就是指令指针会自动增加。我们上面说到 IP 其实就是从 Code Segment 也就是 CS 处偏移的地址，也就是偏移地址。它会知道下一个需要读取指令的地址，如下图所示</p><p><img src="http://www.cxuan.vip/image-20230121090800285.png" alt=""></p><p>在这之后，指令执行执行取出的 B8 23 01 这条指令。</p><p>然后下面再把 2000 和 0003 送到地址加法器中再进行后续指令的读取。后面的指令读取过程和我们上面探讨的如出一辙，这里 cxuan 就不再赘述啦。</p><p>通过对上面的描述，我们能总结一下 8086 CPU 的工作过程</p><ul><li>段寄存器提供段地址和偏移地址给地址加法器</li><li>由地址加法器计算出物理地址通过输入输出控制电路将物理地址送到内存中</li><li>提取物理地址对应的指令，经由控制电路取回并送到指令缓存器中</li><li>IP 继续指向下一条指令的地址，同时指令执行器执行指令缓冲器中的指令</li></ul><h4 id="什么是-code-segment" tabindex="-1"><a class="header-anchor" href="#什么是-code-segment" aria-hidden="true">#</a> 什么是 Code Segment</h4><p>Code Segment 即代码段，它就是我们上面聊到就是 CS 寄存器中存储的基础地址，也就是段地址，段地址其本质上就是一组内存单元的地址，例如上面的 <strong>mov ax,0123H 、mov bx, 0003H</strong>。我们可以将长度为 N 的一组代码，存放在一组连续地址的内存单元中，我们可以认为，这段内存就是用来存放代码的。</p><h4 id="ds-寄存器" tabindex="-1"><a class="header-anchor" href="#ds-寄存器" aria-hidden="true">#</a> DS 寄存器</h4><p>CPU 在读写一个内存单元的时候，需要知道这个内存单元的地址。在 8086 CPU 中，有一个 <code>DS 寄存器</code>，通常用来存放访问数据的段地址。如果你想要读取一个 10000H 的数据，你可能会需要下面这段代码</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov bx,10000H
mov ds,bx
mov al,[0]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这三条指令就把数据 1000 读取到了 al 寄存器中。</p><p>在上面汇编代码中，mov 指令有两种传送方式：</p><ul><li>一种是把数据直接送入寄存器。</li><li>一种是将一个寄存器的数据送入段寄存器。</li></ul><p>但是不仅仅如此，mov 指令还具有下面这几种表达方式：</p><table><thead><tr><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>mov 寄存器，数据</td><td>比如：mov ax,8</td></tr><tr><td>mov 寄存器，寄存器</td><td>比如：mov ax,bx</td></tr><tr><td>mov 寄存器，内存单元</td><td>比如：mov ax,[0]</td></tr><tr><td>mov 内存单元，寄存器</td><td>比如：mov[0], ax</td></tr><tr><td>mov 段寄存器，寄存器</td><td>比如：mov ds,ax</td></tr></tbody></table><h4 id="栈" tabindex="-1"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h4><p>栈我相信大部分小伙伴已经非常熟悉了，栈也是一段存储空间，只不过它具有特殊性。它的特殊性就在于，先进入 栈的元素，最后才出去，也就是我们常说的 <code>先入后出</code>。</p><p>它就像一个大的收纳箱，你可以往里面放相同类型的东西，比如书，最先放进收纳箱的书在最下面，最后放进收纳箱的书在最上面，如果你想拿书的话， 必须从最上面开始取，否则是无法取出最下面的书籍的。</p><p>栈的数据结构就是这样，你把书籍压入收纳箱的操作叫做<code>压入（push）</code>，你把书籍从收纳箱取出的操作叫做<code>弹出（pop）</code>，它的模型图大概是这样。</p><img src="http://www.cxuan.vip/image-20230121091229010.png" style="zoom:50%;"><p>入栈相当于是增加操作，出栈相当于是删除操作，只不过叫法不一样。栈和内存不同，它不需要指定元素的地址。它的大概使用如下</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 压入数据</span>
<span class="token function">push</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">push</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">push</span><span class="token punctuation">(</span><span class="token number">789</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 弹出数据</span>
j <span class="token operator">=</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
k <span class="token operator">=</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
l <span class="token operator">=</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在栈中，LIFO 方式表示栈的数组中所保存的最后面的数据（Last In）会被最先读取出来（First Out）。</p><img src="http://www.cxuan.vip/image-20230121091242308.png" style="zoom:50%;"><h4 id="栈和-ss-寄存器" tabindex="-1"><a class="header-anchor" href="#栈和-ss-寄存器" aria-hidden="true">#</a> 栈和 SS 寄存器</h4><p>下面我们就通过一段汇编代码来描述一下栈的压入弹出的过程。</p><p>8086 CPU 提供入栈和出栈指令，最基本的两个是 <code>PUSH(入栈)</code> 和 <code>POP(出栈)</code>。比如 push ax 会把 ax 寄存器中的数据压入栈中，pop ax 表示从栈顶取出数据送入 ax 寄存器中。</p><p>我这里首先有一个初始的栈，没有任何指令和数据。</p><img src="http://www.cxuan.vip/image-20230121091513324.png" style="zoom:50%;"><p>然后我们向栈中 push 数据后，栈中数据如下</p><img src="http://www.cxuan.vip/image-20230121091522188.png" style="zoom:50%;"><p>涉及的指令有</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov ax,2345H
push ax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意，数据会用两个单元存放，高地址单元存放高 8 位地址，低地址单元存放低 8 位。</p></blockquote><p>再向栈中 push 数据</p><img src="http://www.cxuan.vip/image-20230121091544670.png" style="zoom:50%;"><p>其中涉及的指令有</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov bx,0132H
push bx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在栈中有两条数据，现在我们执行出栈操作</p><img src="http://www.cxuan.vip/image-20230121091606666.png" style="zoom:50%;"><p>其中涉及的指令有</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>pop ax
/* ax = 0132H */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再继续取出数据</p><img src="http://www.cxuan.vip/image-20230121091617669.png" style="zoom:50%;"><p>涉及的指令有</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>pop bx
/* bx = */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的 push 和 pop 过程如下</p><p><img src="http://www.cxuan.vip/image-20230121091627168.png" alt=""></p><p>现在 cxuan 问你一个问题，我们上面描述的是 10000H ~ 1000FH 这段空间来作为 push 和 pop 指令的存取单元。但是，你怎么知道这个栈单元就是 10000H ~ 1000FH 呢？也就是说，你如何选择指定的栈单元进行存取？</p><p>事实上，8086 CPU 有一组关于栈的寄存器 <code>SS</code> 和 <code>SP</code>。SS 是段寄存器，它存储的是栈的基础地址，而 SP 是栈指针，它存储的是偏移地址。在任意时刻，<code>SS:SP</code> 都指向栈顶。push 和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。</p><p>现在，我们可以完整的描述一下 push 和 pop 过程了，如下图所示：</p><p><img src="http://www.cxuan.vip/image-20230121113435794.png" alt=""></p><p>上面这个过程主要涉及到的关键变化如下。</p><p>当使用 <strong>PUSH</strong> 指令向栈中压入 1 个字节单元时，SP = SP - 1；即栈顶元素会发生变化；</p><p>而当使用 <strong>PUSH</strong> 指令向栈中压入 2 个字节的字单元时，SP = SP – 2 ；即栈顶元素也要发生变化；</p><p>当使用 <strong>POP</strong> 指令从栈中弹出 1 个字节单元时， SP = SP + 1；即栈顶元素会发生变化；</p><p>当使用 <strong>POP</strong> 指令从栈中弹出 2 个字节单元的字单元时， SP = SP + 2 ；即栈顶元素会发生变化；</p><h4 id="栈顶越界问题" tabindex="-1"><a class="header-anchor" href="#栈顶越界问题" aria-hidden="true">#</a> 栈顶越界问题</h4><p>现在我们知道，8086 CPU 可以使用 SS 和 SP 指示栈顶的地址，并且提供 PUSH 和 POP 指令实现入栈和出栈，所以，你现在知道了如何能够找到栈顶位置，但是你如何能保证栈顶的位置不会越界呢？栈顶越界会产生什么影响呢？</p><p>比如如下是一个栈顶越界的示意图：</p><p><img src="http://www.cxuan.vip/image-20230121113548387.png" alt=""></p><p>第一开始，SS：SP 寄存器指向了栈顶，然后向栈空间 push 一定数量的元素后，SS:SP 位于栈空间顶部，此时再向栈空间内部 push 元素，就会出现栈顶越界问题。</p><p>栈顶越界是危险的，因为我们既然将一块区域空间安排为栈，那么在栈空间外部也可能存放了其他指令和数据，这些指令和数据有可能是其他程序的，所以如此操作会让计算机<code>懵逼</code>。</p><p>我们希望 8086 CPU 能自己解决问题，毕竟 8086 CPU 已经是个成熟的 CPU 了，要学会自己解决问题了。</p><img src="http://www.cxuan.vip/image-20230121113558718.png" style="zoom:50%;"><p>然而，这对于 8086 CPU 来说，这可能是它一辈子的 <code>夙愿</code> 了，真实情况是，8086 CPU 不会保证栈顶越界问题，也就是说 8086 CPU 只会告诉你栈顶在哪，并不会知道栈空间有多大，所以需要程序员自己手动去保证。。。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>这篇文章我大概带你了解了一下 8086 CPU 的基本结构，了解了一下常用的寄存器分类，8086 CPU 中物理地址的构造过程，以及什么是段和栈。</p><p>如果你在阅读文章的过程中发现错误和问题，请及时与我联系！</p><p>如果文章对你有帮助，希望小伙伴们三连走起！</p>`,190),l=[s];function t(d,c){return a(),p("div",null,l)}const r=e(n,[["render",t],["__file","assembly02-register.html.vue"]]);export{r as default};
