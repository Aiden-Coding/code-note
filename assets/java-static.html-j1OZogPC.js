import{_ as s,o as a,c as n,e as t}from"./app-3RcBQnkC.js";const e={},c=t(`<h1 id="深入理解-static-关键字" tabindex="-1"><a class="header-anchor" href="#深入理解-static-关键字" aria-hidden="true">#</a> 深入理解 static 关键字</h1><ul><li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-static-%E5%85%B3%E9%94%AE%E5%AD%97">深入理解 static 关键字</a><ul><li><a href="#%E5%88%9D%E8%AF%86-static-%E5%85%B3%E9%94%AE%E5%AD%97">初识 static 关键字</a><ul><li><a href="#static-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F">static 修饰变量</a></li><li><a href="#static-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95">static 修饰方法</a></li><li><a href="#static-%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97">static 修饰代码块</a></li><li><a href="#static-%E7%94%A8%E4%BD%9C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">static 用作静态内部类</a></li><li><a href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%8C%85">静态导包</a></li></ul></li><li><a href="#static-%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86">static 进阶知识</a><ul><li><a href="#%E5%85%B3%E4%BA%8E-static-%E7%9A%84%E6%89%80%E5%B1%9E%E7%B1%BB">关于 static 的所属类</a></li><li><a href="#static-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE">static 修饰变量的存储位置</a></li><li><a href="#static-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">static 变量的生命周期</a></li><li><a href="#static-%E5%BA%8F%E5%88%97%E5%8C%96">static 序列化</a></li><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F">类加载顺序</a></li><li><a href="#static-%E7%BB%8F%E5%B8%B8%E7%94%A8%E4%BD%9C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0">static 经常用作日志打印</a></li><li><a href="#static-%E7%BB%8F%E5%B8%B8%E7%94%A8%E4%BD%9C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">static 经常用作单例模式</a></li></ul></li><li><a href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E6%98%AF-static-%E7%9A%84">类的构造器是否是 static 的</a></li></ul></li></ul><p>static 是我们日常生活中经常用到的关键字，也是 Java 中非常重要的一个关键字，static 可以修饰变量、方法、做静态代码块、静态导包等，下面我们就来具体聊一聊这个关键字，我们先从基础开始，从基本用法入手，然后分析其原理、优化等。</p><h2 id="初识-static-关键字" tabindex="-1"><a class="header-anchor" href="#初识-static-关键字" aria-hidden="true">#</a> 初识 static 关键字</h2><h3 id="static-修饰变量" tabindex="-1"><a class="header-anchor" href="#static-修饰变量" aria-hidden="true">#</a> static 修饰变量</h3><p><code>static</code> 关键字表示的概念是 <code>全局的、静态的</code>，用它修饰的变量被称为<code>静态变量</code>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestStatic</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 定义了一个静态变量 i </span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>静态变量也被称为类变量，静态变量是属于这个类所有的。什么意思呢？这其实就是说，static 关键字只能定义在类的 <code>{}</code> 中，而不能定义在任何方法中。</p><p><img src="http://www.cxuan.vip/image-20230204151700269.png" alt=""></p><p>就算把方法中的 static 关键字去掉也是一样的。</p><p><img src="http://www.cxuan.vip/image-20230204151709862.png" alt=""></p><p>static 属于类所有，由类来直接调用 static 修饰的变量，它不需要手动实例化类进行调用</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestStatic</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">TestStatic</span><span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这里你需要理解几个变量的概念</strong></p><ul><li>定义在构造方法、代码块、方法<code>外</code>的变量被称为实例变量，实例变量的副本数量和实例的数量一样。</li><li>定义在方法、构造方法、代码块<code>内</code>的变量被称为局部变量；</li><li>定义在方法参数<code>中</code>的变量被称为参数。</li></ul><h3 id="static-修饰方法" tabindex="-1"><a class="header-anchor" href="#static-修饰方法" aria-hidden="true">#</a> static 修饰方法</h3><p>static 可以修饰方法，被 static 修饰的方法被称为<code>静态方法</code>，其实就是在一个方法定义中加上 <code>static</code> 关键字进行修饰，例如下面这样</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>《Java 编程思想》在 P86 页有一句经典的描述</p><p><strong>static 方法就是没有 this 的方法，在 static 内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用 static 方法，这实际上是 static 方法的主要用途</strong>。</p><p>其中有一句非常重要的话就是 <strong>static 方法就是没有 this 的方法</strong>，也就是说，可以在不用创建对象的前提下就能够访问 static 方法，如何做到呢？看下面一段代码</p><p><img src="http://www.cxuan.vip/image-20230204151725083.png" alt=""></p><p>在上面的例子中，由于 <code>staticMethod</code> 是静态方法，所以能够使用 类名.变量名进行调用。</p><p>因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为 static。平常我们见的最多的 static 方法就是 main方 法，至于为什么 main 方法必须是 static 的，现在应该很清楚了。因为程序在执行 main 方法的时候没有创建任何对象，因此只有通过类名来访问。</p><p><strong>static 修饰方法的注意事项</strong></p><ul><li>首先第一点就是最常用的，不用创建对象，直接<code>类名.变量名</code> 即可访问；</li><li>static 修饰的方法内部不能调用非静态方法；</li></ul><p><img src="http://www.cxuan.vip/image-20230204151735893.png" alt=""></p><ul><li>非静态方法内部可以调用 static 静态方法。</li></ul><p><img src="http://www.cxuan.vip/image-20230204151745628.png" alt=""></p><h3 id="static-修饰代码块" tabindex="-1"><a class="header-anchor" href="#static-修饰代码块" aria-hidden="true">#</a> static 修饰代码块</h3><p>static 关键字可以用来修饰代码块，代码块分为两种，一种是使用 <code>{}</code> 代码块；一种是 <code>static {}</code> 静态代码块。static 修饰的代码块被称为静态代码块。静态代码块可以置于类中的任何地方，类中可以有多个 static 块，在类初次被加载的时候，会按照 static 代码块的顺序来执行，每个 static 修饰的代码块只能执行一次。我们会面会说一下代码块的加载顺序。下面是静态代码块的例子</p><p><img src="http://www.cxuan.vip/image-20230204151756784.png" alt=""></p><p>static 代码块可以用来<strong>优化程序执行顺序</strong>，是因为它的特性：只会在类加载的时候执行一次。</p><h3 id="static-用作静态内部类" tabindex="-1"><a class="header-anchor" href="#static-用作静态内部类" aria-hidden="true">#</a> static 用作静态内部类</h3><p>内部类的使用场景比较少，但是内部类还有具有一些比较有用的。在了解静态内部类前，我们先看一下内部类的分类</p><ul><li>普通内部类</li><li>局部内部类</li><li>静态内部类</li><li>匿名内部类</li></ul><p><code>静态内部类</code>就是用 static 修饰的内部类，静态内部类可以包含静态成员，也可以包含非静态成员，但是在非静态内部类中不可以声明静态成员。</p><p>静态内部类有许多作用，由于非静态内部类的实例创建需要有外部类对象的引用，所以非静态内部类对象的创建必须依托于外部类的实例；而静态内部类的实例创建只需依托外部类；</p><p>并且由于非静态内部类对象持有了外部类对象的引用，因此非静态内部类可以访问外部类的非静态成员；而静态内部类只能访问外部类的静态成员；</p><ul><li>内部类需要脱离外部类对象来创建实例</li><li>避免内部类使用过程中出现内存溢出</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassDemo</span> <span class="token punctuation">{</span>
  
    <span class="token keyword">private</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticClass</span><span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
      
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//下面代码会报错，静态内部类不能访问外部类实例成员</span>
            <span class="token comment">//System.out.println(a);</span>
     
            <span class="token comment">//静态内部类只可以访问外部类类成员</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;b = &quot;</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
        <span class="token punctuation">}</span>
      
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//静态内部内所处的类中的方法，调用静态内部类的实例方法，属于外部类中调用静态内部类的实例方法</span>
            <span class="token class-name">StaticClass</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sc<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>   
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态导包" tabindex="-1"><a class="header-anchor" href="#静态导包" aria-hidden="true">#</a> 静态导包</h3><p>不知道你注意到这种现象没有，比如你使用了 <code>java.util</code> 内的工具类时，你需要导入 java.util 包，才能使用其内部的工具类，如下</p><p><img src="http://www.cxuan.vip/image-20230204151807592.png" alt=""></p><p>但是还有一种导包方式是使用<code>静态导包</code>，静态导入就是使用 <code>import static</code> 用来导入某个类或者某个包中的静态方法或者静态变量。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="static-进阶知识" tabindex="-1"><a class="header-anchor" href="#static-进阶知识" aria-hidden="true">#</a> static 进阶知识</h2><p>我们在了解了 static 关键字的用法之后，来看一下 static 深入的用法，也就是由浅入深，慢慢来，前戏要够～</p><h3 id="关于-static-的所属类" tabindex="-1"><a class="header-anchor" href="#关于-static-的所属类" aria-hidden="true">#</a> 关于 static 的所属类</h3><p>static 所修饰的属性和方法都属于类的，不会属于任何对象；它们的调用方式都是 <code>类名.属性名/方法名</code>，而实例变量和局部变量都是属于具体的对象实例。</p><h3 id="static-修饰变量的存储位置" tabindex="-1"><a class="header-anchor" href="#static-修饰变量的存储位置" aria-hidden="true">#</a> static 修饰变量的存储位置</h3><p>首先，先来认识一下 JVM 的不同存储区域。</p><p><img src="http://www.cxuan.vip/image-20230204151817230.png" alt=""></p><ul><li><p><code>虚拟机栈</code> : Java 虚拟机栈是线程私有的数据区，Java 虚拟机栈的生命周期与线程相同，虚拟机栈也是局部变量的存储位置。方法在执行过程中，会在虚拟机栈种创建一个 <code>栈帧(stack frame)</code>。</p></li><li><p><code>本地方法栈</code>: 本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 <code>native</code> 关键字修饰的方法所存储的区域</p></li><li><p><code>程序计数器</code>：程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成。</p></li><li><p><code>方法区</code>：方法区是各个线程共享的内存区域，它用于存储虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据，也就是说，<strong>static 修饰的变量存储在方法区中</strong></p></li><li><p><code>堆</code>： 堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例，包括<strong>实例变量都在堆上</strong>进行相应的分配。</p></li></ul><h3 id="static-变量的生命周期" tabindex="-1"><a class="header-anchor" href="#static-变量的生命周期" aria-hidden="true">#</a> static 变量的生命周期</h3><p>static 变量的生命周期与类的生命周期相同，随类的加载而创建，随类的销毁而销毁；普通成员变量和其所属的生命周期相同。</p><h3 id="static-序列化" tabindex="-1"><a class="header-anchor" href="#static-序列化" aria-hidden="true">#</a> static 序列化</h3><p>我们知道，序列化的目的就是为了 <strong>把 Java 对象转换为字节序列</strong>。对象转换为有序字节流，以便其能够在网络上传输或者保存在本地文件中。</p><p>声明为 static 和 transient 类型的变量不能被序列化，因为 static 修饰的变量保存在方法区中，只有堆内存才会被序列化。而 <code>transient</code> 关键字的作用就是防止对象进行序列化操作。</p><h3 id="类加载顺序" tabindex="-1"><a class="header-anchor" href="#类加载顺序" aria-hidden="true">#</a> 类加载顺序</h3><p>我们前面提到了类加载顺序这么一个概念，static 修饰的变量和静态代码块在使用前已经被初始化好了，类的初始化顺序依次是</p><p>加载父类的静态字段 -&gt; 父类的静态代码块 -&gt; 子类静态字段 -&gt; 子类静态代码块 -&gt; 父类成员变量（非静态字段）</p><p>-&gt; 父类非静态代码块 -&gt; 父类构造器 -&gt; 子类成员变量 -&gt; 子类非静态代码块 -&gt; 子类构造器</p><h3 id="static-经常用作日志打印" tabindex="-1"><a class="header-anchor" href="#static-经常用作日志打印" aria-hidden="true">#</a> static 经常用作日志打印</h3><p>我们在开发过程中，经常会使用 <code>static</code> 关键字作为日志打印，下面这行代码你应该经常看到</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> <span class="token constant">LOGGER</span> <span class="token operator">=</span> <span class="token class-name">LogFactory</span><span class="token punctuation">.</span><span class="token function">getLoggger</span><span class="token punctuation">(</span><span class="token class-name">StaticTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然而把 static 和 final 去掉都可以打印日志</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> <span class="token constant">LOGGER</span> <span class="token operator">=</span> <span class="token class-name">LogFactory</span><span class="token punctuation">.</span><span class="token function">getLoggger</span><span class="token punctuation">(</span><span class="token class-name">StaticTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">Logger</span> <span class="token constant">LOGGER</span> <span class="token operator">=</span> <span class="token class-name">LogFactory</span><span class="token punctuation">.</span><span class="token function">getLoggger</span><span class="token punctuation">(</span><span class="token class-name">StaticTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这种打印日志的方式存在问题</p><p>对于每个 StaticTest 的实例化对象都会拥有一个 LOGGER，如果创建了1000个 StaticTest 对象，则会多出1000个Logger 对象，造成资源的浪费，因此通常会将 Logger 对象声明为 static 变量，这样一来，能够减少对内存资源的占用。</p><h3 id="static-经常用作单例模式" tabindex="-1"><a class="header-anchor" href="#static-经常用作单例模式" aria-hidden="true">#</a> static 经常用作单例模式</h3><p>由于单例模式指的就是对于不同的类来说，它的副本只有一个，因此 static 可以和单例模式完全匹配。</p><p>下面是一个经典的双重校验锁实现单例模式的场景</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>
 
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>来对上面代码做一个简单的描述</p><p>使用 <code>static</code> 保证 singleton 变量是静态的，使用 <code>volatile</code> 保证 singleton 变量的可见性，使用私有构造器确保 Singleton 不能被 new 实例化。</p><p>使用 <code>Singleton.getInstance()</code> 获取 singleton 对象，首先会进行判断，如果 singleton 为空，会锁住 Singletion 类对象，这里有一些小伙伴们可能不知道为什么需要两次判断，这里来解释下</p><p>如果线程 t1 执行到 singleton == null 后，判断对象为 null，此时线程把执行权交给了 t2，t2 判断对象为 null，锁住 Singleton 类对象，进行下面的判断和实例化过程。如果不进行第二次判断的话，那么 t1 在进行第一次判空后，也会进行实例化过程，此时仍然会创建多个对象。</p><h2 id="类的构造器是否是-static-的" tabindex="-1"><a class="header-anchor" href="#类的构造器是否是-static-的" aria-hidden="true">#</a> 类的构造器是否是 static 的</h2><p>这个问题我相信大部分小伙伴都没有考虑过，在 Java 编程思想中有这么一句话 <strong>类的构造器虽然没有用 static 修饰，但是实际上是 static 方法</strong>，但是并没有给出实际的解释，但是这个问题可以从下面几个方面来回答</p><ul><li>static 最简单、最方便记忆的规则就是没有 this 引用。而在类的构造器中，是有隐含的 this 绑定的，因为构造方法是和类绑定的，从这个角度来看，构造器不是静态的。</li><li>从类的方法这个角度来看，因为 <code>类.方法名</code>不需要新创建对象就能够访问，所以从这个角度来看，构造器也不是静态的</li><li>从 JVM 指令角度去看，我们来看一个例子</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">StaticTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">StaticTest</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">StaticTest</span> staticTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用 javap -c 生成 StaticTest 的字节码看一下</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>public class test.StaticTest {
  public test.StaticTest();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: return

  public static void test();
    Code:
       0: return

  public static void main(java.lang.String[]);
    Code:
       0: invokestatic  #2                  // Method test:()V
       3: new           #3                  // class test/StaticTest
       6: dup
       7: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V
      10: astore_1
      11: return
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现，在调用 static 方法时是使用的 <code>invokestatic</code> 指令，new 对象调用的是 <code>invokespecial</code> 指令，而且在 JVM 规范中 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokestatic 说到</p><p><img src="http://www.cxuan.vip/image-20230204151830997.png" alt=""></p><p>从这个角度来讲，<code>invokestatic</code> 指令是专门用来执行 static 方法的指令；<code>invokespecial</code> 是专门用来执行实例方法的指令；从这个角度来讲，构造器也不是静态的。</p><p>如果你在阅读文章的过程中发现错误和问题，请及时与我联系！</p><p>如果文章对你有帮助，希望小伙伴们三连走起！</p>`,89),i=[c];function p(l,o){return a(),n("div",null,i)}const u=s(e,[["render",p],["__file","java-static.html.vue"]]);export{u as default};
