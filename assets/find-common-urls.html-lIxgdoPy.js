import{_ as o,r as t,o as h,c as d,a as e,b as a,d as s,e as n}from"./app-3RcBQnkC.js";const i={},u=n('<h1 id="如何从大量的-url-中找出相同的-url" tabindex="-1"><a class="header-anchor" href="#如何从大量的-url-中找出相同的-url" aria-hidden="true">#</a> 如何从大量的 URL 中找出相同的 URL？</h1><h3 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述" aria-hidden="true">#</a> 题目描述</h3><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="解答思路" tabindex="-1"><a class="header-anchor" href="#解答思路" aria-hidden="true">#</a> 解答思路</h3><h4 id="_1-分治策略" tabindex="-1"><a class="header-anchor" href="#_1-分治策略" aria-hidden="true">#</a> 1. 分治策略</h4><p>每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。</p><blockquote><p>5, 000, 000, 000 _ 64B ≈ 5GB _ 64 = 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路如下</strong>：</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>999</sub>，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b<sub>0</sub>, b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>999</sub> 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a<sub>0</sub> 对应 b<sub>0</sub>, ..., a<sub>999</sub> 对应 b<sub>999</sub>，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 a<sub>i</sub>( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 b<sub>i</sub> 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h4 id="_2-前缀树" tabindex="-1"><a class="header-anchor" href="#_2-前缀树" aria-hidden="true">#</a> 2. 前缀树</h4><p>一般而言，URL 的长度差距不会不大，而且前面几个字符，绝大部分相同。这种情况下，非常适合使用<strong>字典树</strong>（trie tree） 这种数据结构来进行存储，降低存储成本的同时，提高查询效率。</p>',13),b={href:"https://github.com/ChunelFeng",target:"_blank",rel:"noopener noreferrer"},c={href:"https://github.com/doocs/advanced-java/issues/212",target:"_blank",rel:"noopener noreferrer"},l=n('<h3 id="方法总结" tabindex="-1"><a class="header-anchor" href="#方法总结" aria-hidden="true">#</a> 方法总结</h3><h4 id="分治策略" tabindex="-1"><a class="header-anchor" href="#分治策略" aria-hidden="true">#</a> 分治策略</h4><ol><li>分而治之，进行哈希取余；</li><li>对每个子文件进行 HashSet 统计。</li></ol><h4 id="前缀树" tabindex="-1"><a class="header-anchor" href="#前缀树" aria-hidden="true">#</a> 前缀树</h4><ol><li>利用字符串的公共前缀来降低存储成本，提高查询效率。</li></ol>',5);function _(p,L){const r=t("ExternalLinkIcon");return h(),d("div",null,[u,e("blockquote",null,[e("p",null,[a("由 "),e("a",b,[a("@ChunelFeng"),s(r)]),a(" 反馈。"),e("a",c,[a("#212"),s(r)])])]),l])}const f=o(i,[["render",_],["__file","find-common-urls.html.vue"]]);export{f as default};
