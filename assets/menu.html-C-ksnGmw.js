import{_ as n,r as u,o,c as s,a as l,d as a,w as t,b as i,e}from"./app-3RcBQnkC.js";const c={},r=l("h1",{id:"java工程师成神之路",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#java工程师成神之路","aria-hidden":"true"},"#"),i(" Java工程师成神之路")],-1),d=l("p",null,"基础篇",-1),h=l("p",null,"面向对象",-1),v=l("p",null,"什么是面向对象",-1),_=l("p",null,"封装、继承、多态",-1),b=l("p",null,"平台无关性",-1),m=l("p",null,"值传递",-1),f=l("p",null,"Java基础知识",-1),J=l("p",null,"基本数据类型",-1),T=l("p",null,"自动拆装箱",-1),B=l("p",null,"String",-1),j=l("p",null,"Java中各种关键字",-1),g=l("p",null,"集合类",-1),S=l("li",null,[l("p",null,"常用集合类的使用")],-1),y=l("li",null,[l("p",null,"Java 8中Map相关的红黑树的引用背景、原理等")],-1),C=l("li",null,[l("p",null,"不同版本的JDK中HashMap的实现的区别以及原因")],-1),M=l("p",null,"枚举",-1),D=l("p",null,"IO",-1),k=l("p",null,"反射",-1),L=l("li",null,[l("p",null,[l("code",null,"java.lang.reflect.*")])],-1),A=l("p",null,"动态代理",-1),P=l("p",null,"序列化",-1),I=l("li",null,[l("p",null,"为什么序列化")],-1),x=l("p",null,"注解",-1),O=l("p",null,"泛型",-1),H=l("li",null,[l("p",null,"泛型各种用法")],-1),w=l("code",null,"List<Object>",-1),R=l("code",null,"List",-1),E=l("code",null,"List<?>",-1),z=l("code",null,"List<Object>",-1),N=l("p",null,"单元测试",-1),F=l("li",null,[l("p",null,"junit 和Spring 的结合")],-1),U=e("<li><p>正则表达式</p><ul><li><code>java.lang.util.regex.*</code></li></ul></li><li><p>常用的Java工具库</p><ul><li><p><code>commons.lang</code></p></li><li><p><code>commons.*...</code></p></li><li><p><code>guava-libraries</code></p></li><li><p><code>netty</code></p></li></ul></li>",2),V=l("p",null,"API&SPI",-1),G=l("li",null,[l("p",null,"API")],-1),X=l("p",null,"异常",-1),K=l("p",null,"时间处理",-1),Y=l("li",null,[l("p",null,"Java中时间API")],-1),Q=l("li",null,[l("p",null,"为什么日期格式化时必须有使用y表示年，而不能用Y？")],-1),q=l("p",null,"编码方式",-1),Z=l("li",null,[l("p",null,"如何解决乱码问题")],-1),W=l("p",null,"语法糖",-1),$=e("<li><p>JMS</p><ul><li><p>什么是Java消息服务</p></li><li><p>JMS消息传送模型</p></li></ul></li><li><p>JMX</p><ul><li><p>java.lang.management.*</p></li><li><p>javax.management.*</p></li></ul></li>",2),ll=l("p",null,"BigDecimal",-1),il=l("li",null,[l("p",null,"为什么0.1+0.2不等于0.3")],-1),pl=l("p",null,"Java 8",-1),al=e("<li><p>阅读源代码</p><ul><li><p>String</p></li><li><p>Integer</p></li><li><p>Long</p></li><li><p>Enum</p></li><li><p>BigDecimal</p></li><li><p>ThreadLocal</p></li><li><p>ClassLoader &amp; URLClassLoader</p></li><li><p>ArrayList &amp; LinkedList</p></li><li><p>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap</p></li><li><p>HashSet &amp; LinkedHashSet &amp; TreeSet</p></li></ul></li>",1),tl=l("p",null,"Java并发编程",-1),el=l("p",null,"并发与并行",-1),nl=l("p",null,"线程",-1),ul=l("p",null,"创建线程的多种方式",-1),ol=l("p",null,"线程池",-1),sl=l("li",null,[l("p",null,"自己设计线程池")],-1),cl=l("li",null,[l("p",null,"submit() 和 execute()")],-1),rl=l("li",null,[l("p",null,"线程池原理")],-1),dl=l("p",null,"线程安全",-1),hl=l("li",null,[l("p",null,"多级缓存和一致性问题")],-1),vl=l("li",null,[l("p",null,"CPU时间片和原子性问题")],-1),_l=l("li",null,[l("p",null,"指令重排和有序性问题")],-1),bl=l("li",null,[l("p",null,"线程安全和内存模型的关系")],-1),ml=l("li",null,[l("p",null,"happens-before")],-1),fl=l("li",null,[l("p",null,"as-if-serial")],-1),Jl=e("<li><p>锁</p><ul><li><p>可重入锁</p></li><li><p>阻塞锁</p></li><li><p>乐观锁与悲观锁</p></li><li><p>数据库相关锁机制</p></li><li><p>分布式锁</p></li></ul></li><li><p>无锁</p><ul><li><p>CAS</p></li><li><p>CAS的ABA问题</p></li></ul></li><li><p>锁优化</p><ul><li><p>偏向锁</p></li><li><p>轻量级锁</p></li><li><p>重量级锁</p></li><li><p>锁消除</p></li><li><p>锁粗化</p></li><li><p>自旋锁</p></li></ul></li>",3),Tl=l("p",null,"死锁",-1),Bl=l("li",null,[l("p",null,"死锁的原因")],-1),jl=l("li",null,[l("p",null,"如何避免死锁")],-1),gl=l("li",null,[l("p",null,"写一个死锁的程序")],-1),Sl=l("li",null,[l("p",null,"死锁问题如何排查")],-1),yl=l("p",null,"synchronized",-1),Cl=l("li",null,[l("p",null,"synchronized和lock之间关系")],-1),Ml=l("li",null,[l("p",null,"不使用synchronized如何实现一个线程安全的单例")],-1),Dl=l("li",null,[l("p",null,"synchronized和原子性")],-1),kl=l("li",null,[l("p",null,"synchronized和可见性")],-1),Ll=l("li",null,[l("p",null,"synchronized和有序性")],-1),Al=e("<li><p>volatile</p><ul><li><p>编译器指令重排和CPU指令重排</p></li><li><p>volatile的实现原理</p></li><li><p>内存屏障</p></li><li><p>volatile和原子性</p></li><li><p>volatile和可见性</p></li><li><p>volatile和有序性</p></li><li><p>有了synchronized为什么还需要volatile</p></li></ul></li><li><p>线程相关方法</p><ul><li><p>start &amp; run</p></li><li><p>sleep 和 wait</p></li><li><p>notify &amp; notifyAll</p></li></ul></li><li><p>ThreadLocal</p><ul><li><p>ThreadLocal 原理</p></li><li><p>ThreadLocal 底层的数据结构</p></li></ul></li><li><p>写代码来解决生产者消费者问题</p></li><li><p>并发包</p><ul><li><p>同步容器与并发容器</p></li><li><p>Thread</p></li><li><p>Runnable</p></li><li><p>Callable</p></li><li><p>ReentrantLock</p></li><li><p>ReentrantReadWriteLock</p></li><li><p>Atomic*</p></li><li><p>Semaphore</p></li><li><p>CountDownLatch</p></li><li><p>ConcurrentHashMap</p></li><li><p>Executors</p></li></ul></li>",5),Pl=l("p",null,"底层篇",-1),Il=l("p",null,"JVM",-1),xl=l("p",null,"JVM内存结构",-1),Ol=l("li",null,[l("p",null,"运行时数据区")],-1),Hl=l("li",null,[l("p",null,"堆和栈区别")],-1),wl=l("li",null,[l("p",null,"方法区在不同版本JDK中的位置")],-1),Rl=l("li",null,[l("p",null,"堆外内存")],-1),El=l("li",null,[l("p",null,"TLAB")],-1),zl=e("<li><p>垃圾回收</p><ul><li><p>GC算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收</p></li><li><p>GC参数</p></li><li><p>对象存活的判定</p></li><li><p>垃圾收集器（CMS、G1、ZGC、Epsilon）</p></li></ul></li><li><p>JVM参数及调优</p><ul><li><p>-Xmx</p></li><li><p>-Xmn</p></li><li><p>-Xms</p></li><li><p>-Xss</p></li><li><p>-XX:SurvivorRatio</p></li><li><p>-XX:PermSize</p></li><li><p>-XX:MaxPermSize</p></li><li><p>-XX:MaxTenuringThreshold</p></li></ul></li><li><p>Java对象模型</p><ul><li><p>oop-klass</p></li><li><p>对象头</p></li></ul></li><li><p>HotSpot</p><ul><li><p>即时编译器</p></li><li><p>编译优化</p></li></ul></li><li><p>Java内存模型</p><ul><li><p>计算机内存模型</p></li><li><p>缓存一致性</p></li><li><p>MESI协议</p></li><li><p>可见性</p></li><li><p>原子性</p></li><li><p>顺序性</p></li><li><p>happens-before</p></li><li><p>as-if-serial</p></li><li><p>内存屏障</p></li><li><p>synchronized</p></li><li><p>volatile</p></li><li><p>final</p></li><li><p>锁</p></li></ul></li>",5),Nl=e("<li><p>虚拟机性能监控与故障处理工具</p><ul><li><p>jps</p></li><li><p>jstack</p></li><li><p>jmap</p></li><li><p>jstat</p></li><li><p>jconsole</p></li><li><p>jinfo</p></li><li><p>jhat</p></li><li><p>javap</p></li><li><p>btrace</p></li><li><p>TProfiler</p></li><li><p>jlink</p></li><li><p>Arthas</p></li></ul></li>",1),Fl=l("p",null,"类加载机制",-1),Ul=l("li",null,[l("p",null,"classLoader")],-1),Vl=l("li",null,[l("p",null,"类加载过程是线程安全的吗？")],-1),Gl=l("li",null,[l("p",null,"类加载过程")],-1),Xl=l("li",null,[l("p",null,"如何判断JVM中类和其他类是不是同一个类")],-1),Kl=l("li",null,[l("p",null,"打包工具"),l("ul",null,[l("li",null,[l("p",null,"jar")]),l("li",null,[l("p",null,"jlink")]),l("li",null,[l("p",null,"jpackage")])])],-1),Yl=l("p",null,"编译与反编译",-1),Ql=l("li",null,[l("p",null,"什么是编译")],-1),ql=l("li",null,[l("p",null,"什么是反编译")],-1),Zl=l("li",null,[l("p",null,"编译工具：javac")],-1),Wl=l("li",null,[l("p",null,"反编译工具：javap 、jad 、CRF")],-1),$l=l("li",null,[l("p",null,"JIT"),l("ul",null,[l("li",null,"JIT优化（逃逸分析、栈上分配、标量替换、锁优化）")])],-1),li=l("p",null,"进阶篇",-1),ii=l("li",null,[l("p",null,"Java底层知识"),l("ul",null,[l("li",null,[l("p",null,"字节码")]),l("li",null,[l("p",null,"class文件格式")]),l("li",null,[l("p",null,"CAFEBABE")])])],-1),pi=l("li",null,[l("p",null,"位运算"),l("ul",null,[l("li",null,"用位运算实现加、减、乘、除、取余")])],-1),ai=l("p",null,"设计模式",-1),ti=e("<li><p>设计模式的六大原则</p><ul><li><p>开闭原则（Open Close Principle）</p></li><li><p>里氏代换原则（Liskov Substitution Principle）</p></li><li><p>依赖倒转原则（Dependence Inversion Principle）</p></li><li><p>接口隔离原则（Interface Segregation Principle）</p></li><li><p>迪米特法则（最少知道原则）（Demeter Principle）</p></li><li><p>合成复用原则（Composite Reuse Principle）</p></li></ul></li>",1),ei=l("p",null,"创建型设计模式",-1),ni=l("li",null,[l("p",null,"原型模式")],-1),ui=l("p",null,"结构型设计模式",-1),oi=l("li",null,[l("p",null,"桥接模式")],-1),si=l("li",null,[l("p",null,"装饰模式")],-1),ci=l("li",null,[l("p",null,"组合模式")],-1),ri=l("li",null,[l("p",null,"外观模式")],-1),di=l("li",null,[l("p",null,"享元模式")],-1),hi=l("li",null,[l("p",null,"代理模式")],-1),vi=l("p",null,"行为型设计模式",-1),_i=l("li",null,[l("p",null,"模版方法模式")],-1),bi=l("li",null,[l("p",null,"命令模式")],-1),mi=l("li",null,[l("p",null,"观察者模式")],-1),fi=l("li",null,[l("p",null,"中介者模式")],-1),Ji=l("li",null,[l("p",null,"备忘录模式")],-1),Ti=l("li",null,[l("p",null,"解释器模式")],-1),Bi=l("li",null,[l("p",null,"状态模式")],-1),ji=l("li",null,[l("p",null,"责任链模式")],-1),gi=l("li",null,[l("p",null,"访问者模式")],-1),Si=e("<li><p>单例的七种写法</p><ul><li><p>懒汉——线程不安全</p></li><li><p>懒汉——线程安全</p></li><li><p>饿汉</p></li><li><p>饿汉——变种</p></li><li><p>静态内部类</p></li><li><p>枚举</p></li><li><p>双重校验锁</p></li></ul></li><li><p>为什么推荐使用枚举实现单例？</p></li><li><p>三种工厂模式的区别及联系</p><ul><li>简单工厂、工厂方法、模板工厂</li></ul></li><li><p>会使用常用设计模式</p><ul><li><p>工厂模式</p></li><li><p>适配器模式</p></li><li><p>策略模式</p></li><li><p>模板方法模式</p></li><li><p>观察者模式</p></li><li><p>外观模式</p></li><li><p>代理模式</p></li></ul></li><li><p>不用synchronized和lock，实现线程安全的单例模式</p></li><li><p>nio和reactor设计模式</p></li><li><p>Spring中用到了哪些设计模式</p></li>",7),yi=e("<li><p>网络编程知识</p><ul><li><p>常用协议</p><ul><li><p>tcp、udp、http、https</p></li><li><p>用Java实现FTP、SMTP协议</p></li></ul></li><li><p>OSI七层模型</p><ul><li>每一层的主要协议</li></ul></li><li><p>TCP/UDP</p><ul><li><p>三次握手与四次关闭</p></li><li><p>流量控制和拥塞控制</p></li><li><p>tcp粘包与拆包</p></li></ul></li><li><p>TCP/IP</p><ul><li><p>IPV4</p></li><li><p>IPV6</p></li></ul></li><li><p>HTTP</p><ul><li><p>http/1.0 http/1.1 http/2之间的区别</p></li><li><p>http和https的区别</p></li><li><p>http中 get和post区别</p></li><li><p>常见的web请求返回的状态码</p></li><li><p>404、302、301、500分别代表什么</p></li><li><p>用Java写一个简单的静态文件的HTTP服务器</p></li></ul></li><li><p>HTTP/2</p><ul><li>HTTP/2 存在哪些问题？</li></ul></li><li><p>HTTP/3</p></li><li><p>Java RMI，Socket，HttpClient</p></li><li><p>cookie 与 session</p><ul><li>cookie被禁用，如何实现session</li></ul></li><li><p>了解nginx和apache服务器的特性并搭建一个对应的服务器</p></li><li><p>进程间通讯的方式</p></li><li><p>什么是CDN？如果实现？</p></li><li><p>DNS？</p><ul><li><p>什么是DNS</p></li><li><p>记录类型:A记录、CNAME记录、AAAA记录等</p></li><li><p>域名解析</p></li><li><p>根域名服务器</p></li><li><p>DNS污染</p></li><li><p>DNS劫持</p></li><li><p>公共DNS：114 DNS、Google DNS、OpenDNS</p></li></ul></li><li><p>反向代理</p><ul><li><p>正向代理</p></li><li><p>反向代理</p></li><li><p>反向代理服务器</p></li></ul></li></ul></li><li><p>框架知识</p><ul><li><p>Servlet</p><ul><li><p>生命周期</p></li><li><p>线程安全问题</p></li><li><p>filter和listener</p></li><li><p>web.xml中常用配置及作用</p></li></ul></li><li><p>Hibernate</p><ul><li><p>什么是OR Mapping</p></li><li><p>Hibernate的缓存机制</p></li><li><p>Hibernate的懒加载</p></li><li><p>Hibernate/Ibatis/MyBatis之间的区别</p></li></ul></li><li><p>MyBatis</p><ul><li><p>Mybatis缓存机制</p></li><li><p><code>#{}</code>和<code>${}</code>的区别</p></li><li><p>mapper中传递多个参数</p></li><li><p>Mybatis动态sql</p></li><li><p>Mybatis的延迟加载</p></li></ul></li><li><p>Spring</p><ul><li><p>Bean的初始化</p></li><li><p>AOP原理</p></li><li><p>Spring AOP不支持方法自调用的问题</p></li><li><p>实现Spring的IOC</p></li><li><p>spring四种依赖注入方式</p></li><li><p>为什么我不建议使用@Transactional声明事务</p></li></ul></li><li><p>Spring MVC</p><ul><li><p>什么是MVC</p></li><li><p>Spring mvc与Struts mvc的区别</p></li></ul></li><li><p>Spring Boot</p><ul><li><p>Spring Boot 2.0</p></li><li><p>起步依赖</p></li><li><p>自动配置</p></li><li><p>Spring Boot的starter原理</p></li><li><p>自己实现一个starter</p></li><li><p>为什么Spring Boot可以通过main启动web项目</p></li></ul></li><li><p>Spring Security</p></li><li><p>Spring Cloud</p><ul><li><p>服务发现与注册：Eureka、Zookeeper、Consul</p></li><li><p>负载均衡：Feign、Spring Cloud Loadbalance</p></li><li><p>服务配置：Spring Cloud Config</p></li><li><p>服务限流与熔断：Hystrix</p></li><li><p>服务链路追踪：Dapper</p></li><li><p>服务网关、安全、消息</p></li></ul></li></ul></li><li><p>应用服务器知识</p><ul><li><p>JBoss</p></li><li><p>tomcat</p></li><li><p>jetty</p></li><li><p>Weblogic</p></li></ul></li><li><p>工具</p><ul><li><p>git &amp; svn</p></li><li><p>maven &amp; gradle</p></li><li><p>git技巧</p><ul><li><p>分支合并</p></li><li><p>冲突解决</p></li><li><p>提交回滚</p></li></ul></li><li><p>maven技巧</p><ul><li><p>依赖树</p></li><li><p>依赖仲裁</p></li></ul></li><li><p>Intellij IDEA</p><ul><li>常用插件：Maven Helper、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat、Lombok plugin、.ignore、Mybatis plugin</li></ul></li></ul></li>",4),Ci=e("<li><p>高级篇</p><ul><li><p>新技术</p><ul><li><p>Java 9</p><ul><li>Jigsaw</li><li>Jshell</li><li>Reactive Streams</li></ul></li><li><p>Java 10</p><ul><li>局部变量类型推断</li><li>G1的并行Full GC</li><li>ThreadLocal握手机制</li></ul></li><li><p>Java 11</p><ul><li>ZGC</li><li>Epsilon</li><li>增强var</li></ul></li><li><p>Java 12</p><ul><li>Switch 表达式</li></ul></li><li><p>Java 13</p><ul><li>Text Blocks</li><li>Dynamic CDS Archives</li></ul></li><li><p>Java 14</p><ul><li><p>Java打包工具</p></li><li><p>更有价值的NullPointerException</p></li><li><p>record类型</p></li></ul></li><li><p>Spring 5</p><ul><li>响应式编程</li></ul></li><li><p>Spring Boot 2.0</p></li><li><p>http/2</p></li><li><p>http/3</p></li></ul></li><li><p>性能优化</p><ul><li><p>使用单例</p></li><li><p>使用Future模式</p></li><li><p>使用线程池</p></li><li><p>选择就绪</p></li><li><p>减少上下文切换</p></li><li><p>减少锁粒度</p></li><li><p>数据压缩</p></li><li><p>结果缓存</p></li><li><p>Stream并行流</p></li><li><p>GC调优</p></li><li><p>JVM内存分配调优</p></li><li><p>SQL调优</p></li></ul></li><li><p>线上问题分析</p><ul><li><p>dump</p><ul><li><p>线程Dump</p></li><li><p>内存Dump</p></li><li><p>gc情况</p></li></ul></li><li><p>dump获取及分析工具</p><ul><li><p>jstack</p></li><li><p>jstat</p></li><li><p>jmap</p></li><li><p>jhat</p></li><li><p>Arthas</p></li></ul></li><li><p>dump分析死锁</p></li><li><p>dump分析内存泄露</p></li><li><p>自己编写各种outofmemory，stackoverflow程序</p><ul><li><p>HeapOutOfMemory</p></li><li><p>Young OutOfMemory</p></li><li><p>MethodArea OutOfMemory</p></li><li><p>ConstantPool OutOfMemory</p></li><li><p>DirectMemory OutOfMemory</p></li><li><p>Stack OutOfMemory Stack OverFlow</p></li></ul></li><li><p>Arthas</p><ul><li><p>jvm相关</p></li><li><p>class/classloader相关</p></li><li><p>monitor/watch/trace相关</p></li><li><p>options</p></li><li><p>管道</p></li><li><p>后台异步任务</p></li></ul></li><li><p>常见问题解决思路</p><ul><li><p>内存溢出</p></li><li><p>线程死锁</p></li><li><p>类加载冲突</p></li><li><p>load飙高</p></li><li><p>CPU利用率飙高</p></li><li><p>慢SQL</p></li></ul></li><li><p>使用工具尝试解决以下问题，并写下总结</p><ul><li><p>当一个Java程序响应很慢时如何查找问题</p></li><li><p>当一个Java程序频繁FullGC时如何解决问题</p></li><li><p>如何查看垃圾回收日志</p></li><li><p>当一个Java应用发生OutOfMemory时该如何解决</p></li><li><p>如何判断是否出现死锁</p></li><li><p>如何判断是否存在内存泄露</p></li><li><p>使用Arthas快速排查Spring Boot应用404/401问题</p></li><li><p>使用Arthas排查线上应用日志打满问题</p></li><li><p>利用Arthas排查Spring Boot应用NoSuchMethodError</p></li></ul></li></ul></li><li><p>编译原理知识</p><ul><li><p>编译与反编译</p></li><li><p>Java代码的编译与反编译</p></li><li><p>Java的反编译工具</p><ul><li><p>javap</p></li><li><p>jad</p></li><li><p>CRF</p></li></ul></li><li><p>即时编译器</p><ul><li>编译器优化</li></ul></li></ul></li><li><p>操作系统知识</p><ul><li><p>Linux的常用命令</p><ul><li><p>find、grep、ps、cp、move、tar、head、tail、netstat、lsof、tree、wget、curl、ping、ssh、echo、free、top</p></li><li><p>为什么kill -9 不能随便执行</p></li><li><p>rm一个被打开的文件会发生什么</p></li></ul></li><li><p>进程间通信</p></li><li><p>服务器性能指标</p><ul><li><p>load</p></li><li><p>CPU利用率</p></li><li><p>内存使用情况</p></li><li><p>qps</p></li><li><p>rt</p></li></ul></li><li><p>进程同步</p><ul><li><p>生产者消费者问题</p></li><li><p>哲学家就餐问题</p></li><li><p>读者写者问题</p></li></ul></li><li><p>缓冲区溢出</p></li><li><p>分段和分页</p></li><li><p>虚拟内存与主存</p></li><li><p>虚拟内存管理</p></li><li><p>换页算法</p></li></ul></li><li><p>数据库知识</p><ul><li><p>MySql 执行引擎</p></li><li><p>MySQL 执行计划</p><ul><li><p>如何查看执行计划</p></li><li><p>如何根据执行计划进行SQL优化</p></li></ul></li><li><p>索引</p><ul><li><p>Hash索引&amp;B树索引</p></li><li><p>普通索引&amp;唯一索引</p></li><li><p>聚集索引&amp;非聚集索引</p></li><li><p>覆盖索引</p></li><li><p>最左前缀原则</p></li><li><p>索引下推</p></li><li><p>索引失效</p></li></ul></li><li><p>回表</p></li><li><p>SQL优化</p></li><li><p>数据库事务和隔离级别</p><ul><li><p>事务的ACID</p></li><li><p>事务的隔离级别与读现象</p></li><li><p>事务能不能实现锁的功能</p></li></ul></li><li><p>编码方式</p><ul><li><p>utf8</p></li><li><p>utf8mb4</p></li><li><p>为什么不要在数据库中使用utf8编码</p></li></ul></li><li><p>行数统计</p><ul><li><p>count(1)、count(*)、count(字段)的区别</p></li><li><p>为什么建议使用count(*)</p></li></ul></li><li><p>数据库锁</p><ul><li><p>共享锁、排它锁</p></li><li><p>行锁、表锁</p></li><li><p>乐观锁、悲观锁</p></li><li><p>使用数据库锁实现乐观锁</p></li><li><p>Gap Lock、Next-Key Lock</p></li></ul></li><li><p>连接</p><ul><li><p>内连接</p></li><li><p>左连接</p></li><li><p>右连接</p></li></ul></li><li><p>数据库主备搭建</p></li><li><p>log</p><ul><li><p>binlog</p></li><li><p>redolog</p></li></ul></li><li><p>内存数据库</p><ul><li>h2</li></ul></li><li><p>分库分表</p></li><li><p>读写分离</p></li><li><p>常用的nosql数据库</p><ul><li><p>redis</p></li><li><p>memcached</p></li></ul></li><li><p>Redis</p><ul><li>Redis多线程</li></ul></li><li><p>分别使用数据库锁、NoSql实现分布式锁</p></li><li><p>性能调优</p></li><li><p>数据库连接池</p></li></ul></li><li><p>数据结构与算法知识</p><ul><li><p>简单的数据结构</p><ul><li><p>栈</p></li><li><p>队列</p></li><li><p>链表</p></li><li><p>数组</p></li><li><p>哈希表</p></li><li><p>栈和队列的相同和不同之处</p></li><li><p>栈通常采用的两种存储结构</p></li><li><p>两个栈实现队列，和两个队列实现栈</p></li></ul></li><li><p>树</p><ul><li><p>二叉树</p></li><li><p>字典树</p></li><li><p>平衡树</p></li><li><p>排序树</p></li><li><p>B树</p></li><li><p>B+树</p></li><li><p>R树</p></li><li><p>多路树</p></li><li><p>红黑树</p></li></ul></li><li><p>堆</p><ul><li><p>大根堆</p></li><li><p>小根堆</p></li></ul></li><li><p>图</p><ul><li><p>有向图</p></li><li><p>无向图</p></li><li><p>拓扑</p></li></ul></li><li><p>稳定的排序算法</p><ul><li>冒泡排序</li><li>插入排序</li><li>鸡尾酒排序</li><li>桶排序</li><li>计数排序</li><li>归并排序</li><li>原地归并排序</li><li>二叉排序树排序</li><li>鸽巢排序</li><li>基数排序</li><li>侏儒排序</li><li>图书馆排序</li><li>块排序</li></ul></li><li><p>不稳定的排序算法</p><ul><li>选择排序</li><li>希尔排序</li><li>Clover排序算法</li><li>梳排序</li><li>堆排序</li><li>平滑排序</li><li>快速排序</li><li>内省排序</li><li>耐心排序</li></ul></li><li><p>各种排序算法和时间复杂度</p></li><li><p>深度优先和广度优先搜索</p></li><li><p>全排列</p></li><li><p>贪心算法</p></li><li><p>KMP算法</p></li><li><p>hash算法</p></li><li><p>海量数据处理</p><ul><li>分治</li><li>hash映射</li><li>堆排序</li><li>双层桶划分</li><li>Bloom Filter</li><li>bitmap</li><li>数据库索引</li><li>mapreduce等。</li></ul></li></ul></li><li><p>大数据知识</p><ul><li><p>搜索</p><ul><li><p>Solr</p></li><li><p>Lucene</p></li><li><p>ElasticSearch</p></li></ul></li><li><p>流式计算</p><ul><li><p>Storm</p></li><li><p>Spark</p></li><li><p>Flink</p></li></ul></li><li><p>Hadoop，离线计算</p><ul><li><p>HDFS</p></li><li><p>MapReduce</p></li></ul></li><li><p>分布式日志收集</p><ul><li><p>flume</p></li><li><p>kafka</p></li><li><p>logstash</p></li></ul></li><li><p>数据挖掘</p><ul><li>mahout</li></ul></li></ul></li><li><p>网络安全知识</p><ul><li><p>XSS</p><ul><li>XSS的防御</li></ul></li><li><p>CSRF</p></li><li><p>注入攻击</p><ul><li>SQL注入</li><li>XML注入</li><li>CRLF注入</li></ul></li><li><p>文件上传漏洞</p></li><li><p>加密与解密</p><ul><li>对称加密</li><li>非对称加密</li><li>哈希算法</li><li>加盐哈希算法</li></ul></li><li><p>加密算法</p><ul><li>MD5，SHA1、DES、AES、RSA、DSA</li></ul></li><li><p>彩虹表</p></li><li><p>DDOS攻击</p><ul><li><p>DOS攻击</p></li><li><p>DDOS攻击</p></li><li><p>memcached为什么可以导致DDos攻击</p></li><li><p>什么是反射型DDoS</p></li><li><p>如何通过Hash碰撞进行DOS攻击</p></li></ul></li><li><p>SSL、TLS，HTTPS</p></li><li><p>脱库、洗库、撞库</p></li></ul></li></ul></li><li><p>架构篇</p><ul><li><p>架构设计原则</p><ul><li><p>单一职责原则</p></li><li><p>开放封闭原则</p></li><li><p>里氏替代原则</p></li><li><p>依赖倒置原则</p></li><li><p>接口分离原则</p></li></ul></li><li><p>分布式</p><ul><li><p>分布式理论</p><ul><li><p>2PC</p></li><li><p>3PC</p></li><li><p>CAP</p></li><li><p>BASE</p></li></ul></li><li><p>分布式协调 Zookeeper</p><ul><li><p>基本概念</p></li><li><p>常见用法</p></li><li><p>ZAB算法</p></li><li><p>脑裂</p></li></ul></li><li><p>分布式事务</p><ul><li><p>本地事务&amp;分布式事务</p></li><li><p>可靠消息最终一致性</p></li><li><p>最大努力通知</p></li><li><p>TCC</p></li></ul></li><li><p>Dubbo</p><ul><li>服务注册</li><li>服务发现</li><li>服务治理</li></ul></li><li><p>分布式数据库</p><ul><li><p>怎样打造一个分布式数据库</p></li><li><p>什么时候需要分布式数据库</p></li><li><p>mycat</p></li><li><p>otter</p></li><li><p>HBase</p></li></ul></li><li><p>分布式文件系统</p><ul><li>mfs</li><li>fastdfs</li></ul></li><li><p>分布式缓存</p><ul><li>缓存一致性</li><li>缓存命中率</li><li>缓存冗余</li></ul></li><li><p>限流降级</p><ul><li><p>熔断器模式</p></li><li><p>Hystrix</p></li><li><p>Sentinal</p></li><li><p>resilience4j</p></li></ul></li><li><p>分布式算法</p><ul><li><p>拜占庭问题与算法</p></li><li><p>2PC</p></li><li><p>3PC</p></li><li><p>共识算法</p></li><li><p>Paxos 算法与 Raft 算法</p></li><li><p>ZAB算法</p></li></ul></li></ul></li><li><p>领域驱动设计</p><ul><li><p>实体、值对象</p></li><li><p>聚合、聚合根</p></li><li><p>限界上下文</p></li><li><p>DDD如何分层</p></li><li><p>充血模型和贫血模型</p></li><li><p>DDD和微服务有什么关系</p></li></ul></li><li><p>微服务</p><ul><li><p>SOA</p></li><li><p>康威定律</p></li><li><p>ServiceMesh</p><ul><li>sidecar</li></ul></li><li><p>Docker &amp; Kubernets</p></li><li><p>Spring Boot</p></li><li><p>Spring Cloud</p></li></ul></li><li><p>高并发</p><ul><li><p>分库分表</p><ul><li><p>横向拆分与水平拆分</p></li><li><p>分库分表后的分布式事务问题</p></li></ul></li><li><p>CDN技术</p></li><li><p>消息队列</p><ul><li><p>RabbitMQ、RocketMQ、ActiveMQ、Kafka</p></li><li><p>各个消息队列的对比</p></li></ul></li></ul></li><li><p>高可用</p><ul><li><p>双机架构</p><ul><li><p>主备复制</p></li><li><p>主从复制</p></li><li><p>主主复制</p></li></ul></li><li><p>异地多活</p></li><li><p>预案</p></li><li><p>预热</p></li><li><p>限流</p></li></ul></li><li><p>高性能</p><ul><li><p>高性能数据库</p><ul><li><p>读写分离</p></li><li><p>分库分表</p></li></ul></li><li><p>高性能缓存</p><ul><li><p>缓存穿透</p></li><li><p>缓存雪崩</p></li><li><p>缓存热点</p></li></ul></li><li><p>负载均衡</p></li><li><p>PPC、TPC</p></li></ul></li><li><p>监控</p><ul><li><p>监控什么</p><ul><li><p>CPU</p></li><li><p>内存</p></li><li><p>磁盘I/O</p></li><li><p>网络I/O</p></li></ul></li><li><p>监控手段</p><ul><li><p>进程监控</p></li><li><p>语义监控</p></li><li><p>机器资源监控</p></li><li><p>数据波动</p></li></ul></li><li><p>监控数据采集</p><ul><li>日志</li><li>埋点</li></ul></li><li><p>Dapper</p></li></ul></li><li><p>负载均衡</p><ul><li><p>负载均衡分类</p><ul><li><p>二层负载均衡</p></li><li><p>三层负载均衡</p></li><li><p>四层负载均衡</p></li><li><p>七层负载均衡</p></li></ul></li><li><p>负载均衡工具</p><ul><li><p>LVS</p></li><li><p>Nginx</p></li><li><p>HAProxy</p></li></ul></li><li><p>负载均衡算法</p><ul><li><p>静态负载均衡算法：轮询，比率，优先权</p></li><li><p>动态负载均衡算法: 最少连接数,最快响应速度，观察方法，预测法，动态性能分配，动态服务器补充，服务质量，服务类型，规则模式。</p></li></ul></li></ul></li><li><p>DNS</p><ul><li><p>DNS原理</p></li><li><p>DNS的设计</p></li></ul></li><li><p>CDN</p><ul><li>数据一致性</li></ul></li></ul></li><li><p>扩展篇</p><ul><li><p>云计算</p><ul><li><p>IaaS</p></li><li><p>SaaS</p></li><li><p>PaaS</p></li><li><p>虚拟化技术</p></li><li><p>openstack</p></li><li><p>Serverlsess</p></li></ul></li><li><p>搜索引擎</p><ul><li><p>Solr</p></li><li><p>Lucene</p></li><li><p>Nutch</p></li><li><p>Elasticsearch</p></li></ul></li><li><p>权限管理</p><ul><li>Shiro</li></ul></li><li><p>区块链</p><ul><li><p>哈希算法</p></li><li><p>Merkle树</p></li><li><p>公钥密码算法</p></li><li><p>共识算法</p></li><li><p>Raft协议</p></li><li><p>Paxos 算法与 Raft 算法</p></li><li><p>拜占庭问题与算法</p></li><li><p>消息认证码与数字签名</p></li><li><p>比特币</p><ul><li>挖矿</li><li>共识机制</li><li>闪电网络</li><li>侧链</li><li>热点问题</li><li>分叉</li></ul></li><li><p>以太坊</p><ul><li>超级账本</li></ul></li></ul></li><li><p>人工智能</p><ul><li><p>数学基础</p></li><li><p>机器学习</p></li><li><p>人工神经网络</p></li><li><p>深度学习</p></li><li><p>应用场景</p></li><li><p>常用框架</p><ul><li>TensorFlow</li><li>DeepLearning4J</li></ul></li></ul></li><li><p>IoT</p></li><li><p>量子计算</p></li><li><p>AR &amp; VR</p></li><li><p>其他语言</p><ul><li><p>Groovy</p></li><li><p>Kotlin</p></li><li><p>Python</p></li><li><p>Go</p></li><li><p>NodeJs</p></li><li><p>Swift</p></li><li><p>Rust</p></li></ul></li></ul></li>",3);function Mi(Di,ki){const p=u("RouterLink");return o(),s("div",null,[r,l("ul",null,[l("li",null,[d,l("ul",null,[l("li",null,[h,l("ul",null,[l("li",null,[v,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/object-oriented-vs-procedure-oriented.html"},{default:t(()=>[i("面向对象与面向过程")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/characteristics.html"},{default:t(()=>[i("面向对象的三大基本特征")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/principle.html"},{default:t(()=>[i("面向对象的五大基本原则")]),_:1})])])])]),l("li",null,[_,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/polymorphism.html"},{default:t(()=>[i("什么是多态")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/overloading-vs-overriding.html"},{default:t(()=>[i("方法重写与重载")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/extends-implement.html"},{default:t(()=>[i("Java的继承与实现")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/multiple-inheritance.html"},{default:t(()=>[i("Java为什么不支持多继承")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/inheritance-composition.html"},{default:t(()=>[i("Java的继承与组合")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/constructor.html"},{default:t(()=>[i("构造函数与默认构造函数")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/variable.html"},{default:t(()=>[i("类变量、成员变量和局部变量")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/scope.html"},{default:t(()=>[i("成员变量和方法作用域")]),_:1})])])])]),l("li",null,[b,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/platform-independent.html"},{default:t(()=>[i("Java如何实现的平台无关性的")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/jvm-language.html"},{default:t(()=>[i("JVM还支持哪些语言")]),_:1})])])])]),l("li",null,[m,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/java-pass-by.html"},{default:t(()=>[i("值传递、引用传递")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/object-oriented/why-pass-by-reference.html"},{default:t(()=>[i("为什么说Java中只有值传递")]),_:1})])])])])])]),l("li",null,[f,l("ul",null,[l("li",null,[J,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/basic-data-types.html"},{default:t(()=>[i("8种基本数据类型")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/integer-scope.html"},{default:t(()=>[i("整型中byte、short、int、long的取值范围")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/float.html"},{default:t(()=>[i("什么是浮点型？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/single-double-float.html"},{default:t(()=>[i("什么是单精度和双精度？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/float-amount.html"},{default:t(()=>[i("为什么不能用浮点型表示金额？")]),_:1})])])])]),l("li",null,[T,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/boxing-unboxing.html"},{default:t(()=>[i("自动拆装箱")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/integer-cache.html"},{default:t(()=>[i("Integer的缓存机制")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/success-isSuccess-and-boolean-Boolean.html"},{default:t(()=>[i("如何正确定义接口的返回值(boolean/Boolean)类型及命名(success/isSuccess)")]),_:1})])])])]),l("li",null,[B,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/final-string.html"},{default:t(()=>[i("字符串的不可变性")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/substring.html"},{default:t(()=>[i("JDK 6和JDK 7中substring的原理及区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/replace-in-string.html"},{default:t(()=>[i("replaceFirst、replaceAll、replace区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/string-append.html"},{default:t(()=>[i("String对“+”的重载")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/string-concat.html"},{default:t(()=>[i("字符串拼接的几种方式和区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/stringjoiner-in-java8.html"},{default:t(()=>[i("Java 8中的StringJoiner")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/value-of-vs-to-string.html"},{default:t(()=>[i("String.valueOf和Integer.toString的区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/switch-string.html"},{default:t(()=>[i("switch对String的支持")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/string-pool.html"},{default:t(()=>[i("字符串池")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/class-contant-pool.html"},{default:t(()=>[i("Class常量池")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/Runtime-Constant-Pool.html"},{default:t(()=>[i("运行时常量池")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/intern.html"},{default:t(()=>[i("intern")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/length-of-string.html"},{default:t(()=>[i("String有没有长度限制？")]),_:1})])])])]),l("li",null,[j,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/transient-in-java.html"},{default:t(()=>[i("transient")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/instanceof-in-java.html"},{default:t(()=>[i("instanceof")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/volatile.html"},{default:t(()=>[i("volatile")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/synchronized.html"},{default:t(()=>[i("synchronized")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/final-in-java.html"},{default:t(()=>[i("final")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/static-in-java.html"},{default:t(()=>[i("static")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/const-in-java.html"},{default:t(()=>[i("const")]),_:1})])])])]),l("li",null,[g,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/Collection-vs-Collections.html"},{default:t(()=>[i("Collection和Collections区别")]),_:1})])]),S,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/set-vs-list.html"},{default:t(()=>[i("Set和List区别？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/arraylist-vs-linkedlist-vs-vector.html"},{default:t(()=>[i("ArrayList和LinkedList和Vector的区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/why-transient-in-arraylist.html"},{default:t(()=>[i("ArrayList使用了transient关键字进行存储优化，而Vector没有，为什么？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/synchronizedlist-vector.html"},{default:t(()=>[i("SynchronizedList和Vector的区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/set-repetition.html"},{default:t(()=>[i("Set如何保证元素不重复?")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/HashMap-HashTable-ConcurrentHashMap.html"},{default:t(()=>[i("HashMap、HashTable、ConcurrentHashMap区别")]),_:1})])]),y,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/hashmap-capacity.html"},{default:t(()=>[i("HashMap的容量、扩容")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/hash-in-hashmap.html"},{default:t(()=>[i("HashMap中hash方法的原理")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/hashmap-default-capacity.html"},{default:t(()=>[i("为什么HashMap的默认容量设置成16")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/hashmap-default-loadfactor.html"},{default:t(()=>[i("为什么HashMap的默认负载因子设置成0.75")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/hashmap-init-capacity.html"},{default:t(()=>[i("为什么建议设置HashMap的初始容量，设置多少合适")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/stream.html"},{default:t(()=>[i("Java 8中stream相关用法")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/apache-collections.html"},{default:t(()=>[i("Apache集合处理工具类的使用")]),_:1})])]),C,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/Arrays-asList.html"},{default:t(()=>[i("Arrays.asList获得的List使用时需要注意什么")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/iteration-of-collection.html"},{default:t(()=>[i("Collection如何迭代")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/Enumeration-vs-Iterator.html"},{default:t(()=>[i("Enumeration和Iterator区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/fail-fast-vs-fail-safe.html"},{default:t(()=>[i("fail-fast 和 fail-safe")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/delete-while-iterator.html"},{default:t(()=>[i("如何在遍历的同时删除ArrayList中的元素")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/CopyOnWriteArrayList.html"},{default:t(()=>[i("CopyOnWriteArrayList")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/ConcurrentSkipListMap.html"},{default:t(()=>[i("ConcurrentSkipListMap")]),_:1})])])])]),l("li",null,[M,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-usage.html"},{default:t(()=>[i("枚举的用法")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-impl.html"},{default:t(()=>[i("枚举的实现")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-singleton.html"},{default:t(()=>[i("枚举与单例")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-class.html"},{default:t(()=>[i("Enum类")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-compare.html"},{default:t(()=>[i("Java枚举如何比较")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-switch.html"},{default:t(()=>[i("switch对枚举的支持")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-serializable.html"},{default:t(()=>[i("枚举的序列化如何实现")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/enum-thread-safe.html"},{default:t(()=>[i("枚举的线程安全性问题")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/stop-use-enum-in-api.html"},{default:t(()=>[i("为什么不建议在对外接口中使用枚举")]),_:1})])])])]),l("li",null,[D,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/byte-stream-vs-character-stream.html"},{default:t(()=>[i("字符流、字节流")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/input-stream-vs-output-stream.html"},{default:t(()=>[i("输入流、输出流")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/convert-bytestream-characterstream.html"},{default:t(()=>[i("字节流和字符流之间的相互转换")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/synchronized-vs-asynchronization.html"},{default:t(()=>[i("同步、异步")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/block-vs-non-blocking.html"},{default:t(()=>[i("阻塞、非阻塞")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/linux-io.html"},{default:t(()=>[i("Linux 5种IO模型")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/bio-vs-nio-vs-aio.html"},{default:t(()=>[i("BIO、NIO和AIO的区别、三种IO的用法与原理")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/netty.html"},{default:t(()=>[i("netty")]),_:1})])])])]),l("li",null,[k,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/reflection.html"},{default:t(()=>[i("反射")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/usage-of-reflection.html"},{default:t(()=>[i("反射有什么作用")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/Class.html"},{default:t(()=>[i("Class类")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/ioc-implement-with-factory-and-reflection.html"},{default:t(()=>[i("反射与工厂模式实现Spring IOC")]),_:1})])]),L])]),l("li",null,[A,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/static-proxy.html"},{default:t(()=>[i("静态代理")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/dynamic-proxy.html"},{default:t(()=>[i("动态代理")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/dynamic-proxy-vs-reflection.html"},{default:t(()=>[i("动态代理和反射的关系")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/dynamic-proxy-implementation.html"},{default:t(()=>[i("动态代理的几种实现方式")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/aop-vs-proxy.html"},{default:t(()=>[i("AOP")]),_:1})])])])]),l("li",null,[P,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/serialize.html"},{default:t(()=>[i("什么是序列化与反序列化")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/serialize-in-java.html"},{default:t(()=>[i("Java如何实现序列化与反序列化")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/diff-serializable-vs-externalizable.html"},{default:t(()=>[i("Serializable 和 Externalizable 有何不同")]),_:1})])]),I,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/serialVersionUID.html"},{default:t(()=>[i("serialVersionUID")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/serialVersionUID-modify.html"},{default:t(()=>[i("为什么serialVersionUID不能随便改")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/transient-in-java.html"},{default:t(()=>[i("transient")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/serialize-principle.html"},{default:t(()=>[i("序列化底层原理")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/serialize-singleton.html"},{default:t(()=>[i("序列化如何破坏单例模式")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/protobuf.html"},{default:t(()=>[i("protobuf")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/bug-in-apache-commons-collections.html"},{default:t(()=>[i("Apache-Commons-Collections的反序列化漏洞")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/bug-in-fastjson.html"},{default:t(()=>[i("fastjson的反序列化漏洞")]),_:1})])])])]),l("li",null,[x,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/meta-annotation.html"},{default:t(()=>[i("元注解")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/custom-annotation.html"},{default:t(()=>[i("自定义注解")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/annotation-in-java.html"},{default:t(()=>[i("Java中常用注解使用")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/annotion-and-reflect.html"},{default:t(()=>[i("注解与反射的结合")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/create-annotation.html"},{default:t(()=>[i("如何自定义一个注解？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/annotation-in-spring.html"},{default:t(()=>[i("Spring常用注解")]),_:1})])])])]),l("li",null,[O,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/generics.html"},{default:t(()=>[i("什么是泛型")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/type-erasure.html"},{default:t(()=>[i("类型擦除")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/generics-problem.html"},{default:t(()=>[i("泛型带来的问题")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/k-t-v-e.html"},{default:t(()=>[i("泛型中K T V E ？ object等的含义")]),_:1})])]),H,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/Wildcard-Character.html"},{default:t(()=>[i("限定通配符和非限定通配符")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/extends-vs-super.html"},{default:t(()=>[i("上下界限定符extends 和 super")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/genericity-list.html"},{default:t(()=>[w,i("和原始类型"),R,i("之间的区别?")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/genericity-list-wildcard.html"},{default:t(()=>[E,i("和"),z,i("之间的区别是什么?")]),_:1})])])])]),l("li",null,[N,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/junit.html"},{default:t(()=>[i("junit")]),_:1})])]),F,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/mock.html"},{default:t(()=>[i("mock")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/ut-with-jmockit.html"},{default:t(()=>[i("JMockit")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/h2-db.html"},{default:t(()=>[i("内存数据库（h2）")]),_:1})])])])]),U,l("li",null,[V,l("ul",null,[G,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/api-vs-spi.html"},{default:t(()=>[i("API和SPI的关系和区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/create-spi.html"},{default:t(()=>[i("如何定义SPI")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/spi-principle.html"},{default:t(()=>[i("SPI的实现原理")]),_:1})])])])]),l("li",null,[X,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/error-vs-exception.html"},{default:t(()=>[i("Error和Exception")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/exception-type.html"},{default:t(()=>[i("异常类型")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/keyword-about-exception.html"},{default:t(()=>[i("异常相关关键字")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/handle-exception.html"},{default:t(()=>[i("正确处理异常")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/define-exception.html"},{default:t(()=>[i("自定义异常")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/exception-chain.html"},{default:t(()=>[i("异常链")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/try-with-resources.html"},{default:t(()=>[i("try-with-resources")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/order-about-finllly-return.html"},{default:t(()=>[i("finally和return的执行顺序")]),_:1})])])])]),l("li",null,[K,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/time-zone.html"},{default:t(()=>[i("时区")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/StandardTime-vs-daylightSavingTime.html"},{default:t(()=>[i("冬令时和夏令时")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/timestamp.html"},{default:t(()=>[i("时间戳")]),_:1})])]),Y,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/GMT.html"},{default:t(()=>[i("格林威治时间")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/CET-UTC-GMT-CST.html"},{default:t(()=>[i("CET,UTC,GMT,CST几种常见时间的含义和关系")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/simpledateformat-thread-safe.html"},{default:t(()=>[i("SimpleDateFormat的线程安全性问题")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/time-in-java8.html"},{default:t(()=>[i("Java 8中的时间处理")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/get-los_angeles-time.html"},{default:t(()=>[i("如何在东八区的计算机上获取美国时间")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/YYYY-vs-yyyy.html"},{default:t(()=>[i("yyyy和YYYY有什么区别？")]),_:1})])]),Q])]),l("li",null,[q,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/ASCII.html"},{default:t(()=>[i("什么是ASCII？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/UNICODE.html"},{default:t(()=>[i("Unicode")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/why-utf8.html"},{default:t(()=>[i("有了Unicode为啥还需要UTF-8")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/UTF8-UTF16-UTF32.html"},{default:t(()=>[i("UTF8、UTF16、UTF32区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/why-gbk.html"},{default:t(()=>[i("有了UTF8为什么还需要GBK？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/gbk-gb2312-gb18030.html"},{default:t(()=>[i("GBK、GB2312、GB18030之间的区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/url-encode.html"},{default:t(()=>[i("URL编解码")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/big-endian-vs-little-endian.html"},{default:t(()=>[i("Big Endian和Little Endian")]),_:1})])]),Z])]),l("li",null,[W,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/syntactic-sugar.html"},{default:t(()=>[i("Java中语法糖原理、解语法糖")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/syntactic-sugar.html"},{default:t(()=>[i("语法糖介绍")]),_:1})])])])]),$,l("li",null,[ll,l("ul",null,[il,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/stop-using-equlas-in-bigdecimal.html"},{default:t(()=>[i("为什么不能使用BigDecimal的equals比较大小")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/stop-create-bigdecimal-with-double.html"},{default:t(()=>[i("为什么不能直接使用double创建一个BigDecimal")]),_:1})])])])]),l("li",null,[pl,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/lambda.html"},{default:t(()=>[i("lambda表达式")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/stream.html"},{default:t(()=>[i("Stream API")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/time-in-java8.html"},{default:t(()=>[i("时间API")]),_:1})])])])]),al])]),l("li",null,[tl,l("ul",null,[l("li",null,[el,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/concurrent.html"},{default:t(()=>[i("什么是并发")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/parallel.html"},{default:t(()=>[i("什么是并行")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/concurrent-vs-parallel.html"},{default:t(()=>[i("并发与并行的区别")]),_:1})])])])]),l("li",null,[nl,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/progress-vs-thread.html"},{default:t(()=>[i("线程与进程的区别")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/thread.html"},{default:t(()=>[i("线程的特点")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/implement-of-thread.html"},{default:t(()=>[i("线程的实现")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/state-of-thread.html"},{default:t(()=>[i("线程的状态")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/priority-of-thread.html"},{default:t(()=>[i("线程优先级")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/thread-scheduling.html"},{default:t(()=>[i("线程调度")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/debug-in-multithread.html"},{default:t(()=>[i("多线程如何Debug")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/deamon-thread.html"},{default:t(()=>[i("守护线程")]),_:1})])])])]),l("li",null,[ul,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/create-thread-with-extends.html"},{default:t(()=>[i("继承Thread类创建线程")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/create-thread-with-Implement.html"},{default:t(()=>[i("实现Runnable接口创建线程")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/create-thread-with-callback-future-task.html"},{default:t(()=>[i("通过Callable和FutureTask创建线程")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/create-thread-with-thead-pool.html"},{default:t(()=>[i("通过线程池创建线程")]),_:1})])])])]),l("li",null,[ol,l("ul",null,[sl,cl,rl,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/why-not-executors.html"},{default:t(()=>[i("为什么不允许使用Executors创建线程池")]),_:1})])])])]),l("li",null,[dl,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/thread-safe.html"},{default:t(()=>[i("什么是线程安全")]),_:1})])]),hl,vl,_l,bl,ml,fl])]),Jl,l("li",null,[Tl,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/deadlock-java-level.html"},{default:t(()=>[i("什么是死锁")]),_:1})])]),Bl,jl,gl,Sl])]),l("li",null,[yl,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/concurrent-coding/synchronized.html"},{default:t(()=>[i("synchronized是如何实现的？")]),_:1})])]),Cl,Ml,Dl,kl,Ll])]),Al])])])]),l("li",null,[Pl,l("ul",null,[l("li",null,[Il,l("ul",null,[l("li",null,[xl,l("ul",null,[Ol,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/exclusive-in-runtime-area.html"},{default:t(()=>[i("运行时数据区哪些是线程独享")]),_:1})])]),Hl,wl,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/Runtime-Constant-Pool.html"},{default:t(()=>[i("运行时常量池")]),_:1})])]),Rl,El,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/stack-alloc.html"},{default:t(()=>[i("Java中的对象一定在堆上分配吗？")]),_:1})])])])]),zl])]),Nl,l("li",null,[Fl,l("ul",null,[Ul,Vl,Gl,Xl,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/parents-delegate.html"},{default:t(()=>[i("双亲委派原则")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/why-parents-delegate.html"},{default:t(()=>[i("为什么需要双亲委派？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/relation-with-parents-delegate.html"},{default:t(()=>[i("“父子加载器”之间的关系是继承吗？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/implements-of-parents-delegate.html"},{default:t(()=>[i("双亲委派是如何实现的？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/ibreak-parants-delegate.html"},{default:t(()=>[i("如何打破双亲委派")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/define-class-loader.html"},{default:t(()=>[i("如何自定义类加载器")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/sample-of-break-parents-delegate.html"},{default:t(()=>[i("双亲委派被破坏的例子")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/spi-parents-delegate.html"},{default:t(()=>[i("为什么JNDI，JDBC等需要破坏双亲委派？")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/tomcat-parents-delegate.html"},{default:t(()=>[i("为什么Tomcat要破坏双亲委派")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basement/jvm/moduler.html"},{default:t(()=>[i("模块化（jboss modules、osgi、jigsaw）")]),_:1})])])])]),Kl,l("li",null,[Yl,l("ul",null,[Ql,ql,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/basics/java-basic/class-contant-pool.html"},{default:t(()=>[i("Class常量池")]),_:1})])]),Zl,Wl])]),$l])]),l("li",null,[li,l("ul",null,[ii,pi,l("li",null,[ai,l("ul",null,[ti,l("li",null,[ei,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/advance/design-patterns/singleton-pattern.html"},{default:t(()=>[i("单例模式")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/advance/design-patterns/abstract-factory-pattern.html"},{default:t(()=>[i("抽象工厂模式")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/advance/design-patterns/builder-pattern.html"},{default:t(()=>[i("建造者模式")]),_:1})])]),l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/advance/design-patterns/factory-method-pattern.html"},{default:t(()=>[i("工厂模式")]),_:1})])]),ni])]),l("li",null,[ui,l("ul",null,[l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/advance/design-patterns/adapter-pattern.html"},{default:t(()=>[i("适配器模式")]),_:1})])]),oi,si,ci,ri,di,hi])]),l("li",null,[vi,l("ul",null,[_i,bi,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/advance/design-patterns/iterator-pattern.html"},{default:t(()=>[i("迭代器模式")]),_:1})])]),mi,fi,Ji,Ti,Bi,l("li",null,[l("p",null,[a(p,{to:"/toBeTopJavaer/advance/design-patterns/strategy-pattern.html"},{default:t(()=>[i("策略模式")]),_:1})])]),ji,gi])]),Si])]),yi])]),Ci])])}const Ai=n(c,[["render",Mi],["__file","menu.html.vue"]]);export{Ai as default};
