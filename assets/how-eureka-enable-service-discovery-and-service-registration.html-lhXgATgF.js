import{_ as t,r as s,o as n,c as d,a as e,b as r,d as o,e as i}from"./app-3RcBQnkC.js";const p="/code-note/assets/eureka-server-homepage-p2fFOhkI.png",u="/code-note/assets/eureka-instance-registered-currently-GFkirPEG.png",h="/code-note/assets/eureka-server-applicationresource-addinstance-zOUb5wni.png",l="/code-note/assets/eureka-server-registry-structure-FXCIHvAG.png",a="/code-note/assets/eureka-server-register-sequence-chart-V06KiSoZ.png",v="/code-note/assets/eureka-server-instanceresource-renew-Awg9ySF-.png",g="/code-note/assets/eureka-server-renew-sequence-chart-U63McMKW.png",k="/code-note/assets/eureka-server-instanceresource-cancellease-z9B3X4_z.png",_="/code-note/assets/eureka-server-cancellease-sequence-chart-48RBW3o7.png",m="/code-note/assets/eureka-server-evict-sequence-chart-vbRYyPEr.png",f="/code-note/assets/eureka-service-provider-renew-sequence-chart-kTU1wzZg.png",E="/code-note/assets/eureka-service-provider-cancel-sequence-chart-K9Xvbus9.png",b="/code-note/assets/eureka-service-consumer-fetchregistry-M0YmS6aN.png",S="/code-note/assets/eureka-service-consumer-fetch-sequence-chart-Tcyg0dI7.png",w="/code-note/assets/eureka-service-consumer-update-sequence-chart-W-AvE3OF.png",x={},y=e("h1",{id:"服务发现组件-eureka-的几个主要调用过程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#服务发现组件-eureka-的几个主要调用过程","aria-hidden":"true"},"#"),r(" 服务发现组件 Eureka 的几个主要调用过程")],-1),I=e("h2",{id:"前言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),r(" 前言")],-1),R=e("code",null,"微服务",-1),A=e("code",null,"服务发现（Service Discovery）",-1),q=e("code",null,"apache",-1),C={href:"https://github.com/apache/zookeeper",target:"_blank",rel:"noopener noreferrer"},P=e("code",null,"Netflix",-1),D={href:"https://github.com/Netflix/eureka",target:"_blank",rel:"noopener noreferrer"},N=e("code",null,"hashicorp",-1),T={href:"https://github.com/hashicorp/consul",target:"_blank",rel:"noopener noreferrer"},B=e("code",null,"CoreOS",-1),F={href:"https://github.com/etcd-io/etcd",target:"_blank",rel:"noopener noreferrer"},V=e("h2",{id:"eureka-是什么",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#eureka-是什么","aria-hidden":"true"},"#"),r(" Eureka 是什么")],-1),z=e("code",null,"Eureka",-1),L={href:"https://github.com/Netflix/eureka",target:"_blank",rel:"noopener noreferrer"},O=e("blockquote",null,[e("p",null,"Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers.")],-1),U=e("p",null,"At Netflix, Eureka is used for the following purposes apart from playing a critical part in mid-tier load balancing.",-1),M=e("code",null,"Eureka",-1),G={href:"https://www.netflix.com",target:"_blank",rel:"noopener noreferrer"},W=e("code",null,"Spring Cloud",-1),K={href:"https://github.com/Netflix/eureka/wik",target:"_blank",rel:"noopener noreferrer"},X=i('<h2 id="服务注册中心-eureka-server" tabindex="-1"><a class="header-anchor" href="#服务注册中心-eureka-server" aria-hidden="true">#</a> 服务注册中心（Eureka Server）</h2><p>我们在项目中引入 <code>Eureka Server</code> 的相关依赖，然后在启动类加上注解 <code>@EnableEurekaServer</code> ，就可以将其作为注册中心，启动服务后访问页面如下：</p><p><img src="'+p+'" alt="eureka-server-homepage.png"></p><p>我们继续添加两个模块 <code>service-provider</code> ， <code>service-consumer</code> ，然后在启动类加上注解 <code>@EnableEurekaClient</code> 并指定注册中心地址为我们刚刚启动的 <code>Eureka Server</code> ，再次访问可以看到两个服务都已经注册进来了。</p><p><img src="'+u+'" alt="eureka-instance-registered-currently.png"></p><p>可以看到 <code>Eureka</code> 的使用非常简单，只需要添加几个注解和配置就实现了服务注册和服务发现，接下来我们看看它是如何实现这些功能的。</p><h3 id="服务注册-register" tabindex="-1"><a class="header-anchor" href="#服务注册-register" aria-hidden="true">#</a> 服务注册（Register）</h3><p>注册中心提供了服务注册接口，用于当有新的服务启动后进行调用来实现服务注册，或者心跳检测到服务状态异常时，变更对应服务的状态。服务注册就是发送一个 <code>POST</code> 请求带上当前实例信息到类 <code>ApplicationResource</code> 的 <code>addInstance</code> 方法进行服务注册。</p><p><img src="'+h+'" alt="eureka-server-applicationresource-addinstance.png"></p><p>可以看到方法调用了类 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>register</code> 方法，该方法主要分为两步：</p><ol><li>调用父类 <code>AbstractInstanceRegistry</code> 的 <code>register</code> 方法把当前服务注册到注册中心</li><li>调用 <code>replicateToPeers</code> 方法使用异步的方式向其它的 <code>Eureka Server</code> 节点同步服务注册信息</li></ol><p>服务注册信息保存在一个嵌套的 <code>map</code> 中，它的结构如下：</p><p><img src="'+l+'" alt="eureka-server-registry-structure.png"></p><p>第一层 <code>map</code> 的 <code>key</code> 是应用名称（对应 <code>Demo</code> 里的 <code>SERVICE-PROVIDER</code> ），第二层 <code>map</code> 的 <code>key</code> 是应用对应的实例名称（对应 <code>Demo</code> 里的 <code>mghio-mbp:service-provider:9999</code> ），一个应用可以有多个实例，主要调用流程如下图所示：</p><p><img src="'+a+'" alt="eureka-server-register-sequence-chart.png"></p><h3 id="服务续约-renew" tabindex="-1"><a class="header-anchor" href="#服务续约-renew" aria-hidden="true">#</a> 服务续约（Renew）</h3><p>服务续约会由服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code> ）定期调用，类似于心跳，用来告知注册中心 <code>Eureka Server</code> 自己的状态，避免被 <code>Eureka Server</code> 认为服务时效将其剔除下线。服务续约就是发送一个 <code>PUT</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>renewLease</code> 方法进行服务续约操作。</p><p><img src="'+v+'" alt="eureka-server-instanceresource-renew.png"></p><p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>renew</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先更新当前 <code>Eureka Server</code> 节点的状态，服务续约成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：</p><p><img src="'+g+'" alt="eureka-server-renew-sequence-chart.png"></p><h3 id="服务下线-cancel" tabindex="-1"><a class="header-anchor" href="#服务下线-cancel" aria-hidden="true">#</a> 服务下线（Cancel）</h3><p>当服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code> ）停止服务时，会发送请求告知注册中心 <code>Eureka Server</code> 进行服务剔除下线操作，防止服务消费者从注册中心调用到不存在的服务。服务下线就是发送一个 <code>DELETE</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>cancelLease</code> 方法进行服务剔除下线操作。</p><p><img src="'+k+'" alt="eureka-server-instanceresource-cancellease.png"></p><p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>cancel</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先在当前 <code>Eureka Server</code> 节点剔除下线该服务，服务下线成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：</p><p><img src="'+_+'" alt="eureka-server-cancellease-sequence-chart.png"></p><h3 id="服务剔除-eviction" tabindex="-1"><a class="header-anchor" href="#服务剔除-eviction" aria-hidden="true">#</a> 服务剔除（Eviction）</h3><p>服务剔除是注册中心 <code>Eureka Server</code> 在启动时就启动一个守护线程 <code>evictionTimer</code> 来定期（默认为 <code>60</code> 秒）执行检测服务的，判断标准就是超过一定时间没有进行 <code>Renew</code> 的服务，默认的失效时间是 <code>90</code> 秒，也就是说当一个已注册的服务在 <code>90</code> 秒内没有向注册中心 <code>Eureka Server</code> 进行服务续约（Renew），就会被从注册中心剔除下线。失效时间可以通过配置 <code>eureka.instance.leaseExpirationDurationInSeconds</code> 进行修改，定期执行检测服务可以通过配置 <code>eureka.server.evictionIntervalTimerInMs</code> 进行修改，主要调用流程如下图所示：</p><p><img src="'+m+'" alt="eureka-server-evict-sequence-chart.png"></p><h2 id="服务提供者-service-provider" tabindex="-1"><a class="header-anchor" href="#服务提供者-service-provider" aria-hidden="true">#</a> 服务提供者（Service Provider）</h2><p>对于服务提供方（比如 <code>Demo</code> 中的 <code>service-provider</code> 服务）来说，主要有三大类操作，分别为 <code>服务注册（Register）</code> 、 <code>服务续约（Renew）</code> 、 <code>服务下线（Cancel）</code> ，接下来看看这三个操作是如何实现的。</p><h3 id="服务注册-register-1" tabindex="-1"><a class="header-anchor" href="#服务注册-register-1" aria-hidden="true">#</a> 服务注册（Register）</h3><p>一个服务要对外提供服务，首先要在注册中心 <code>Eureka Server</code> 进行服务相关信息注册，能进行这一步的前提是你要配置 <code>eureka.client.register-with-eureka=true</code> ，这个默认值为 <code>true</code> ，注册中心不需要把自己注册到注册中心去，把这个配置设为 <code>false</code> ，这个调用比较简单，主要调用流程如下图所示：</p><p><img src="'+a+'" alt="eureka-service-provider-register-sequence-chart.png"></p><h3 id="服务续约-renew-1" tabindex="-1"><a class="header-anchor" href="#服务续约-renew-1" aria-hidden="true">#</a> 服务续约（Renew）</h3><p>服务续约是由服务提供者方定期（默认为 <code>30</code> 秒）发起心跳的，主要是用来告知注册中心 <code>Eureka Server</code> 自己状态是正常的还活着，可以通过配置 <code>eureka.instance.lease-renewal-interval-in-seconds</code> 来修改，当然服务续约的前提是要配置 <code>eureka.client.register-with-eureka=true</code> ，将该服务注册到注册中心中去，主要调用流程如下图所示：</p><p><img src="'+f+'" alt="eureka-service-provider-renew-sequence-chart.png"></p><h3 id="服务下线-cancel-1" tabindex="-1"><a class="header-anchor" href="#服务下线-cancel-1" aria-hidden="true">#</a> 服务下线（Cancel）</h3><p>当服务提供者方服务停止时，要发送 <code>DELETE</code> 请求告知注册中心 <code>Eureka Server</code> 自己已经下线，好让注册中心将自己剔除下线，防止服务消费方从注册中心获取到不可用的服务。这个过程实现比较简单，在类 <code>DiscoveryClient</code> 的 <code>shutdown</code> 方法加上注解 <code>@PreDestroy</code> ，当服务停止时会自动触发服务剔除下线，执行服务下线逻辑，主要调用流程如下图所示：</p><p><img src="'+E+'" alt="eureka-service-provider-cancel-sequence-chart.png"></p><h2 id="服务消费者-service-consumer" tabindex="-1"><a class="header-anchor" href="#服务消费者-service-consumer" aria-hidden="true">#</a> 服务消费者（Service Consumer）</h2><p>这里的服务消费者如果不需要被其它服务调用的话，其实只会涉及到两个操作，分别是从注册中心 <code>获取服务列表（Fetch）</code> 和 <code>更新服务列表（Update）</code> 。如果同时也需要注册到注册中心对外提供服务的话，那么剩下的过程和上文提到的服务提供者是一致的，这里不再阐述，接下来看看这两个操作是如何实现的。</p><h3 id="获取服务列表-fetch" tabindex="-1"><a class="header-anchor" href="#获取服务列表-fetch" aria-hidden="true">#</a> 获取服务列表（Fetch）</h3><p>服务消费者方启动之后首先肯定是要先从注册中心 <code>Eureka Server</code> 获取到可用的服务列表同时本地也会缓存一份。这个获取服务列表的操作是在服务启动后 <code>DiscoverClient</code> 类实例化的时候执行的。</p><p><img src="'+b+'" alt="eureka-service-consumer-fetchregistry.png"></p><p>可以看出，能发生这个获取服务列表的操作前提是要保证配置了 <code>eureka.client.fetch-registry=true</code> ，该配置的默认值为 <code>true</code> ，主要调用流程如下图所示：</p><p><img src="'+S+'" alt="eureka-service-consumer-fetch-sequence-chart.png"></p><h3 id="更新服务列表-update" tabindex="-1"><a class="header-anchor" href="#更新服务列表-update" aria-hidden="true">#</a> 更新服务列表（Update）</h3><p>由上面的 <code>获取服务列表（Fetch）</code> 操作过程可知，本地也会缓存一份，所以这里需要定期的去到注册中心 <code>Eureka Server</code> 获取服务的最新配置，然后比较更新本地缓存，这个更新的间隔时间可以通过配置 <code>eureka.client.registry-fetch-interval-seconds</code> 修改，默认为 <code>30</code> 秒，能进行这一步更新服务列表的前提是你要配置 <code>eureka.client.register-with-eureka=true</code> ，这个默认值为 <code>true</code> 。主要调用流程如下图所示：</p><p><img src="'+w+'" alt="eureka-service-consumer-update-sequence-chart.png"></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>工作中项目使用的是 <code>Spring Cloud</code> 技术栈，它有一套非常完善的开源代码来整合 <code>Eureka</code> ，使用起来非常方便。之前都是直接加注解和修改几个配置属性一气呵成的，没有深入了解过源码实现，本文主要是阐述了服务注册、服务发现等相关过程和实现方式，对 <code>Eureka</code> 服务发现组件有了更近一步的了解。</p><hr><p>参考文章</p>',53),H={href:"https://github.com/Netflix/eureka",target:"_blank",rel:"noopener noreferrer"},Y={href:"https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture",target:"_blank",rel:"noopener noreferrer"};function Z(j,J){const c=s("ExternalLinkIcon");return n(),d("div",null,[y,I,e("p",null,[r("现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为 "),R,r(" ），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。 一个比较好的解决方案就是 "),A,r(" 。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 "),q,r(" 的 "),e("a",C,[r("zookeeper"),o(c)]),r("、 "),P,r(" 的 "),e("a",D,[r("eureka"),o(c)]),r("、 "),N,r(" 的 "),e("a",T,[r("consul"),o(c)]),r("、 "),B,r(" 的 "),e("a",F,[r("etcd"),o(c)]),r("。")]),V,e("p",null,[z,r(" 在 "),e("a",L,[r("GitHub"),o(c)]),r(" 上对其的定义为")]),O,U,e("p",null,[M,r(" 是由 "),e("a",G,[r("Netflix"),o(c)]),r(" 公司开源，采用的是 Client / Server 模式进行设计，基于 http 协议和使用 Restful Api 开发的服务注册与发现组件，提供了完整的服务注册和服务发现，可以和 "),W,r(" 无缝集成。其中 Server 端扮演着服务注册中心的角色，主要是为 Client 端提供服务注册和发现等功能，维护着 Client 端的服务注册信息，同时定期心跳检测已注册的服务当不可用时将服务剔除下线，Client 端可以通过 Server 端获取自身所依赖服务的注册信息，从而完成服务间的调用。遗憾的是从其官方的 "),e("a",K,[r("github wiki"),o(c)]),r(" 可以发现，2.0 版本已经不再开源。但是不影响我们对其进行深入了解，毕竟服务注册、服务发现相对来说还是比较基础和通用的，其它开源实现框架的思想也是想通的。")]),X,e("p",null,[e("a",H,[r("Netflix Eureka"),o(c)])]),e("p",null,[e("a",Y,[r("Service Discovery in a Microservices Architecture"),o(c)])])])}const $=t(x,[["render",Z],["__file","how-eureka-enable-service-discovery-and-service-registration.html.vue"]]);export{$ as default};
