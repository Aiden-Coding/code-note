import{_ as n,o as s,c as a,e as t}from"./app-3RcBQnkC.js";const p={},e=t(`<h1 id="java基础-反射篇" tabindex="-1"><a class="header-anchor" href="#java基础-反射篇" aria-hidden="true">#</a> Java基础 反射篇</h1><ul><li><a href="#java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E7%AF%87">Java基础 反射篇</a><ul><li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E4%BD%9C%E7%94%A8">反射的思想及作用</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">反射的基本使用</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84-class-%E5%AF%B9%E8%B1%A1">获取类的 Class 对象</a></li><li><a href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1">构造类的实例化对象</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF">获取一个类的所有信息</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8Ffield">获取类中的变量（Field）</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95method">获取类中的方法（Method）</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8constructor">获取类的构造器（Constructor）</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3">获取注解</a></li><li><a href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">通过反射调用方法</a></li></ul></li><li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">反射的应用场景</a><ul><li><a href="#spring-%E7%9A%84-ioc-%E5%AE%B9%E5%99%A8">Spring 的 IOC 容器</a></li><li><a href="#%E5%8F%8D%E5%B0%84--%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">反射 + 抽象工厂模式</a></li><li><a href="#jdbc-%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E7%B1%BB">JDBC 加载数据库驱动类</a></li></ul></li><li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E7%BC%BA%E9%99%B7">反射的优势及缺陷</a><ul><li><a href="#%E5%A2%9E%E5%8A%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7">增加程序的灵活性</a></li><li><a href="#%E7%A0%B4%E5%9D%8F%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7">破坏类的封装性</a></li><li><a href="#%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97">性能损耗</a></li></ul></li><li><a href="#%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%AF%87%E6%96%87%E6%9C%AB%E6%80%BB%E7%BB%93">反射基础篇文末总结</a></li></ul></li></ul><p>反射是一个非常重要的知识点，在学习<code>Spring 框架</code>时，Bean的初始化用到了反射，在<code>破坏单例模式</code>时也用到了反射，在<code>获取标注的注解</code>时也会用到反射······</p><p>当然了，反射在日常开发中，我们没碰到过多少，至少我没怎么用过。但面试是<strong>造火箭</strong>现场，可爱的面试官们又怎会轻易地放过我们呢？反射是开源框架中的一个重要设计理念，在源码分析中少不了它的身影，所以，今天我会尽量用浅显易懂的语言，让你去理解下面这几点：</p><p>（1）反射的思想以及它的作用​ 👉 <strong>概念篇</strong></p><p>（2）反射的基本使用及应用场景 👉 <strong>应用篇</strong></p><p>（3）使用反射能给我们编码时带来的优势以及存在的缺陷 👉 <strong>分析篇</strong></p><h2 id="反射的思想及作用" tabindex="-1"><a class="header-anchor" href="#反射的思想及作用" aria-hidden="true">#</a> 反射的思想及作用</h2><p>有反必有正，就像世间的阴和阳，计算机的0和1一样。天道有轮回，苍天...<s>（净会在这瞎bibi）</s></p><p>在学习反射之前，先来了解<strong>正射</strong>是什么。我们平常用的最多的 <code>new</code> 方式实例化对象的方式就是一种正射的体现。假如我需要实例化一个<code>HashMap</code>，代码就会是这样子。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>某一天发现，该段程序不适合用 HashMap 存储键值对，更倾向于用<code>LinkedHashMap</code>存储。重新编写代码后变成下面这个样子。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>假如又有一天，发现数据还是适合用 HashMap来存储，难道又要重新修改源码吗？</p><blockquote><p>发现问题了吗？我们每次改变一种需求，都要去重新<strong>修改源码</strong>，然后对代码进行编译，打包，再到 JVM 上重启项目。这么些步骤下来，效率非常低。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596529718718-903156ef-2e22-428e-9449-ab26ced3b5f8.png" alt="image.png"></p><p>对于这种<strong>需求频繁变更但变更不大</strong>的场景，频繁地更改源码肯定是一种不允许的操作，我们可以使用一个<code>开关</code>，判断什么时候使用哪一种数据结构。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">String</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;HashMap&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;LinkedHashMap&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;WeakHashMap&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> map<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过传入参数<code>param</code>决定使用哪一种数据结构，可以在项目运行时，通过<strong>动态传入参数</strong>决定使用哪一个数据结构。</p><p>如果某一天还想用<code>TreeMap</code>，还是避免不了修改源码，重新编译执行的弊端。这个时候，<strong>反射</strong>就派上用场了。</p><p>在代码运行之前，我们<strong>不确定</strong>将来会使用哪一种数据结构，只有在程序<strong>运行时才决定</strong>使用哪一个数据类，而<code>反射</code>可以在<strong>程序运行过程</strong>中动态<strong>获取类信息</strong>和<strong>调用类方法</strong>。通过反射构造类实例，代码会演变成下面这样。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Consructor</span> con <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> con<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论使用什么 Map，只要实现了<code>Map接口</code>，就可以使用<code>全类名路径</code>传入到方法中，获得对应的 Map 实例。例如java.util.HashMap / java.util.LinkedHashMap····如果要创建其它类例如<code>WeakHashMap</code>，我也<strong>不需要修改上面这段源码</strong>。</p><p>我们来回顾一下如何从 <code>new</code> 一个对象引出使用<code>反射</code>的。</p><ul><li>在不使用反射时，构造对象使用 new 方式实现，这种方式在<strong>编译期</strong>就可以把对象的类型确定下来。</li><li>如果需求发生变更，需要构造另一个对象，则需要修改源码，非常不优雅，所以我们通过使用<code>开关</code>，在程序运行时判断需要构造哪一个对象，在运行时可以<strong>变更开关</strong>来实例化不同的数据结构。</li><li>如果还有其它扩展的类有可能被使用，就会创建出<strong>非常多的分支</strong>，且在编码时不知道有什么其他的类被使用到，假如日后<code>Map</code>接口下多了一个集合类是<code>xxxHashMap</code>，还得创建分支，此时引出了反射：可以在<code>运行时</code>才确定使用哪一个数据类，在切换类时，无需重新修改源码、编译程序。</li></ul><p>第一章总结：</p><ul><li>反射的<strong>思想</strong>：<strong>在程序运行过程中确定和解析数据类的类型。</strong></li><li>反射的<strong>作用</strong>：对于在<code>编译期</code>无法确定使用哪个数据类的场景，通过<code>反射</code>可以在程序运行时<strong>构造出不同的数据类实例</strong>。</li></ul><h2 id="反射的基本使用" tabindex="-1"><a class="header-anchor" href="#反射的基本使用" aria-hidden="true">#</a> 反射的基本使用</h2><p>Java 反射的主要组成部分有4个：</p><ul><li><code>Class</code>：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了本来的<strong>所有信息</strong>。记着一句话，通过反射干任何事，先找 Class 准没错！</li><li><code>Field</code>：描述一个类的<strong>属性</strong>，内部包含了该属性的所有信息，例如<strong>数据类型，属性名，访问修饰符</strong>······</li><li><code>Constructor</code>：描述一个类的<strong>构造方法</strong>，内部包含了构造方法的所有信息，例如<strong>参数类型，参数名字，访问修饰符</strong>······</li><li><code>Method</code>：描述一个类的<strong>所有方法</strong>（包括抽象方法），内部包含了该方法的所有信息，与<code>Constructor</code>类似，不同之处是 Method 拥有<strong>返回值类型</strong>信息，因为构造方法是没有返回值的。</li></ul><p>我总结了一张脑图，放在了下面，如果用到了反射，离不开这核心的<code>4</code>个类，只有去了解它们内部提供了哪些信息，有什么作用，运用它们的时候才能<strong>易如反掌</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596555823611-0f82d57a-d2b1-4457-a10f-b36e101c0b8e.png" alt="img"></p><p>我们在学习反射的基本使用时，我会用一个<code>SmallPineapple</code>类作为模板进行说明，首先我们先来熟悉这个类的基本组成：<strong>属性，构造函数和方法</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmallPineapple</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span> <span class="token comment">// 体重只有自己知道</span>
   	
    <span class="token keyword">public</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;[&quot;</span><span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot; 的年龄是：&quot;</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反射中的用法有非常非常多，常见的功能有以下这几个：</p><ul><li>在运行时获取一个类的 <strong>Class 对象</strong></li><li>在运行时构造一个类的<strong>实例化对象</strong></li><li>在运行时获取一个类的所有信息：<strong>变量、方法、构造器、注解</strong></li></ul><h3 id="获取类的-class-对象" tabindex="-1"><a class="header-anchor" href="#获取类的-class-对象" aria-hidden="true">#</a> 获取类的 Class 对象</h3><p>在 Java 中，每一个类都会有专属于自己的 Class 对象，当我们编写完<code>.java</code>文件后，使用<code>javac</code>编译后，就会产生一个字节码文件<code>.class</code>，在字节码文件中包含类的所有信息，如<code>属性</code>，<code>构造方法</code>，<code>方法</code>······当字节码文件被装载进虚拟机执行时，会在内存中生成 Class 对象，它包含了该类内部的所有信息，在程序运行时可以获取这些信息。</p><p>获取 Class 对象的方法有<code>3</code>种：</p><ul><li><code>类名.class</code>：这种获取方式只有在<code>编译</code>前已经声明了该类的类型才能获取到 Class 对象</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>实例.getClass()</code>：通过实例化对象获取该实例的 Class 对象</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SmallPineapple</span> sp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> sp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>Class.forName(className)</code>：通过类的<strong>全限定名</strong>获取该类的 Class 对象</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.bean.smallpineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>拿到 <code>Class</code>对象就可以对它为所欲为了：剥开它的皮（获取<strong>类信息</strong>）、指挥它做事（调用它的<strong>方法</strong>），看透它的一切（获取<strong>属性</strong>），总之它就没有隐私了。</p><p>不过在程序中，每个类的 Class 对象只有一个，也就是说你只有这一个<code>奴隶</code>。我们用上面三种方式测试，通过三种方式打印各个 <code>Class</code> 对象都是相同的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.bean.SmallPineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clazz2 <span class="token operator">=</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
<span class="token class-name">SmallPineapple</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clazz3 <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Class.forName() == SmallPineapple.class:&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>clazz1 <span class="token operator">==</span> clazz2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Class.forName() == instance.getClass():&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>clazz1 <span class="token operator">==</span> clazz3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;instance.getClass() == SmallPineapple.class:&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>clazz2 <span class="token operator">==</span> clazz3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596534789018-870958ba-911f-45a3-b4b7-f73ff93251fd.png" alt="image.png"></p><blockquote><p>内存中只有一个 Class 对象的原因要牵扯到 <code>JVM 类加载机制</code>的<code>双亲委派模型</code>，它保证了程序运行时，<code>加载类</code>时每个类在内存中仅会产生一个<code>Class对象</code>。在这里我不打算详细展开说明，可以简单地理解为 JVM 帮我们保证了<strong>一个类在内存中至多存在一个 Class 对象</strong>。</p></blockquote><h3 id="构造类的实例化对象" tabindex="-1"><a class="header-anchor" href="#构造类的实例化对象" aria-hidden="true">#</a> 构造类的实例化对象</h3><p>通过反射构造一个类的实例方式有<code>2</code>种：</p><ul><li>Class 对象调用<code>newInstance()</code>方法</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.bean.SmallPineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SmallPineapple</span> smallPineapple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SmallPineapple</span><span class="token punctuation">)</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
smallPineapple<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [null 的年龄是：0]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使 SmallPineapple 已经显式定义了构造方法，通过 newInstance() 创建的实例中，所有属性值都是对应类型的<code>初始值</code>，因为 newInstance() 构造实例会<strong>调用默认无参构造器</strong>。</p><ul><li>Constructor 构造器调用<code>newInstance()</code>方法</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.bean.SmallPineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Constructor</span> constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SmallPineapple</span> smallPineapple2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SmallPineapple</span><span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">&quot;小菠萝&quot;</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
smallPineapple2<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [小菠萝 的年龄是：21]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 getConstructor(Object... paramTypes) 方法指定获取<strong>指定参数类型</strong>的 Constructor， Constructor 调用 newInstance(Object... paramValues) 时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。</p><p>通过<code>Class</code>对象调用 newInstance() 会走<strong>默认无参构造方法</strong>，如果想通过<strong>显式构造方法</strong>构造实例，需要提前从Class中调用<code>getConstructor()</code>方法获取对应的构造器，通过构造器去实例化对象。</p><blockquote><p>这些 API 是在开发当中最常遇到的，当然还有非常多重载的方法，本文由于篇幅原因，且如果每个方法都一一讲解，我们也记不住，所以用到的时候去类里面查找就已经足够了。</p></blockquote><h3 id="获取一个类的所有信息" tabindex="-1"><a class="header-anchor" href="#获取一个类的所有信息" aria-hidden="true">#</a> 获取一个类的所有信息</h3><p><strong>Class 对象中包含了该类的所有信息，在编译期我们能看到的信息就是该类的变量、方法、构造器，在运行时最常被获取的也是这些信息。</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1597313607659-2df4f865-3bc8-4dbd-8dfc-f6eafe34519d.png" alt="img"></p><h3 id="获取类中的变量-field" tabindex="-1"><a class="header-anchor" href="#获取类中的变量-field" aria-hidden="true">#</a> 获取类中的变量（Field）</h3><ul><li>Field[] getFields()：获取类中所有被<code>public</code>修饰的所有变量</li><li>Field getField(String name)：根据<strong>变量名</strong>获取类中的一个变量，该<strong>变量必须被public修饰</strong></li><li>Field[] getDeclaredFields()：获取类中所有的变量，但<strong>无法获取继承下来的变量</strong></li><li>Field getDeclaredField(String name)：根据姓名获取类中的某个变量，<strong>无法获取继承下来的变量</strong></li></ul><h3 id="获取类中的方法-method" tabindex="-1"><a class="header-anchor" href="#获取类中的方法-method" aria-hidden="true">#</a> 获取类中的方法（Method）</h3><ul><li><p>Method[] getMethods()：获取类中被<code>public</code>修饰的所有方法</p></li><li><p>Method getMethod(String name, Class...&lt;?&gt; paramTypes)：根据<strong>名字和参数类型</strong>获取对应方法，该方法必须被<code>public</code>修饰</p></li><li><p>Method[] getDeclaredMethods()：获取<code>所有</code>方法，但<strong>无法获取继承下来的方法</strong></p></li><li><p>Method getDeclaredMethod(String name, Class...&lt;?&gt; paramTypes)：根据<strong>名字和参数类型</strong>获取对应方法，<strong>无法获取继承下来的方法</strong></p></li></ul><h3 id="获取类的构造器-constructor" tabindex="-1"><a class="header-anchor" href="#获取类的构造器-constructor" aria-hidden="true">#</a> 获取类的构造器（Constructor）</h3><ul><li>Constuctor[] getConstructors()：获取类中所有被<code>public</code>修饰的构造器</li><li>Constructor getConstructor(Class...&lt;?&gt; paramTypes)：根据<code>参数类型</code>获取类中某个构造器，该构造器必须被<code>public</code>修饰</li><li>Constructor[] getDeclaredConstructors()：获取类中所有构造器</li><li>Constructor getDeclaredConstructor(class...&lt;?&gt; paramTypes)：根据<code>参数类型</code>获取对应的构造器</li></ul><p>每种功能内部以 Declared 细分为<code>2</code>类：</p><blockquote><p>有<code>Declared</code>修饰的方法：可以获取该类内部包含的<strong>所有</strong>变量、方法和构造器，但是<strong>无法获取继承下来的信息</strong></p><p>无<code>Declared</code>修饰的方法：可以获取该类中<code>public</code>修饰的变量、方法和构造器，可<strong>获取继承下来的信息</strong></p></blockquote><p>如果想获取类中**所有的（包括继承）**变量、方法和构造器，则需要同时调用<code>getXXXs()</code>和<code>getDeclaredXXXs()</code>两个方法，用<code>Set</code>集合存储它们获得的变量、构造器和方法，以防两个方法获取到相同的东西。</p><p>例如：要获取SmallPineapple获取类中<strong>所有的变量</strong>，代码应该是下面这样写。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.bean.SmallPineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取 public 属性，包括继承</span>
<span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields1 <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取所有属性，不包括继承</span>
<span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields2 <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将所有属性汇总到 set</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Field</span><span class="token punctuation">&gt;</span></span> allFields <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
allFields<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>fields1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
allFields<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>fields2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>不知道你有没有发现一件<strong>有趣的事情</strong>，如果父类的属性用<code>protected</code>修饰，利用反射是<strong>无法获取到</strong>的。</p><p>protected 修饰符的作用范围：只允许<code>同一个包下</code>或者<code>子类</code>访问，可以继承到子类。</p><p>getFields() 只能获取到本类的<code>public</code>属性的变量值；</p><p>getDeclaredFields() 只能获取到<strong>本类的所有属性，不包括继承</strong>的；无论如何都获取不到父类的 protected 属性修饰的变量，但是它的的确确存在于子类中。</p></blockquote><h3 id="获取注解" tabindex="-1"><a class="header-anchor" href="#获取注解" aria-hidden="true">#</a> 获取注解</h3><p><strong>获取注解单独拧了出来，因为它并不是专属于 Class 对象的一种信息，每个变量，方法和构造器都可以被注解修饰，所以在反射中，Field，Constructor 和 Method 类对象都可以调用下面这些方法获取标注在它们之上的注解。</strong></p><ul><li>Annotation[] getAnnotations()：获取该对象上的<strong>所有注解</strong></li><li>Annotation getAnnotation(Class annotaionClass)：传入<code>注解类型</code>，获取该对象上的特定一个注解</li><li>Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取<code>继承</code>下来的注解</li><li>Annotation getDeclaredAnnotation(Class annotationClass)：根据<code>注解类型</code>，获取该对象上的特定一个注解，无法获取<code>继承</code>下来的注解</li></ul><p>只有注解的<code>@Retension</code>标注为<code>RUNTIME</code>时，才能够通过反射获取到该注解，@Retension 有<code>3</code>种保存策略：</p><ul><li><code>SOURCE</code>：只在**源文件(.java)**中保存，即该注解只会保留在源文件中，<strong>编译时编译器会忽略该注解</strong>，例如 @Override 注解</li><li><code>CLASS</code>：保存在<strong>字节码文件(.class)<strong>中，注解会随着编译跟随字节码文件中，但是</strong>运行时</strong>不会对该注解进行解析</li><li><code>RUNTIME</code>：一直保存到<strong>运行时</strong>，<strong>用得最多的一种保存策略</strong>，在运行时可以获取到该注解的所有信息</li></ul><p>像下面这个例子，SmallPineapple 类继承了抽象类<code>Pineapple</code>，<code>getInfo()</code>方法上标识有 @Override 注解，且在子类中标注了<code>@Transient</code>注解，在运行时获取子类重写方法上的所有注解，只能获取到<code>@Transient</code>的信息。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Pineapple</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmallPineapple</span> <span class="token keyword">extends</span> <span class="token class-name">Pineapple</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Transient</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;小菠萝的身高和年龄是:&quot;</span> <span class="token operator">+</span> height <span class="token operator">+</span> <span class="token string">&quot;cm ; &quot;</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">&quot;岁&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动类<code>Bootstrap</code>获取 SmallPineapple 类中的 getInfo() 方法上的注解信息：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bootstrap</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 根据运行时传入的全类名路径判断具体的类对象
     * <span class="token keyword">@param</span> <span class="token parameter">path</span> 类的全类名路径
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">Class</span> obj <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;getInfo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Annotation</span><span class="token punctuation">[</span><span class="token punctuation">]</span> annotations <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Annotation</span> annotation <span class="token operator">:</span> annotations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token function">execute</span><span class="token punctuation">(</span><span class="token string">&quot;com.pineapple.SmallPineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// @java.beans.Transient(value=true)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="通过反射调用方法" tabindex="-1"><a class="header-anchor" href="#通过反射调用方法" aria-hidden="true">#</a> 通过反射调用方法</h3><p>通过反射获取到某个 Method 类对象后，可以通过调用<code>invoke</code>方法执行。</p><ul><li><code>invoke(Oject obj, Object... args)</code>：参数\`\`1<code>指定调用该方法的**对象**，参数</code>2\`是方法的参数列表值。</li></ul><p>如果调用的方法是<strong>静态方法</strong>，参数1只需要传入<code>null</code>，因为静态方法不与某个对象有关，只与某个类有关。</p><p>可以像下面这种做法，通过反射实例化一个对象，然后获取<code>Method</code>方法对象，调用<code>invoke()</code>指定<code>SmallPineapple</code>的<code>getInfo()</code>方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.bean.SmallPineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Constructor</span> constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SmallPineapple</span> sp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SmallPineapple</span><span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">&quot;小菠萝&quot;</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;getInfo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// [小菠萝的年龄是：21]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="反射的应用场景" tabindex="-1"><a class="header-anchor" href="#反射的应用场景" aria-hidden="true">#</a> 反射的应用场景</h2><p>反射常见的应用场景这里介绍<code>3</code>个：</p><ul><li>Spring 实例化对象：当程序启动时，Spring 会读取配置文件<code>applicationContext.xml</code>并解析出里面所有的 <code>&lt;bean&gt; </code>标签实例化到<code>IOC</code>容器中。</li><li>反射 + 工厂模式：通过<code>反射</code>消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，<code>反射</code>可以使得程序更加健壮。</li><li>JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的<code>驱动类</code>时用到反射加载驱动类</li></ul><h3 id="spring-的-ioc-容器" tabindex="-1"><a class="header-anchor" href="#spring-的-ioc-容器" aria-hidden="true">#</a> Spring 的 IOC 容器</h3><p>在 Spring 中，经常会编写一个上下文配置文件<code>applicationContext.xml</code>，里面就是关于<code>bean</code>的配置，程序启动时会读取该 xml 文件，解析出所有的 <code>&lt;bean&gt;</code>标签，并实例化对象放入<code>IOC</code>容器中。</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>smallpineapple<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.bean.SmallPineapple<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>java.lang.String<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>小菠萝<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>int<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>21<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在定义好上面的文件后，通过<code>ClassPathXmlApplicationContext</code>加载该配置文件，程序启动时，Spring 会将该配置文件中的所有<code>bean</code>都实例化，放入 IOC 容器中，IOC 容器本质上就是一个工厂，通过该工厂传入 <code>\\&lt;bean&gt;</code> 标签的<code>id</code>属性获取到对应的实例。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ApplicationContext</span> ac <span class="token operator">=</span>
                <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;applicationContext.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">SmallPineapple</span> smallPineapple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SmallPineapple</span><span class="token punctuation">)</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;smallpineapple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        smallPineapple<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [小菠萝的年龄是：21]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：</p><ul><li><strong>获取Class对象的构造器</strong></li><li>通过构造器<strong>调用 newInstance()</strong> 实例化对象</li></ul><p>当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的<strong>便捷且稳定</strong>。</p><blockquote><p>在之后的文章中会专门写一篇文章讲解如何利用反射实现一个<code>简易版</code>的<code>IOC</code>容器，IOC容器原理很简单，只要掌握了反射的思想，了解反射的常用 API 就可以实现，我可以提供一个简单的思路：利用 HashMap 存储所有实例，key 代表<code>\\&lt;bean&gt;</code>标签的 <code>id</code>，value 存储对应的实例，这对应了 Spring IOC容器管理的对象默认是<strong>单例</strong>的。</p></blockquote><h3 id="反射-抽象工厂模式" tabindex="-1"><a class="header-anchor" href="#反射-抽象工厂模式" aria-hidden="true">#</a> 反射 + 抽象工厂模式</h3><p>传统的工厂模式，如果需要生产新的子类，<strong>需要修改工厂类，在工厂类中增加新的分支</strong>；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> object<span class="token punctuation">&gt;</span></span> <span class="token function">produceMap</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;HashMap&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;TreeMap&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token comment">// ···</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>利用反射和工厂模式相结合，在产生新的子类时，<strong>工厂类不用修改任何东西</strong>，可以专注于子类的实现，<strong>当子类确定下来时，工厂也就可以生产该子类了。</strong></p><p>反射 + 抽象工厂的<strong>核心思想</strong>是：</p><ul><li><strong>在运行时通过参数传入不同子类的全限定名获取到不同的 Class 对象，调用 newInstance() 方法返回不同的子类。<strong>细心的读者会发现提到了</strong>子类</strong>这个概念，所以反射 + 抽象工厂模式，一般会用于有<strong>继承</strong>或者<strong>接口实现</strong>关系。</li></ul><p>例如，在运行时才确定使用哪一种 <code>Map</code> 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapFactory</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * <span class="token keyword">@param</span> <span class="token parameter">className</span> 类的全限定名
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">produceMap</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>className</code> 可以指定为 java.util.HashMap，或者 java.util.TreeMap 等等，根据业务场景来定。</p><h3 id="jdbc-加载数据库驱动类" tabindex="-1"><a class="header-anchor" href="#jdbc-加载数据库驱动类" aria-hidden="true">#</a> JDBC 加载数据库驱动类</h3><p>在导入第三方库时，JVM不会主动去加载外部导入的类，而是<strong>等到真正使用时，才去加载需要的类</strong>，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给 JVM 加载该类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DBConnectionUtil</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/** 指定数据库的驱动类 */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DRIVER_CLASS_NAME</span> <span class="token operator">=</span> <span class="token string">&quot;com.mysql.jdbc.Driver&quot;</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 加载驱动类</span>
        <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token constant">DRIVER_CLASS_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取数据库连接对象</span>
        conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc:mysql://···&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;root&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> conn<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们开发 SpringBoot 项目时，会经常遇到这个类，但是可能习惯成自然了，就没多大在乎，我在这里给你们看看常见的<code>application.yml</code>中的数据库配置，我想你应该会恍然大悟吧。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1597332406168-5103f33d-79f5-456b-9962-0f779bab5174.png" alt="img"></p><p>这里的 <strong>driver-class-name</strong>，和我们一开始加载的类是不是觉得很相似，这是因为<strong>MySQL</strong>版本不同引起的<strong>驱动类不同</strong>，这体现使用反射的好处：不需要修改源码，<strong>仅加载配置文件就可以完成驱动类的替换</strong>。</p><blockquote><p>在之后的文章中会专门写一篇文章详细地介绍反射的应用场景，实现简单的<code>IOC</code>容器以及通过反射实现工厂模式的好处。</p><p>在这里，你只需要掌握反射的基本用法和它的思想，了解它的主要使用场景。</p></blockquote><h2 id="反射的优势及缺陷" tabindex="-1"><a class="header-anchor" href="#反射的优势及缺陷" aria-hidden="true">#</a> 反射的优势及缺陷</h2><p>反射的<strong>优点</strong>：</p><ul><li><strong>增加程序的灵活性</strong>：面对需求变更时，可以灵活地实例化不同对象</li></ul><p>但是，有得必有失，一项技术不可能只有优点没有缺点，反射也有<strong>两个比较隐晦的缺点</strong>：</p><ul><li><strong>破坏类的封装性</strong>：可以强制访问 private 修饰的信息</li><li><strong>性能损耗</strong>：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的<strong>检查步骤和解析步骤</strong>，JVM无法对它们优化。</li></ul><h3 id="增加程序的灵活性" tabindex="-1"><a class="header-anchor" href="#增加程序的灵活性" aria-hidden="true">#</a> 增加程序的灵活性</h3><p>这里不再用 SmallPineapple 举例了，我们来看一个更加<code>贴近开发</code>的例子：</p><ul><li>利用反射连接数据库，<strong>涉及到数据库的数据源</strong>。在 SpringBoot 中一切约定大于配置，想要<strong>定制配置</strong>时，使用<code>application.properties</code>配置文件指定数据源</li></ul><p><strong>角色1 - Java的设计者</strong>：我们设计好<code>DataSource</code>接口，你们其它数据库厂商想要开发者用<code>你们的数据源</code>监控数据库，就得实现<code>我的这个接口</code>！</p><p><strong>角色2 - 数据库厂商</strong>：</p><ul><li>MySQL 数据库厂商：我们提供了 <strong>com.mysql.cj.jdbc.MysqlDataSource</strong> 数据源，开发者可以使用它连接 MySQL。</li><li>阿里巴巴厂商：我们提供了 <strong>com.alibaba.druid.pool.DruidDataSource</strong> 数据源，我这个数据源更牛逼，具有<strong>页面监控</strong>，<strong>慢SQL日志记录</strong>等功能，开发者快来用它监控 MySQL吧！</li><li>SQLServer 厂商：我们提供了 <strong>com.microsoft.sqlserver.jdbc.SQLServerDataSource</strong> 数据源，如果你想实用SQL Server 作为数据库，那就使用我们的这个数据源连接吧</li></ul><p><strong>角色3 - 开发者</strong>：我们可以用<code>配置文件</code>指定使用<code>DruidDataSource</code>数据源</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">spring.datasource.type</span><span class="token punctuation">=</span><span class="token value attr-value">com.alibaba.druid.pool.DruidDataSource</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>需求变更</strong>：某一天，老板来跟我们说，Druid 数据源不太符合我们现在的项目了，我们使用 <strong>MysqlDataSource</strong> 吧，然后程序猿就会修改配置文件，重新加载配置文件，并重启项目，完成数据源的切换。</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">spring.datasource.type</span><span class="token punctuation">=</span><span class="token value attr-value">com.mysql.cj.jdbc.MysqlDataSource</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在改变连接数据库的数据源时，只需要改变配置文件即可，<strong>无需改变任何代码</strong>，原因是：</p><ul><li><strong>Spring Boot 底层封装好了连接数据库的数据源配置，利用反射，适配各个数据源。</strong></li></ul><p>下面来简略的进行源码分析。我们用<code>ctrl+左键</code>点击<code>spring.datasource.type</code>进入 DataSourceProperties 类中，发现使用setType() 将<strong>全类名转化为 Class 对象</strong>注入到<code>type</code>成员变量当中。在连接并监控数据库时，就会使用指定的数据源操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">DataSource</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setType</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">DataSource</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Class</code>对象指定了泛型上界<code>DataSource</code>，我们去看一下各大数据源的<code>类图结构</code>。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596689119592-98ae06fd-c59e-4794-8130-ff0bdfe0f550.png" alt="image.png"></p><p><strong>上图展示了一部分数据源，当然不止这些，但是我们可以看到，无论指定使用哪一种数据源，我们都只需要与配置文件打交道，而无需更改源码，这就是反射的灵活性！</strong></p><h3 id="破坏类的封装性" tabindex="-1"><a class="header-anchor" href="#破坏类的封装性" aria-hidden="true">#</a> 破坏类的封装性</h3><p>很明显的一个特点，反射可以获取类中被<code>private</code>修饰的变量、方法和构造器，这<strong>违反了面向对象的封装特性</strong>，因为被 private 修饰意味着不想对外暴露，只允许本类访问，而<code>setAccessable(true)</code>可以无视访问修饰符的限制，外界可以强制访问。</p><p>还记得<code>单例模式</code>一文吗？里面讲到反射破坏饿汉式和懒汉式单例模式，所以之后用了<code>枚举</code>避免被反射KO。</p><p>回到最初的起点，SmallPineapple 里有一个 weight 属性被 private 修饰符修饰，目的在于自己的体重并不想给外界知道。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmallPineapple</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span> <span class="token comment">// 体重只有自己知道</span>
    
    <span class="token keyword">public</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">double</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然 weight 属性理论上只有自己知道，但是如果经过反射，这个类就像在<strong>裸奔</strong>一样，在反射面前变得<code>一览无遗</code>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SmallPineapple</span> sp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmallPineapple</span><span class="token punctuation">(</span><span class="token string">&quot;小菠萝&quot;</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token string">&quot;54.5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Clazz</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Field</span> weight <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;weight&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
weight<span class="token punctuation">.</span><span class="token function">setAccessable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;窥觑到小菠萝的体重是：&quot;</span> <span class="token operator">+</span> weight<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 窥觑到小菠萝的体重是：54.5 kg</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="性能损耗" tabindex="-1"><a class="header-anchor" href="#性能损耗" aria-hidden="true">#</a> 性能损耗</h3><p><strong>在直接 new 对象并调用对象方法和访问属性时，编译器会在编译期提前检查可访问性，如果尝试进行不正确的访问，IDE会提前提示错误，例如参数传递类型不匹配，非法访问 private 属性和方法。</strong></p><blockquote><p>而在利用反射操作对象时，编译器无法提前得知对象的类型，访问是否合法，参数传递类型是否匹配。只有在程序运行时调用反射的代码时才会从头开始检查、调用、返回结果，JVM也无法对反射的代码进行优化。</p></blockquote><p>虽然反射具有性能损耗的特点，但是我们不能一概而论，产生了使用反射就会性能下降的思想，反射的慢，需要同时调用上<code>100W</code>次才可能体现出来，在几次、几十次的调用，并不能体现反射的性能低下。所以不要一味地戴有色眼镜看反射，<strong>在单次调用反射的过程中，性能损耗可以忽略不计。如果程序的性能要求很高，那么尽量不要使用反射。</strong></p><h2 id="反射基础篇文末总结" tabindex="-1"><a class="header-anchor" href="#反射基础篇文末总结" aria-hidden="true">#</a> 反射基础篇文末总结</h2><ul><li>反射的思想：反射就像是<strong>一面镜子</strong>一样，在<strong>运行时</strong>才看到自己是谁，可获取到自己的信息，甚至实例化对象。</li><li>反射的作用：<strong>在运行时才确定实例化对象，使程序更加健壮</strong>，面对需求变更时，可以最大程度地做到不修改程序源码应对不同的场景，实例化不同类型的对象。</li><li>反射的应用场景常见的有<code>3</code>个：Spring的 IOC 容器，反射+工厂模式 使工厂类更稳定，JDBC连接数据库时加载驱动类</li><li>反射的<code>3</code>个特点：增加程序的灵活性、破坏类的封装性以及性能损耗</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivkbczxoj31l20t8al5.jpg" alt="image-20210716163352584"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivl4khz9j31d60h8mze.jpg" alt="image-20210716163433337"></p>`,155),o=[e];function c(l,i){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","java-reflect.html.vue"]]);export{r as default};
