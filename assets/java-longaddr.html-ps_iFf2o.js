import{_ as t,r as o,o as c,c as l,a as s,b as n,d as e,e as a}from"./app-3RcBQnkC.js";const i={},u=a('<h1 id="longadder-用法和源码剖析" tabindex="-1"><a class="header-anchor" href="#longadder-用法和源码剖析" aria-hidden="true">#</a> LongAdder 用法和源码剖析</h1><ul><li><a href="#longadder-%E7%94%A8%E6%B3%95%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90">LongAdder 用法和源码剖析</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5-longadder">为什么引入 LongAdder</a></li><li><a href="#%E8%AE%A4%E8%AF%86-longadder">认识 LongAdder</a></li><li><a href="#%E8%AE%A4%E8%AF%86-striped64">认识 Striped64</a><ul><li><a href="#%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84-longaccumulate">最关键的 longAccumulate</a></li></ul></li><li><a href="#longadder-%E7%9A%84%E5%86%8D%E8%AE%A4%E8%AF%86">LongAdder 的再认识</a></li><li><a href="#%E5%90%8E%E8%AE%B0">后记</a></li></ul></li></ul><p>我们在之前的文章中介绍到了 AtomicLong ，如果你还不了解，我建议你阅读一下这篇文章</p>',3),r={href:"https://github.com/crisxuan/bestJavaer/blob/master/java-concurrent/java-atomicxxx.md",target:"_blank",rel:"noopener noreferrer"},d=a(`<p>为什么我要先说 AtomicLong 呢？因为 LongAdder 的设计是根据 AtomicLong 的缺陷来设计的。</p><h2 id="为什么引入-longadder" tabindex="-1"><a class="header-anchor" href="#为什么引入-longadder" aria-hidden="true">#</a> 为什么引入 LongAdder</h2><p>我们知道，AtomicLong 是利用底层的 CAS 操作来提供并发性的，比如 <code>addAndGet</code> 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span> <span class="token operator">+</span> delta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还知道，CAS 是一种轻量级的自旋方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。(也即乐观锁的实现模式)</p><p>在并发数量比较低的场景中，线程冲突的概率比较小，自旋的次数不会很多。但是，在并发数量激增的情况下，会出现大量失败并不断自旋的场景，此时 AtomicLong 的自旋次数很容易会成为瓶颈。</p><p>为了解决这种缺陷，引入了本篇文章的主角 --- LongAdder，它主要解决高并发环境下 AtomictLong 的自旋瓶颈问题。</p><h2 id="认识-longadder" tabindex="-1"><a class="header-anchor" href="#认识-longadder" aria-hidden="true">#</a> 认识 LongAdder</h2><p>我们先看一下 JDK 源码中关于 LongAdder 的讨论</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf5stiimrj60v408cta202.jpg" alt="image-20211014212705102" style="zoom:67%;"><p>这段话很清晰的表明，在多线程环境下，如果业务场景更侧重于<code>统计数据</code>或者<code>收集信息</code>的话，<strong>LongAdder 要比 AtomicLong 有更好的性能，吞吐量更高，但是会占用更多的内存</strong>。在并发数量较低或者单线程场景中，AtomicLong 和 LongAdder 具有相同的特征，也就是说，在上述场景中，AtomicLong 和 LongAdder 可以互换。</p><p>首先我们先来看一下 LongAdder类的定义：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guvhba12h6j60ve01c3ym02.jpg" alt="image-20210927205405590"></p><p>可以看到，LongAdder 继承于 <em>Striped64</em>类，并实现了 <em>Serializable</em> 接口。</p><p>Striped64 又是继承于 Number 类，现在你可能不太清楚 Striped64 是做什么的，但是你别急。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guvjerrbqzj608y07e0t002.jpg" alt="image-20210927220641285"></p><p>我们知道，Number 类是基本数据类型的包装类以及原子性包装类的父类，继承 Number 类表示它可以当作数值进行处理，然而这样并不能说明什么，它对我们来说还是一头雾水，随后我翻了翻 Striped64 的继承体系，发现这个类有几个实现，而这几个实现能够很好的帮助我们理解什么是 Striped64。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guvjs2c2eyj30r0072ta7.jpg" alt="image-20210927221928038"></p><p>在其中我们看到了 <em>Accumulator</em>，它的中文概念就是<strong>累加器</strong>，所以我们猜测 Striped64 也能实现累加的功能。果不其然，在我求助了部分帖子之后，我们可以得出来一个结论：<strong>Striped64 就是一个支持 64 位的累加器</strong>。</p><p>但是那两个 Accumulator 的实现可以实现累加，这个好理解，但是这两个 Adder 呢？它们也能实现累加的功能吗？</p><p>我们再次细致的查看一下 LongAdder 和 DoubleAdder 的源码（因为这两个类非常相似）。</p><p>（下面的叙事风格主要以 LongAdder 为准，DoubleAdder 会兼带着聊一下，但不是主要叙事对象，毕竟这两个类的基类非常相似。）</p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0132335d511115a8012187f4205b46.gif&amp;refer=http%3A%2F%2Fimg.zcool.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1635345475&amp;t=6fd822923cb555606849a9b1aeadd45f" alt="img" style="zoom:25%;"><p>在翻阅一波源码过后，我们发现了一些方法，比如 <em>increment、decrement、add、reset、sum</em>等，这些方法看起来好像是一个累加器所拥有的功能。</p><p>在详细翻阅源码后，我认证了我的想法，因为 increment 、decrement 都是调用的 add 方法，而 add 方法底层则使用了 <em>longAccmulate</em>，我给你画个图你就知道了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv4ricucbzj60ma0cfmxr02.jpg" alt="image-20211005213659245"></p><p>所以，LongAdder 的第一个特性就是可以处理数值，而实现了 Serializable 这个接口表示 LongAdder 可以序列化，以便存储在文件中或在网络上传输。</p><p>然后我们继续往下走，现在时间的罗盘指向了 LongAdder 的 add 方法，我们脑子里面已经有印象，这个 LongAdder 方法是来做并发累加的，所以这个 add 方法如果不出意外就是并发的累加方法，那么很奇怪了，这个方法为什么没有使用 synchronized 呢？</p><p>我们继续观察 add 方法都做了哪些操作。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf5p6b6qaj30u60b8jss.jpg" alt="image-20211014212335838"></p><p>开始时就是分配了一些变量而已啊，这也没什么特殊的，继续看到第二行的时候，我们发现有一个 <em>cells</em> 对象，这个 cells 对象是个数组，好像是个全局的。。。。。。那么在哪里定义的呢？</p><p>一想到还有个 Striped64 这个类，果断点进去看到了这个全局变量，另外，Striped64 这个类很重要，我们可不能把它忘了。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv4t9ksy1vj60fm0bg3yo02.jpg" alt="image-20211005223747438" style="zoom:50%;"><p>在 Striped64 类中，赫然出现了下面这三个重要的全局变量。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf5pfg4vbj30wa0kkmza.jpg" alt="image-20211014212350947" style="zoom:50%;"><p>由 transient 修饰的这三个全局变量，会保证不会被序列化。</p><p>我们先不解释这三个变量是什么，有什么用，因为我们刚刚撸到了 add 方法，所以还是回到 add 方法上来：</p><p>继续向下走，我们看到了 <em>caseBase</em> 方法，这个方法又是干什么的？点进去，发现还是 Striped64 中的方法，现在，我们陷入了沉思。</p><p><strong>我们上面只是知道了 Striped64 是一个累加器，但是我现在要不要撸一遍 Striped64 的源码？？？？？？</strong></p><h2 id="认识-striped64" tabindex="-1"><a class="header-anchor" href="#认识-striped64" aria-hidden="true">#</a> 认识 Striped64</h2><p>果然出来混都是要还的，上面没有介绍的 Striped64 的三个变量，现在就要好好介绍一波了。</p><ul><li>cells 它是一个数组，如果不是 null ，它的大小就是 2 的次方。</li><li>base 是 Striped64 的基本数值，<strong>主要在没有争用时使用，同时也作为 cells 初始化时使用，使用 CAS 进行更新</strong>。</li><li>cellsBusy 它是一个 <code>SpinLock(自旋锁)</code>，在初始化 cells 时使用。</li></ul><p>除了这三个变量之外，还有一个变量，我竟然把它忽视了，罪过罪过。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf5q4im2zj30w204cdg7.jpg" alt="image-20211014212430723" style="zoom:50%;"><p>它表示的是 CPU 的核数。</p><p>好像并没有看出来什么玄机，接着往下走</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf5qdtvinj60xq0ni77202.jpg" alt="image-20211014212445958" style="zoom:50%;">`,47),k=s("em",null,"UNSAFE",-1),m={href:"https://github.com/crisxuan/bestJavaer/blob/master/java-concurrent/java-atomicxxx.md",target:"_blank",rel:"noopener noreferrer"},v=a(`<p>而这个 Cell 元素，就是 cells 数组中的每个对象。</p><p>这里比较特殊的是 <code>@sun.misc.Contended</code> 注解，它是 Java 8 中新增的注解，用来避免缓存的伪共享，减少 CPU 缓存级别的竞争。</p><p>害，就这？</p><p>先不要着急，Striped64 最核心的功能是分别为 LongAdder 和 DoubleAdder 提供并发累加的功能，所以 Striped64 中的 longAccumulate 和 doubleAccumulate 才是关键，我们主要介绍 longAccumulate 方法，方法比较长，我们慢慢进入节奏。</p><h3 id="最关键的-longaccumulate" tabindex="-1"><a class="header-anchor" href="#最关键的-longaccumulate" aria-hidden="true">#</a> 最关键的 longAccumulate</h3><p>先贴出来 longAccumulate 的完整代码，然后我们再进行分析：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">longAccumulate</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token class-name">LongBinaryOperator</span> fn<span class="token punctuation">,</span>
                          <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取线程的哈希值</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// force initialization</span>
        h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// True if last slot nonempty</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// cells 已经初始化了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的 cell 不存在，需要新建</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 只有在 cells 没上锁时才尝试新建</span>
                    <span class="token class-name">Cell</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 上锁</span>
                        <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{</span>               <span class="token comment">// 上锁后判断 cells 对应元素是否被占用</span>
                            <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                                <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                                rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
                                created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                            cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>        <span class="token comment">// cell 创建完毕，可以退出</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">continue</span><span class="token punctuation">;</span>           <span class="token comment">// 加锁后发现 cell 元素已经不再为空，轮询重试</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 下面这些 else 在尝试检测当前竞争度大不大，如果大则尝试扩容，如</span>
            <span class="token comment">// 果扩容已经没用了，则尝试 rehash 来分散并发到不同的 cell 中</span>

            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span>       <span class="token comment">// 已知 CAS 失败，说明并发度大</span>
                wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment">// rehash 后重试</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span>   <span class="token comment">// 尝试 CAS 将值更新到 cell 中</span>
                                         fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token constant">NCPU</span> <span class="token operator">||</span> cells <span class="token operator">!=</span> as<span class="token punctuation">)</span> <span class="token comment">// cells 数组已经够大，rehash</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>               <span class="token comment">// At max size or stale</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>                 <span class="token comment">// 到此说明其它竞争已经很大，rehash</span>
                collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// rehash 都没用，尝试扩容</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 加锁过程中可能有其它线程在扩容，需要排除该情形</span>
                        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                            rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment">// Retry with expanded table</span>
            <span class="token punctuation">}</span>
            h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// rehash</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// cells 未初始化</span>
            <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>                           <span class="token comment">// Initialize table</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                    init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casBase</span><span class="token punctuation">(</span>v <span class="token operator">=</span> base<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span>
                                    fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 其它线程在初始化 cells 或在扩容，尝试更新 base</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先别忙着惊讶，整理好心情慢慢看。</p><p>首先，在 Striped64 中，会先计算哈希，哈希值用于分发线程到 cells 数组。Striped64 中利用了 Thread 类中用来做伪随机数的 <code>threadLocalRandomProbe</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@sun.misc.Contended</span><span class="token punctuation">(</span><span class="token string">&quot;tlr&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">int</span> threadLocalRandomProbe<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Striped64 中复制（直接拿来用）了 <code>ThreadLocalRandom</code> 中的一些方法，使用 unsafe 来获取和修改字段值。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvcjgj6dqfj60x60s6q6002.jpg" alt="image-20211012150253007" style="zoom:50%;"><p>可以理解为 <code>getProbe</code> 用来获取哈希值，<code>advanceProbe</code> 用来更新哈希值。</p><p>而其中的 <code>PROBE</code> 常量是在类加载的时候从类加载器提取的 threadLocalRandomProbe 的常量值。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvcjj1nn16j60vs0hytb702.jpg" alt="image-20211012150523655" style="zoom:50%;"><p>然后是一系列的循环判断向 cell 数组映射的操作，因为 Cells 类占用比较多的空间，所以它的初始化按需进行的，开始时为空，需要时先创建两个元素，不够用时再扩展成两倍大小。在修改 cells 数组（如扩展）时需要加锁，这也就是 <code>cellsBusy</code> 的作用。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvcjsdtdi0j60vi08gjs702.jpg" alt="image-20211012151423319" style="zoom:50%;"><p>释放锁只需要将 cellsBusy 从 0 -&gt; 1 即可。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外，这个方法虽然代码行很多，使用了很多 if else ，但其实代码设计使用了<em>双重检查锁</em>，也就是下面这种模式</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>condition_met<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 只在必要时进入</span>
  <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 加锁</span>
  done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">// 因为外层有轮询，需要记录任务是否需要继续</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition_met<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 前面的 if 到加锁间状态可能变化，需要重新判断</span>
      <span class="token comment">// ...</span>

      done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token comment">// 任务完成</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 确保锁释放</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span>                <span class="token comment">// 任务完成，可以退出轮询</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 <code>doubleAccumulate</code> 的整体逻辑与 longAccumulate 几乎一样，区别在于将 double 存储成 long 时需要转换。例如在创建 cell 时，需要</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Cell</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">doubleToRawLongBits</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>doubleToRawLongBits 是一个 native 方法，将 <code>double</code> 转成 <code>long</code>。在累加时需要再转来回：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
               <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                <span class="token class-name">Double</span><span class="token punctuation">.</span>doubleToRawLongBits
                <span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">longBitsToDouble</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">+</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token comment">// 转回 double 做累加</span>
                <span class="token class-name">Double</span><span class="token punctuation">.</span>doubleToRawLongBits
                <span class="token punctuation">(</span>fn<span class="token punctuation">.</span>applyAsDouble
                 <span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">longBitsToDouble</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的流程我们只是高度概括了下，实际的分支要远比我们概括的更多，longAccumulate 会根据不同的状态来执行不同的分支，比如在线程竞争非常激烈的情况下，还会通过对 cells 进行扩容或者重新计算哈希值来重新分散线程，这些做法的目的是将多个线程的计数请求分散到不同的 cell 中的 index 上，这其实和 <code>ConcurrentHashMap</code> 的设计思路一样，只不过 Java7 中的 ConcurrentHashMap 实现 segment 加锁使用了比较重的 <code>synchronized</code> 锁，而 Striped64 使用了轻量级的 unsafe CAS 来进行并发操作。</p><p><strong>一口气终于讲完一个段落了，累屁我了，歇会继续肝下面</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvcueyxzgkj60by05iq2w02.jpg" alt="image-20211012212203127"></p><p>下面再说回 LongAdder 这个类。</p><h2 id="longadder-的再认识" tabindex="-1"><a class="header-anchor" href="#longadder-的再认识" aria-hidden="true">#</a> LongAdder 的再认识</h2><p>所以，LongAdder 的原理就是，在最初无竞争时，只更新 base 值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的 LongAdder 存储的值，下面我画个图帮助你理解一下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf5riuob0j61e60u0n1202.jpg" alt="image-20211014212550880"></p><p>如果你理解了上面 Striped64 的描述和上面这幅图之后，LongAdder 你就理解的差不多了，最后还有一个 LongAdder 中的 sum 方法需要强调下：</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf5rukbmwj60m00ciwf702.jpg" alt="image-20211014212611052" style="zoom:50%;"><p><code>sum</code> 方法会返回当前总和，在没有并发的情况下会返回一个准确的结果，也就是把所有的 base 值相加求和之后的结果，那么，现在有一个问题，如果前面已经累加到 sum 上的 Cell 的 value 值有修改，不就没法计算了吗？</p><blockquote><p>这里的结论就是，LongAdder 不是强一致性的，它是最终一致性。</p></blockquote><h2 id="后记" tabindex="-1"><a class="header-anchor" href="#后记" aria-hidden="true">#</a> 后记</h2><p>这篇我和你聊了一下为什么引入 LongAdder 以及 AtomicLong 有哪些缺陷，然后带你了解了一下 LongAdder 的源码和它的底层实现，如果这篇文章对你有帮助的话，可以给我个三连，你的支持是我更新最大的动力！</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivkbczxoj31l20t8al5.jpg" alt="image-20210716163352584"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivl4khz9j31d60h8mze.jpg" alt="image-20210716163433337"></p>`,40);function g(b,y){const p=o("ExternalLinkIcon");return c(),l("div",null,[u,s("p",null,[s("a",r,[n("Atomic 原子工具类详解"),e(p)])]),d,s("p",null,[n("这里出现了一个 Cell 元素的内部类，里面出现了 long 型的 value 值，cas 方法，"),k,n("，valueOffSet 元素，如果你看过我的这篇文章 "),s("a",m,[n("Atomic 原子工具类详解"),e(p)]),n(" 或者你了解 AtomicLong 的设计的话，你就知道，Cell 的设计是和 AtomicLong 完全一样的，都是使用了 volatile 变量、Unsafe 加上字段的偏移量，再用 CAS 进行修改。")]),v])}const f=t(i,[["render",g],["__file","java-longaddr.html.vue"]]);export{f as default};
