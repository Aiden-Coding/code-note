import{_ as e,o as s,c as r,e as a}from"./app-3RcBQnkC.js";const t="/code-note/assets/zookeeper-distributed-lock-L2qWGDUd.png",d={},o=a('<h1 id="redis-的并发竞争问题是什么-如何解决这个问题-了解-redis-事务的-cas-方案吗" tabindex="-1"><a class="header-anchor" href="#redis-的并发竞争问题是什么-如何解决这个问题-了解-redis-事务的-cas-方案吗" aria-hidden="true">#</a> Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？</h1><h2 id="面试官心理分析" tabindex="-1"><a class="header-anchor" href="#面试官心理分析" aria-hidden="true">#</a> 面试官心理分析</h2><p>这个也是线上非常常见的一个问题，就是<strong>多客户端同时并发写</strong>一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p><p>而且 Redis 自己就有天然解决这个问题的 CAS 类的乐观锁方案。</p><h2 id="面试题剖析" tabindex="-1"><a class="header-anchor" href="#面试题剖析" aria-hidden="true">#</a> 面试题剖析</h2><p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p><p><img src="'+t+'" alt="zookeeper-distributed-lock"></p><p>你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。</p><p>每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>',9),i=[o];function c(n,h){return s(),r("div",null,i)}const l=e(d,[["render",c],["__file","redis-cas.html.vue"]]);export{l as default};
