import{_ as e,o as a,c as i,e as p}from"./app-3RcBQnkC.js";const l={},d=p('<h1 id="程序的机器级表示" tabindex="-1"><a class="header-anchor" href="#程序的机器级表示" aria-hidden="true">#</a> 程序的机器级表示</h1><ul><li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA">程序的机器级表示</a><ul><li><a href="#%E6%8C%87%E4%BB%A4%E9%9B%86">指令集</a><ul><li><a href="#%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86">精简指令集</a></li><li><a href="#%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86">复杂指令集</a></li></ul></li><li><a href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81">机器级代码</a></li><li><a href="#%E8%AE%A4%E8%AF%86%E6%B1%87%E7%BC%96">认识汇编</a></li><li><a href="#%E4%B8%8E%E6%B1%87%E7%BC%96%E6%9C%89%E5%85%B3%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%92%8C%E6%A6%82%E5%BF%B5">与汇编有关的硬件和概念</a><ul><li><a href="#cpu">CPU</a></li><li><a href="#%E5%86%85%E5%AD%98">内存</a></li><li><a href="#%E7%A3%81%E7%9B%98">磁盘</a></li><li><a href="#%E6%80%BB%E7%BA%BF">总线</a><ul><li><a href="#%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4">读操作步骤</a></li><li><a href="#%E5%86%99%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4">写操作步骤</a></li></ul></li><li><a href="#%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF">地址总线</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF">数据总线</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF">控制总线</a></li><li><a href="#%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E7%9A%84%E8%AF%BB%E5%8F%96%E8%BF%87%E7%A8%8B">一次内存的读取过程</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><p>汇编代码是计算机的一种低级表示，它是一种低级语言，可以从字面角度去理解它，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信等。编译器生成机器码经过了一系列的转换，这些转换遵循<code>编程语言</code>、目标机器的<code>指令集</code> 和<code>操作系统</code>。</p><h2 id="指令集" tabindex="-1"><a class="header-anchor" href="#指令集" aria-hidden="true">#</a> 指令集</h2><p>指令集就是指挥计算机工作的指令，因为程序就是按照一定执行顺序排列的指令。因为计算机的执行控制权由 CPU 操作，所以指令集就是 CPU 中用来计算和控制计算机的一系列指令的集合。每个 CPU 在产出时都规定了与硬件电路相互配合工作的指令集。</p><p>指令集有不少分类，但是一般分为两种，一种是<code>精简指令集</code>，一种是<code>复杂指令集</code>。具体描述如下</p><h3 id="精简指令集" tabindex="-1"><a class="header-anchor" href="#精简指令集" aria-hidden="true">#</a> 精简指令集</h3><p>精简指令的英文是 <code>reduced instruction set computer， RISC</code>，原意是精简指令集计算，简称为精简指令集，是 CPU 的一种 <code>设计模式</code>，可以把 CPU 想象成一家流水线工厂，对<code>指令数目</code>和<code>寻址方式</code>都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。</p><p>常见的精简指令集处理器包括 <strong>ARM、AVR、MIPS、PARISC、RISC-V 和 SPARC</strong>。</p><p>所以你就能理解</p><p><img src="http://www.cxuan.vip/image-20230128210530837.png" alt=""></p><p>这本书是讲啥的了。</p><blockquote><p>它主要是基于 MIPS 体系结构把冯诺依曼体系的五大组件进行了逐一的硬件实现 + 软件设计介绍，更为重要的是引入了诸多并行计算的内容，这是大部分教材中忽略或者内容较少的，会根据这个思路把并行相关的内容，结合 OpenMP, CUDA 和 Hadoop/Spark 整体融入到新书中，毕竟这是未来发展的趋势</p></blockquote><p>还有这本书</p><p><img src="http://www.cxuan.vip/image-20230128210645920.png" alt=""></p><p>这本书又是讲啥的。</p><p>这本书是讲 RISC-V 指令集的，因为指令集的不同也区分了三个版本，三个版本？？？嗯，还有下面这个</p><p><img src="http://www.cxuan.vip/image-20230128210810425.png" alt=""></p><p>这本书是讲 ARM 指令集的。</p><p>所以一般在看 CASPP 的时候并发的看看这本书是非常不错的选择。</p><p>精简指令集一般具有如下特征</p><ul><li>统一的指令编码</li><li>通用的寄存器，一般会区分整数和浮点数</li><li>简单的寻址模式，复杂寻址模式被简单指令序列来取代</li><li>支持很少偏门的类型，例如 RISC 支持字节字符串类型。</li></ul><h3 id="复杂指令集" tabindex="-1"><a class="header-anchor" href="#复杂指令集" aria-hidden="true">#</a> 复杂指令集</h3><p>复杂指令集的英文是 <code>Complex Instruction Set Computing, CISC</code>，是一种微处理器指令集架构，也被译为复杂指令集。</p><p>复杂指令集包括 <strong>System/360、VAX、x86 等</strong>。</p><p>复杂指令集可以说是在精简指令集之上作出的改变。</p><p>复杂指令集的特点是指令数目多而复杂，每条指令字长并不相等，计算机必须加以判读，并为此付出了性能的代价。</p><p>一般来说，提升 CPU 性能的方法有如下这几种</p><ul><li>增加寄存器的大小</li><li>增进内部的并行性</li><li>增加高速缓存的大小</li><li>增加核心时脉的速度</li><li>加入其他功能，例如 IO 和计时器</li><li>加入向量处理器</li><li>硬件多线程技术</li></ul><p>比较抽象，我们后面会组织成文章具体介绍一下。</p><p>C 编译器会接收其他操作并把其转换为<code>汇编语言</code>输出，汇编语言是机器级别的代码表示。我们之前介绍过，C 语言程序的执行过程分为下面这几步</p><p><img src="http://www.cxuan.vip/image-20230118093008167.png" alt=""></p><p>下面我们更多的讨论都是基于汇编代码来讨论。</p><p>我们日常所接触的高级语言，都是经过了层层封装的结果，所以我们平常是接触不到汇编语言的，更不会用汇编语言来进行编程，这就和你不知道操作系统的存在一样，但其实你每个操作，甚至你双击一个图标都和操作系统有关系。</p><p>高级语言的抽象级别很高，但是经过了层层抽象之后，高级语言的执行效率肯定没有汇编语言高，也没有汇编语言可靠。</p><p>但是高级语言有更大的优点是其编译后能够在不同的机器上运行，汇编语言针对不同的指令集有不同的表示。并且高级语言学习来更加通俗易懂，降低计算机门槛，让内卷更加严重（当然这是开个玩笑，冒犯到请别当真）。</p><blockquote><p>话不多说，了解底层必须了解汇编语言。否则一个 synchronized 底层实现就能够让你头疼不已。而且，天天飘着也不好，迟早要落地。</p></blockquote><p>了解汇编代码也有助于我们优化程序代码，分析代码中隐含的低效率，并且这种优化方法一旦优化成功，将是量级的提高，而不是改改 if...else ，使用一个新特性所能比的。</p><h2 id="机器级代码" tabindex="-1"><a class="header-anchor" href="#机器级代码" aria-hidden="true">#</a> 机器级代码</h2><p>计算机系统使用了多种不同形式的抽象，可以通过一个简单的抽象模型来隐藏实现细节。对于机器级别的程序来说，有两点非常重要。</p><p>首先第一点，定义机器级别程序的格式和行为被称为 <code>指令集体系结构或指令集架构(instruction set architecture)</code>， ISA。ISA 定义了进程状态、指令的格式和每一个指令对状态的影响。大部分的指令集架构包括 ISA 用来描述进程的行为就好像是顺序执行的，一条指令执行结束后，另外一条指令再开始。处理器硬件的描述要更复杂，它可以同时并行执行许多指令，但是它采用了<code>安全措施</code>来确保整体行为与 ISA 规定的顺序一致。</p><p>第二点，机器级别对内存地址的描述就是 <code>虚拟地址(virtual address)</code>，它提供了一个内存模型来表示一个巨大的字节数组。</p><p>编译器在整个编译的过程中起到了至关重要的作用，把 C 语言转换为处理器执行的基本指令。汇编代码非常接近于机器代码，只不过与二进制机器代码相比，汇编代码的可读性更强，所以理解汇编是理解机器工作的第一步。</p><p>一些进程状态对机器可见，但是 C 语言程序员却看不到这些，包括</p><ul><li><code>程序计数器(Program counter)</code>，它存储下一条指令的地址，在 x86-64 架构中用 <code>%rip</code> 来表示。</li></ul><p>程序执行时，PC 的初始值为程序第一条指令的地址，在顺序执行程序时， CPU 首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将 PC 的值加 1 并指向下一条要执行的指令。</p><p>比如下面一个例子。</p><p><img src="http://www.cxuan.vip/image-20230118093022495.png" alt=""></p><p>这是一段数值进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。由于使用机器语言难以描述，所以这是经过翻译后的结果，实际上每个指令和数据都可能分布在不同的地址上，但为了方便说明，把组成一条指令的内存和数据放在了一个内存地址上。</p><ul><li>整数<code>寄存器文件(register file)</code>包含 16 个命名的位置，用来存储 64 位的值。这些寄存器可以存储地址和整型数据。有些寄存器用于跟踪程序状态，而另一些寄存器用于保存临时数据，例如过程的参数和局部变量，以及函数要返回的值。这个 <code>文件</code> 是和磁盘文件无关的，它只是 CPU 内部的一块高速存储单元。有专用的寄存器，也有通用的寄存器用来存储操作数。</li><li><code>条件码寄存器</code> 用来保存有关最近执行的算术或逻辑指令的状态信息。这些用于实现控件或数据流中的条件更改，例如实现 if 和 while 语句所需的条件更改。我们都学过高级语言，高级语言中的条件控制流程主要分为三种：<code>顺序执行、条件分支、循环判断</code>三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。 <ul><li>顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。</li><li>条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。</li></ul></li></ul><p>下面以条件分支为例来说明程序的执行过程（循环也很相似）</p><p><img src="http://www.cxuan.vip/image-20230118093032650.png" alt=""></p><p>程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序+1，执行到 0102 地址的指令时，判断 0106 寄存器的数值大于 0，跳转（jump）到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 <code>if()</code> 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接+1，而是下一条指令的地址。</p><ul><li>一组 <code>向量寄存器</code>用来存储一个或者多个整数或者浮点数值，向量寄存器是对一维数据上进行操作。</li></ul><p>机器指令只会执行非常简单的操作，例如将存放在寄存器的两个数进行相加，把数据从内存转移到寄存器中或者是条件分支转移到新的指令地址。编译器必须生成此类指令的序列，以实现程序构造，例如算术表达式求值，循环或过程调用和返回</p><h2 id="认识汇编" tabindex="-1"><a class="header-anchor" href="#认识汇编" aria-hidden="true">#</a> 认识汇编</h2><p>我相信各位应该都知道汇编语言的出现背景吧，那就是二进制表示数据，太复杂太庞大了，为了解决这个问题，出现了汇编语言，汇编语言和机器指令的区别就在于表示方法上，汇编使用<code>操作数</code>来表示，机器指令使用二进制来表示，我之前多次提到机器码就是汇编，你也不能说我错，但是不准确。</p><p>但是汇编适合二进制代码存在转换关系的。</p><p>汇编代码需要经过 <code>汇编器</code> 编译后才产生二进制代码，这个二进制代码就是目标代码，然后由链接器将其连接起来运行。</p><p><img src="http://www.cxuan.vip/image-20230118093056675.png" alt=""></p><p>汇编语言主要分为以下三类</p><ul><li>汇编指令：它是一种机器码的<code>助记符</code>，它有对应的机器码</li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号，比如 +、-、*、/ 等，由编译器识别，没有对应的机器码</li></ul><p>汇编语言的核心是汇编指令，而我们对汇编的探讨也是基于汇编指令展开的。</p><h2 id="与汇编有关的硬件和概念" tabindex="-1"><a class="header-anchor" href="#与汇编有关的硬件和概念" aria-hidden="true">#</a> 与汇编有关的硬件和概念</h2><h3 id="cpu" tabindex="-1"><a class="header-anchor" href="#cpu" aria-hidden="true">#</a> CPU</h3><p>CPU 是计算机的大脑，它也是整个计算机的核心，它也是执行汇编语言的硬件，CPU 的内部包含有寄存器，而寄存器是用于存储指令和数据的，汇编语言的本质也就是 CPU 内部操作数所执行的一系列计算。</p><h3 id="内存" tabindex="-1"><a class="header-anchor" href="#内存" aria-hidden="true">#</a> 内存</h3><p>没有内存，计算机就像是一个没有记忆的人类，只会永无休止的重复性劳动。CPU 所需的指令和数据都由内存来提供，CPU 指令经由内存提供，经过一系列计算后再输出到内存。</p><h3 id="磁盘" tabindex="-1"><a class="header-anchor" href="#磁盘" aria-hidden="true">#</a> 磁盘</h3><p>磁盘也是一种存储设备，它和内存的最大区别在于永久存储，程序需要在内存装载后才能运行，而提供给内存的程序都是由磁盘存储的。</p><h3 id="总线" tabindex="-1"><a class="header-anchor" href="#总线" aria-hidden="true">#</a> 总线</h3><p>一般来说，内存内部会划分多个存储单元，存储单元用来存储指令和数据，就像是房子一样，存储单元就是房子的门牌号。而 CPU 与内存之间的交互是通过地址<code>总线</code>来进行的，总线从逻辑上分为三种</p><ul><li>地址线</li><li>数据线</li><li>控制线</li></ul><img src="http://www.cxuan.vip/image-20230118094211136.png"><p>CPU 与存储器之间的读写主要经过以下几步</p><h4 id="读操作步骤" tabindex="-1"><a class="header-anchor" href="#读操作步骤" aria-hidden="true">#</a> 读操作步骤</h4><ul><li>CPU 通过地址线发出需要读取指令的位置</li><li>CPU 通过控制线发出读指令</li><li>内存把数据放在数据线上返回给 CPU</li></ul><h4 id="写操作步骤" tabindex="-1"><a class="header-anchor" href="#写操作步骤" aria-hidden="true">#</a> 写操作步骤</h4><ul><li>CPU 通过地址线发出需要写出指令的位置</li><li>CPU 通过控制线发出写指令</li><li>CPU 把数据通过数据线写入内存</li></ul><p>下面我们就来具体了解一下这三类总线</p><h3 id="地址总线" tabindex="-1"><a class="header-anchor" href="#地址总线" aria-hidden="true">#</a> 地址总线</h3><p>通过我们上面的探讨，我们知道 CPU 通过<code>地址总线</code>来指定存储位置的，地址总线上能传送多少不同的信息，CPU 就可以对多少个存储单元进行寻址。</p><p><img src="http://www.cxuan.vip/image-20230128211458439.png" alt=""></p><p>上图中 CPU 和内存中间信息交换通过了 10 条地址总线，每一条线能够传递的数据都是 0 或 1 ，所以上图一次 CPU 和内存传递的数据是 2 的十次方。</p><p>所以，如果 CPU 有 N 条地址总线，那么可以说这个地址总线的宽度是 N 。这样 CPU 可以寻找 2 的 N 次方个内存单元。</p><h3 id="数据总线" tabindex="-1"><a class="header-anchor" href="#数据总线" aria-hidden="true">#</a> 数据总线</h3><p>CPU 与内存或其他部件之间的数据传送是由<code>数据总线</code>来完成的。数据总线的宽度决定了 CPU 和外界的数据传输速度。8 根数据总线可以一次传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可以传输两个字节，32 根数据总线可以一次传输四个字节。。。。。。</p><h3 id="控制总线" tabindex="-1"><a class="header-anchor" href="#控制总线" aria-hidden="true">#</a> 控制总线</h3><p>CPU 与其他部件之间的控制是通过 <code>控制总线</code> 来完成的。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部部件的控制能力。</p><h3 id="一次内存的读取过程" tabindex="-1"><a class="header-anchor" href="#一次内存的读取过程" aria-hidden="true">#</a> 一次内存的读取过程</h3><p><strong>内存结构</strong></p><p>内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图</p><p><img src="http://www.cxuan.vip/image-20230118094240801.png" alt=""></p><p>图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，<strong>+5V 表示1，0V 表示 0</strong>。</p><p>我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = <code>1024个地址</code>。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。</p><p>如果我们使用的是 512 MB 的内存，这就相当于是 512000（512 * 1000） 个内存 IC。当然，一台计算机不太可能有这么多个内存 IC ，然而，通常情况下，一个内存 IC 会有更多的引脚，也就能存储更多数据。</p><p><strong>内存读取过程</strong></p><p>下面是一次内存的读取过程。</p><p><img src="http://www.cxuan.vip/image-20230118094256309.png" alt=""></p><p>来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：</p><ul><li>首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 <code>A0 - A9</code> 来指定数据的存储场所，然后再把数据的值输入给 <code>D0 - D7</code> 的数据信号，并把 <code>WR（write）</code>的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据</li><li>读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。</li><li>图中的 RD 和 WR 又被称为控制信号。其中当WR 和 RD 都为 0 时，无法进行写入和读取操作。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>此篇文章我们主要探讨了指令集、指令集的分类，与汇编有关的硬件，总线都有哪些，分别的作用都是什么，然后我们以一次内存读取过程来连接一下 CPU 和内存的交互过程。</p><p>如果你在阅读文章的过程中发现错误和问题，请及时与我联系！</p><p>如果文章对你有帮助，希望小伙伴们三连走起！</p>',105),c=[d];function r(h,o){return a(),i("div",null,c)}const n=e(l,[["render",r],["__file","assembly01-basic.html.vue"]]);export{n as default};
