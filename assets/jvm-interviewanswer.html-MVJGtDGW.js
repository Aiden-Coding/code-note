import{_ as n,r as t,o as p,c as r,a as e,b as a,d as s,e as i}from"./app-3RcBQnkC.js";const o={},c=i(`<h1 id="jvm-面试题总结" tabindex="-1"><a class="header-anchor" href="#jvm-面试题总结" aria-hidden="true">#</a> JVM 面试题总结</h1><ul><li><a href="#jvm-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">JVM 面试题总结</a><ul><li><a href="#jvm-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">JVM 的主要作用是什么？</a></li><li><a href="#%E8%AF%B7%E4%BD%A0%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-java-%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">请你描述一下 Java 的内存区域？</a></li><li><a href="#%E8%AF%B7%E4%BD%A0%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-java-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">请你描述一下 Java 中的类加载机制？</a><ul><li><a href="#%E5%8A%A0%E8%BD%BD">加载</a></li><li><a href="#%E9%AA%8C%E8%AF%81">验证</a></li><li><a href="#%E5%87%86%E5%A4%87">准备</a></li><li><a href="#%E8%A7%A3%E6%9E%90">解析</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li><li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li><li><a href="#%E5%8D%B8%E8%BD%BD">卸载</a></li></ul></li><li><a href="#%E5%9C%A8-jvm-%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%9A%84">在 JVM 中，对象是如何创建的？</a></li><li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%A2">内存分配方式有哪些呢？</a></li><li><a href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">请你说一下对象的内存布局？</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4-header">对象头 Header</a></li><li><a href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE-instance-data">实例数据 Instance Data</a></li><li><a href="#%E5%AF%B9%E9%BD%90-padding">对齐 Padding</a></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">对象访问定位的方式有哪些？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%B7%B2%E7%BB%8F%E6%AD%BB%E4%BA%A1">如何判断对象已经死亡？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB">如何判断一个不再使用的类？</a></li><li><a href="#jvm-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA%E6%9C%89%E5%93%AA%E4%BA%9B">JVM 分代收集理论有哪些？</a></li><li><a href="#%E8%81%8A%E4%B8%80%E8%81%8A-jvm-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">聊一聊 JVM 中的垃圾回收算法？</a><ul><li><a href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">标记-清除算法</a></li><li><a href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">标记-复制算法</a></li><li><a href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95">标记-整理算法</a></li></ul></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%B0%E5%BF%86%E9%9B%86%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%A1%E8%A1%A8%E8%AE%B0%E5%BF%86%E9%9B%86%E5%92%8C%E5%8D%A1%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">什么是记忆集，什么是卡表？记忆集和卡表有什么关系？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%A1%E9%A1%B5">什么是卡页？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%99%E5%B1%8F%E9%9A%9C%E5%86%99%E5%B1%8F%E9%9A%9C%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">什么是写屏障？写屏障带来的问题？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%BC%9A%E9%80%A0%E6%88%90%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">什么是三色标记法？三色标记法会造成哪些问题？</a></li><li><a href="#%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E6%B3%A2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">请你介绍一波垃圾收集器</a><ul><li><a href="#serial-%E6%94%B6%E9%9B%86%E5%99%A8">Serial 收集器</a></li><li><a href="#parnew-%E6%94%B6%E9%9B%86%E5%99%A8">ParNew 收集器</a></li><li><a href="#parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8">Parallel Scavenge 收集器</a></li><li><a href="#serial-old-%E6%94%B6%E9%9B%86%E5%99%A8">Serial Old 收集器</a></li><li><a href="#parallel-old-%E6%94%B6%E9%9B%86%E5%99%A8">Parallel Old 收集器</a></li><li><a href="#cms-%E6%94%B6%E9%9B%86%E5%99%A8">CMS 收集器</a></li><li><a href="#garbage-first-%E6%94%B6%E9%9B%86%E5%99%A8">Garbage First 收集器</a></li></ul></li><li><a href="#jvm-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D">JVM 常用命令介绍</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">什么是双亲委派模型？</a></li><li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BC%BA%E9%99%B7">双亲委派模型的缺陷？</a></li><li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%89%E6%AC%A1%E7%A0%B4%E5%9D%8F">双亲委派机制的三次破坏</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84-jvm-%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B">常见的 JVM 调优参数有哪些？</a></li></ul></li></ul><p>肝了一篇非常硬核的 JVM 基础总结，写作不易，小伙伴们赶紧点赞、转发安排起来！</p><h2 id="jvm-的主要作用是什么" tabindex="-1"><a class="header-anchor" href="#jvm-的主要作用是什么" aria-hidden="true">#</a> JVM 的主要作用是什么？</h2><p>JVM 就是 Java Virtual Machine（Java虚拟机）的缩写，JVM 屏蔽了与具体操作系统平台相关的信息，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码 （字节码），就可以在不同的平台上运行。</p><h2 id="请你描述一下-java-的内存区域" tabindex="-1"><a class="header-anchor" href="#请你描述一下-java-的内存区域" aria-hidden="true">#</a> 请你描述一下 Java 的内存区域？</h2><p>JVM 在执行 Java 程序的过程中会把它管理的内存分为若干个不同的区域，这些组成部分有些是线程私有的，有些则是线程共享的，Java 内存区域也叫做运行时数据区，它的具体划分如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guasgnlwt1j60tt0m676m02.jpg" alt="image-20210909232300925"></p><ul><li><code>虚拟机栈</code> : Java 虚拟机栈是线程私有的数据区，Java 虚拟机栈的生命周期与线程相同，虚拟机栈也是局部变量的存储位置。方法在执行过程中，会在虚拟机栈中创建一个 <code>栈帧(stack frame)</code>。每个方法执行的过程就对应了一个入栈和出栈的过程。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtk2o0n8y5j608r0fkdgn02.jpg" alt="image-20210817204550728"></p><ul><li><p><code>本地方法栈</code>: 本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 <code>native</code> 关键字修饰的方法所存储的区域。</p></li><li><p><code>程序计数器</code>：程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成。</p></li><li><p><code>方法区</code>：方法区是各个线程共享的内存区域，它用于存储虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p><code>堆</code>：堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例都会分配在堆上。JDK 1.7后，字符串常量池从永久代中剥离出来，存放在堆中。</p><p>堆空间的内存分配（默认情况下）：</p><ul><li>老年代 ： 三分之二的堆空间</li><li>年轻代 ： 三分之一的堆空间 <ul><li>eden 区： 8/10 的年轻代空间</li><li>survivor 0 : 1/10 的年轻代空间</li><li>survivor 1 : 1/10 的年轻代空间</li></ul></li></ul><p>命令行上执行如下命令，会查看默认的 JVM 参数。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>java <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintFlagsFinal</span> <span class="token operator">-</span>version
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出的内容非常多，但是只有两行能够反映出上面的内存分配结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtjz8prpx9j617a016mx102.jpg" alt="image-20210817184720097"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtjz9arsfbj617u0143yf02.jpg" alt="image-20210817184754351"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtjz7w06w5j617806ymxq02.jpg" alt="image-20210817184629515"></p></li><li><p><code>运行时常量池</code>：运行时常量池又被称为 <code>Runtime Constant Pool</code>，这块区域是方法区的一部分，它的名字非常有意思，通常被称为 <code>非堆</code>。它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 intern 方法就是一个典型的例子。</p></li></ul><h2 id="请你描述一下-java-中的类加载机制" tabindex="-1"><a class="header-anchor" href="#请你描述一下-java-中的类加载机制" aria-hidden="true">#</a> 请你描述一下 Java 中的类加载机制？</h2><p>Java 虚拟机负责把描述类的数据从 Class 文件加载到系统内存中，并对类的数据进行<strong>校验、转换解析和初始化</strong>，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称之为 Java 的<code>类加载机制</code>。</p><p>一个类从被加载到虚拟机内存开始，到卸载出内存为止，一共会经历下面这些过程。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3deyd9xj60ln07omxk02.jpg" alt="image-20210823222909485"></p><p>类加载机制一共有五个步骤，分别是<strong>加载、链接、初始化、使用和卸载</strong>阶段，这五个阶段的顺序是确定的。</p><p>其中链接阶段会细分成三个阶段，分别是验证、准备、解析阶段，这三个阶段的顺序是不确定的，这三个阶段通常交互进行。解析阶段通常会在初始化之后再开始，这是为了支持 Java 语言的运行时绑定特性（也被称为<code>动态绑定</code>）。</p><p>下面我们就来聊一下这几个过程。</p><h3 id="加载" tabindex="-1"><a class="header-anchor" href="#加载" aria-hidden="true">#</a> 加载</h3><p>关于什么时候开始加载这个过程，《Java 虚拟机规范》并没有强制约束，所以这一点我们可以自由实现。加载是整个类加载过程的第一个阶段，在这个阶段，Java 虚拟机需要完成三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流表示的一种存储结构转换为运行时数据区中方法区的数据结构。</li><li>在内存中生成一个 Class 对象，这个对象就代表了这个数据结构的访问入口。</li></ul><p>《Java 虚拟机规范》并未规定全限定名是如何获取的，所以现在业界有很多获取全限定名的方式：</p><ul><li>从 ZIP 包中读取，最终会改变为 JAR、EAR、WAR 格式。</li><li>从网络中获取，最常见的应用就是 Web Applet。</li><li>运行时动态生成，使用最多的就是动态代理技术。</li><li>由其他文件生成，比如 JSP 应用场景，由 JSP 文件生成对应的 Class 文件。</li><li>从数据库中读取，这种场景就比较小了。</li><li>可以从加密文件中获取，这是典型的防止 Class 文件被反编译的保护措施。</li></ul><p>加载阶段既可以使用虚拟机内置的引导类加载器来完成，也可以使用用户自定义的类加载器来完成。程序员可以通过自己定义类加载器来控制字节流的访问方式。</p><p>数组的加载不需要通过类加载器来创建，它是直接在内存中分配，但是数组的元素类型（数组去掉所有维度的类型）最终还是要靠类加载器来完成加载。</p><h3 id="验证" tabindex="-1"><a class="header-anchor" href="#验证" aria-hidden="true">#</a> 验证</h3><p>加载过后的下一个阶段就是验证，因为我们上一步讲到在内存中生成了一个 Class 对象，这个对象是访问其代表数据结构的入口，所以这一步验证的工作就是确保 Class 文件的字节流中的内容符合《Java 虚拟机规范》中的要求，保证这些信息被当作代码运行后，它不会威胁到虚拟机的安全。</p><p>验证阶段主要分为四个阶段的检验：</p><ul><li>文件格式验证。</li><li>元数据验证。</li><li>字节码验证。</li><li>符号引用验证。</li></ul><p><strong>文件格式验证</strong></p><p>这一阶段可能会包含下面这些验证点：</p><ul><li>魔数是否以 <code>0xCAFEBABE</code> 开头。</li><li>主、次版本号是否在当前 Java 虚拟机接受范围之内。</li><li>常亮池的常量中是否有不支持的常量类型。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据。</li><li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li></ul><p>实际上验证点远远不止有这些，上面这些只是从 HotSpot 源码中摘抄的一小段内容。</p><p><strong>元数据验证</strong></p><p>这一阶段主要是对字节码描述的信息进行语义分析，以确保描述的信息符合《Java 语言规范》，验证点包括</p><ul><li>验证的类是否有父类（除了 Object 类之外，所有的类都应该有父类）。</li><li>要验证类的父类是否继承了不允许继承的类。</li><li>如果这个类不是抽象类，那么这个类是否实现了父类或者接口中要求的所有方法。</li><li>是否覆盖了 final 字段，是否出现了不符合规定的重载等。</li></ul><p>需要记住这一阶段只是对《Java 语言规范》的验证。</p><p><strong>字节码验证</strong></p><p>字节码验证阶段是最复杂的一个阶段，这个阶段主要是确定程序语意是否合法、是否是符合逻辑的。这个阶段主要是对类的方法体（Class 文件中的 Code 属性）进行校验分析。这部分验证包括</p><ul><li>确保操作数栈的数据类型和实际执行时的数据类型是否一致。</li><li>保证任何跳转指令不会跳出到方法体外的字节码指令上。</li><li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，但是不能把父类数据类型赋值给子类等诸如此不安全的类型转换。</li><li>其他验证。</li></ul><p>如果没有通过字节码验证，就说明验证出问题。但是不一定通过了字节码验证，就能保证程序是安全的。</p><p><strong>符号引用验证</strong></p><p>最后一个阶段的校验行为发生在虚拟机将符号引用转换为直接引用的时候，这个转化将在连接的第三个阶段，即解析阶段中发生。符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验，这个验证主要包括</p><ul><li>符号引用中的字符串全限定名是否能找到对应的类。</li><li>指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用的类、字段方法的可访问性是否可被当前类所访问。</li><li>其他验证。</li></ul><p>这一阶段主要是确保解析行为能否正常执行，如果无法通过符号引用验证，就会出现类似 <code>IllegalAccessError</code>、<code>NoSuchFieldError</code>、<code>NoSuchMethodError</code> 等错误。</p><p>验证阶段对于虚拟机来说非常重要，如果能通过验证，就说明你的程序在运行时不会产生任何影响。</p><h3 id="准备" tabindex="-1"><a class="header-anchor" href="#准备" aria-hidden="true">#</a> 准备</h3><p>准备阶段是为类中的变量分配内存并设置其初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，在 JDK 7 之前，HotSpot 使用永久代来实现方法区，是符合这种逻辑概念的。而在 JDK 8 之后，变量则会随着 Class 对象一起存放在 Java 堆中。</p><p>下面通常情况下的基本类型和引用类型的初始值</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3ekype5j60ml0azgly02.jpg" alt="image-20210823223020677"></p><p>除了&quot;通常情况&quot;下，还有一些&quot;例外情况&quot;，如果类字段属性中存在 <code>ConstantValue</code> 属性，那就这个变量值在初始阶段就会初始化为 ConstantValue 属性所指定的初始值，比如</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token string">&quot;666&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译时就会把 value 的值设置为 666。</p><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析" aria-hidden="true">#</a> 解析</h3><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li><code>符号引用</code>：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。</li><li><code>直接引用</code>：直接引用可以直接指向目标的指针、相对便宜量或者一个能间接定位到目标的句柄。直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。</li></ul><p>这样说你可能还有点不明白，我再换一种说法：</p><blockquote><p>在编译的时候一个每个 Java 类都会被编译成一个 class 文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。</p></blockquote><p>《Java 虚拟机规范》并未规定解析阶段发生的时间，只要求了在 anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 putstatic 这 17 个用于操作符号引用的字节码指令之前，先对所使用的符号引用进行解析。</p><p>解析也分为四个步骤</p><ul><li>类或接口的解析</li><li>字段解析</li><li>方法解析</li><li>接口方法解析</li></ul><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h3><p>初始化是类加载过程的最后一个步骤，在之前的阶段中，都是由 Java 虚拟机占主导作用，但是到了这一步，却把主动权移交给应用程序。</p><p>对于初始化阶段，《Java 虚拟机规范》严格规定了只有下面这六种情况下才会触发类的初始化。</p><ul><li>在遇到 new、getstatic、putstatic 或者 invokestatic 这四条字节码指令时，如果没有进行过初始化，那么首先触发初始化。通过这四个字节码的名称可以判断，这四条字节码其实就两个场景，调用 new 关键字的时候进行初始化、读取或者设置一个静态字段的时候、调用静态方法的时候。</li><li>在初始化类的时候，如果父类还没有初始化，那么就需要先对父类进行初始化。</li><li>在使用 java.lang.reflect 包的方法进行反射调用的时候。</li><li>当虚拟机启动时，用户需要指定执行主类的时候，说白了就是虚拟机会先初始化 main 方法这个类。</li><li>在使用 JDK 7 新加入的动态语言支持时，如果一个 jafva.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getstatic、REF_putstatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，需要先对其进行初始化。</li><li>当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个借口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ul><p>其实上面只有前四个大家需要知道就好了，后面两个比较冷门。</p><blockquote><p>如果说要答类加载的话，其实聊到这里已经可以了，但是为了完整性，我们索性把后面两个过程也来聊一聊。</p></blockquote><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><p>这个阶段没什么可说的，就是初始化之后的代码由 JVM 来动态调用执行。</p><h3 id="卸载" tabindex="-1"><a class="header-anchor" href="#卸载" aria-hidden="true">#</a> 卸载</h3><p>当代表一个类的 Class 对象不再被引用，那么 Class 对象的生命周期就结束了，对应的在方法区中的数据也会被卸载。</p><blockquote><p>⚠️但是需要注意一点：JVM 自带的类加载器装载的类，是不会卸载的，由用户自定义的类加载器加载的类是可以卸载的。</p></blockquote><h2 id="在-jvm-中-对象是如何创建的" tabindex="-1"><a class="header-anchor" href="#在-jvm-中-对象是如何创建的" aria-hidden="true">#</a> 在 JVM 中，对象是如何创建的？</h2><p>如果要回答对象是怎么创建的，我们一般想到的回答是直接 <code>new</code> 出来就行了，这个回答不仅局限于编程中，也融入在我们生活中的方方面面。</p><p>但是遇到面试的时候你只回答一个&quot;new 出来就行了&quot;显然是不行的，因为面试更趋向于让你解释当程序执行到 new 这条指令时，它的背后发生了什么。</p><p>所以你需要从 JVM 的角度来解释这件事情。</p><p>当虚拟机遇到一个 new 指令时（其实就是字节码），首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析和初始化。</p><blockquote><p>因为此时很可能不知道具体的类是什么，所以这里使用的是符号引用。</p></blockquote><p>如果发现这个类没有经过上面类加载的过程，那么就执行相应的类加载过程。</p><p>类检查完成后，接下来虚拟机将会为新生对象<strong>分配内存</strong>，对象所需的大小在类加载完成后便可确定（我会在下面的面试题中介绍）。</p><p>分配内存相当于是把一块固定的内存块从堆中划分出来。划分出来之后，虚拟机会将分配到的内存空间都初始化为零值，如果使用了 <code>TLAB</code>（本地线程分配缓冲），这一项初始化工作可以提前在 TLAB 分配时进行。这一步操作保证了对象实例字段在 Java 代码中可以不赋值就能直接使用。</p><p>接下来，Java 虚拟机还会对对象进行必要的设置，比如确定对象是哪个类的实例、对象的 hashcode、对象的 gc 分代年龄信息。这些信息存放在对象的对象头（Object Header）中。</p><p>如果上面的工作都做完后，从虚拟机的角度来说，一个新的对象就创建完毕了；但是对于程序员来说，对象创建才刚刚开始，因为构造函数，即 Class 文件中的 <code>&lt;init&gt;()</code> 方法还没有执行，所有字段都为默认的零值。new 指令之后才会执行 <code>&lt;init&gt;()</code> 方法，然后按照程序员的意愿对对象进行初始化，这样一个对象才可能被完整的构造出来。</p><h2 id="内存分配方式有哪些呢" tabindex="-1"><a class="header-anchor" href="#内存分配方式有哪些呢" aria-hidden="true">#</a> 内存分配方式有哪些呢？</h2><p>在类加载完成后，虚拟机需要为新生对象分配内存，为对象分配内存相当于是把一块确定的区域从堆中划分出来，这就涉及到一个问题，<strong>要划分的堆区是否规整</strong>。</p><p>假设 Java 堆中内存是规整的，所有使用过的内存放在一边，未使用的内存放在一边，中间放着一个指针，这个指针为分界指示器。那么为新对象分配内存空间就相当于是把指针向空闲的空间挪动对象大小相等的距离，这种内存分配方式叫做<code>指针碰撞(Bump The Pointer)</code>。</p><p>如果 Java 堆中的内存并不是规整的，已经被使用的内存和未被使用的内存相互交错在一起，这种情况下就没有办法使用指针碰撞，这里就要使用另外一种记录内存使用的方式：<code>空闲列表(Free List)</code>，空闲列表维护了一个列表，这个列表记录了哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p><p>所以，上述两种分配方式选择哪个，取决于 Java 堆是否规整来决定。在一些垃圾收集器的实现中，Serial、ParNew 等带压缩整理过程的收集器，使用的是指针碰撞；而使用 CMS 这种基于清除算法的收集器时，使用的是空闲列表，具体的垃圾收集器我们后面会聊到。</p><h2 id="请你说一下对象的内存布局" tabindex="-1"><a class="header-anchor" href="#请你说一下对象的内存布局" aria-hidden="true">#</a> 请你说一下对象的内存布局？</h2><p>在 <code>hotspot</code> 虚拟机中，对象在内存中的布局分为三块区域：</p><ul><li><code>对象头(Header)</code></li><li><code>实例数据(Instance Data)</code></li><li><code>对齐填充(Padding)</code></li></ul><p>这三块区域的内存分布如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3ev5370j60ik0abq3m02.jpg" alt="image-20210823223037637"></p><p>我们来详细介绍一下上面对象中的内容。</p><h3 id="对象头-header" tabindex="-1"><a class="header-anchor" href="#对象头-header" aria-hidden="true">#</a> 对象头 Header</h3><p>对象头 Header 主要包含 MarkWord 和对象指针 Klass Pointer，如果是数组的话，还要包含数组的长度。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3f0bex7j60me03n0sz02.jpg" alt="image-20210823223045677"></p><p>在 32 位的虚拟机中 MarkWord ，Klass Pointer 和数组长度分别占用 32 位，也就是 4 字节。</p><p>如果是 64 位虚拟机的话，MarkWord ，Klass Pointer 和数组长度分别占用 64 位，也就是 8 字节。</p><p>在 32 位虚拟机和 64 位虚拟机的 Mark Word 所占用的字节大小不一样，32 位虚拟机的 Mark Word 和 Klass Pointer 分别占用 32 bits 的字节，而 64 位虚拟机的 Mark Word 和 Klass Pointer 占用了64 bits 的字节，下面我们以 32 位虚拟机为例，来看一下其 Mark Word 的字节具体是如何分配的。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3jd4rcij60m40hl40j02.jpg" alt="image-20210823223455786"></p><p>用中文翻译过来就是</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3jrrzlaj60kn0c40u502.jpg" alt="image-20210823223519871"></p><ul><li>无状态也就是<code>无锁</code>的时候，对象头开辟 25 bit 的空间用来存储对象的 hashcode ，4 bit 用于存放分代年龄，1 bit 用来存放是否偏向锁的标识位，2 bit 用来存放锁标识位为 01。</li><li><code>偏向锁</code> 中划分更细，还是开辟 25 bit 的空间，其中 23 bit 用来存放线程ID，2bit 用来存放 epoch，4bit 存放分代年龄，1 bit 存放是否偏向锁标识， 0 表示无锁，1 表示偏向锁，锁的标识位还是 01。</li><li><code>轻量级锁</code>中直接开辟 30 bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为 00。</li><li><code>重量级锁</code>中和轻量级锁一样，30 bit 的空间用来存放指向重量级锁的指针，2 bit 存放锁的标识位，为 11</li><li><code>GC标记</code>开辟 30 bit 的内存空间却没有占用，2 bit 空间存放锁标志位为 11。</li></ul><p>其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1 bit 区分了这是无锁状态还是偏向锁状态。</p>`,105),d=e("code",null,"OpenJDK",-1),g={href:"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp",target:"_blank",rel:"noopener noreferrer"},h=i('<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3jz9elsj60lz062t9202.jpg" alt="image-20210823223531938"></p><p>来解释一下</p><ul><li>age_bits 就是我们说的分代回收的标识，占用4字节</li><li>lock_bits 是锁的标志位，占用2个字节</li><li>biased_lock_bits 是是否偏向锁的标识，占用1个字节。</li><li>max_hash_bits 是针对无锁计算的 hashcode 占用字节数量，如果是 32 位虚拟机，就是 32 - 4 - 2 -1 = 25 byte，如果是 64 位虚拟机，64 - 4 - 2 - 1 = 57 byte，但是会有 25 字节未使用，所以 64 位的 hashcode 占用 31 byte。</li><li>hash_bits 是针对 64 位虚拟机来说，如果最大字节数大于 31，则取 31，否则取真实的字节数</li><li>cms_bits 我觉得应该是不是 64 位虚拟机就占用 0 byte，是 64 位就占用 1byte</li><li>epoch_bits 就是 epoch 所占用的字节大小，2 字节。</li></ul><p>在上面的虚拟机对象头分配表中，我们可以看到有几种锁的状态：无锁（无状态），偏向锁，轻量级锁，重量级锁，其中轻量级锁和偏向锁是 JDK1.6 中对 synchronized 锁进行优化后新增加的，其目的就是为了大大优化锁的性能，所以在 JDK 1.6 中，使用 synchronized 的开销也没那么大了。其实从锁有无锁定来讲，还是只有无锁和重量级锁，偏向锁和轻量级锁的出现就是增加了锁的获取性能而已，并没有出现新的锁。</p><p>所以我们的重点放在对 synchronized 重量级锁的研究上，当 monitor 被某个线程持有后，它就会处于锁定状态。在 HotSpot 虚拟机中，monitor 的底层代码是由 <code>ObjectMonitor</code> 实现的，其主要数据结构如下（位于 HotSpot 虚拟机源码 ObjectMonitor.hpp 文件，C++ 实现的）</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3k94ae6j60g40ar74w02.jpg" alt="image-20210823223547587"></p><p>这段 C++ 中需要注意几个属性：_WaitSet 、 _EntryList 和 _Owner，每个等待获取锁的线程都会被封装称为 <code>ObjectWaiter</code> 对象。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3kfk0qhj60lc039jrj02.jpg" alt="image-20210823223558339"></p><p>_Owner 是指向了 ObjectMonitor 对象的线程，而 _WaitSet 和 _EntryList 就是用来保存每个线程的列表。</p><blockquote><p>那么这两个列表有什么区别呢？这个问题我和你聊一下锁的获取流程你就清楚了。</p></blockquote><p><strong>锁的两个列表</strong></p><p>当多个线程同时访问某段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的 monitor 之后，就会进入 _Owner 区域，并把 ObjectMonitor 对象的 _Owner 指向为当前线程，并使 _count + 1，如果调用了释放锁（比如 wait）的操作，就会释放当前持有的 monitor ，owner = null， _count - 1，同时这个线程会进入到 _WaitSet 列表中等待被唤醒。如果当前线程执行完毕后也会释放 monitor 锁，只不过此时不会进入 _WaitSet 列表了，而是直接复位 _count 的值。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3kk6i5fj60k30afwf202.jpg" alt="image-20210823223605628"></p><p>Klass Pointer 表示的是类型指针，也就是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><blockquote><p>你可能不是很理解指针是个什么概念，你可以简单理解为指针就是指向某个数据的地址。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtr3kqtluwj60dg039mx602.jpg" alt="image-20210823223616085"></p><h3 id="实例数据-instance-data" tabindex="-1"><a class="header-anchor" href="#实例数据-instance-data" aria-hidden="true">#</a> 实例数据 Instance Data</h3><p>实例数据部分是对象真正存储的有效信息，也是代码中定义的各个字段的字节大小，比如一个 byte 占 1 个字节，一个 int 占用 4 个字节。</p><h3 id="对齐-padding" tabindex="-1"><a class="header-anchor" href="#对齐-padding" aria-hidden="true">#</a> 对齐 Padding</h3><p>对齐不是必须存在的，它只起到了**占位符(%d, %c 等)**的作用。这就是 JVM 的要求了，因为 HotSpot JVM 要求对象的起始地址必须是 8 字节的整数倍，也就是说对象的字节大小是 8 的整数倍，不够的需要使用 Padding 补全。</p><h2 id="对象访问定位的方式有哪些" tabindex="-1"><a class="header-anchor" href="#对象访问定位的方式有哪些" aria-hidden="true">#</a> 对象访问定位的方式有哪些？</h2><p>我们创建一个对象的目的当然就是为了使用它，但是，一个对象被创建出来之后，在 JVM 中是如何访问这个对象的呢？一般有两种方式：<strong>通过句柄访问</strong>和 <strong>通过直接指针访问</strong>。</p><ul><li><p>如果使用句柄访问方式的话，Java 堆中可能会划分出一块内存作为句柄池，引用（reference）中存储的是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自具体的地址信息。如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtosvrqsq0j30jz0bst9f.jpg" alt="image-20210821225508905"></p></li><li><p>如果使用直接指针访问的话，Java 堆中对象的内存布局就会有所区别，栈区引用指示的是堆中的实例数据的地址，如果只是访问对象本身的话，就不会多一次直接访问的开销，而对象类型数据的指针是存在于方法区中，如果定位的话，需要多一次直接定位开销。如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtosxslmk7j60jz0bgt9a02.jpg" alt="image-20210821225705281"></p></li></ul><p>这两种对象访问方式各有各的优势，使用句柄最大的好处就是引用中存储的是句柄地址，对象移动时只需改变句柄的地址就可以，而无需改变对象本身。</p><p>使用直接指针来访问速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因为这类的开销也是值得优化的地方。</p><p>上面聊到了对象的两种数据，一种是对象的实例数据，这没什么好说的，就是对象实例字段的数据，一种是对象的类型数据，这个数据说的是对象的类型、父类、实现的接口和方法等。</p><h2 id="如何判断对象已经死亡" tabindex="-1"><a class="header-anchor" href="#如何判断对象已经死亡" aria-hidden="true">#</a> 如何判断对象已经死亡？</h2><p>我们大家知道，基本上所有的对象都在堆中分布，当我们不再使用对象的时候，垃圾收集器会对无用对象进行回收♻️，那么 JVM 是如何判断哪些对象已经是&quot;无用对象&quot;的呢？</p><p>这里有两种判断方式，首先我们先来说第一种：<strong>引用计数法</strong>。</p><p>引用计数法的判断标准是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就会加一；当引用失效时，计数器的值就会减一；只要任何时刻计数器为零的对象就是不会再被使用的对象。虽然这种判断方式非常简单粗暴，但是往往很有用，不过，在 Java 领域，主流的 Hotspot 虚拟机实现并没有采用这种方式，因为引用计数法不能解决对象之间的循环引用问题。</p><p>循环引用问题简单来讲就是两个对象之间互相依赖着对方，除此之外，再无其他引用，这样虚拟机无法判断引用是否为零从而进行垃圾回收操作。</p><p>还有一种判断对象无用的方法就是<strong>可达性分析算法</strong>。</p><p>当前主流的 JVM 都采用了可达性分析算法来进行判断，这个算法的基本思路就是通过一系列被称为<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径被称为<code>引用链</code>（Reference Chain），如果某个对象到 GC Roots 之间没有任何引用链相连接，或者说从 GC Roots 到这个对象不可达时，则证明此这个对象是无用对象，需要被垃圾回收。</p><p>这种引用方式如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtpyny0sztj60ji0d80tl02.jpg" alt="image-20210822230043691"></p><p>如上图所示，从枚举根节点 GC Roots 开始进行遍历，object 1 、2、3、4 是存在引用关系的对象，而 object 5、6、7 之间虽然有关联，但是它们到 GC Roots 之间是不可大的，所以被认为是可以回收的对象。</p><p>在 Java 技术体系中，可以作为 GC Roots 进行检索的对象主要有</p><ul><li><p>在虚拟机栈（栈帧中的本地变量表）中引用的对象。</p></li><li><p>方法区中类静态属性引用的对象，比如 Java 类的引用类型静态变量。</p></li><li><p>方法区中常量引用的对象，比如字符串常量池中的引用。</p></li><li><p>在本地方法栈中 JNI 引用的对象。</p></li><li><p>JVM 内部的引用，比如基本数据类型对应的 Class 对象，一些异常对象比如 NullPointerException、OutOfMemoryError 等，还有系统类加载器。</p></li><li><p>所有被 synchronized 持有的对象。</p></li><li><p>还有一些 JVM 内部的比如 JMXBean、JVMTI 中注册的回调，本地代码缓存等。</p></li><li><p>根据用户所选的垃圾收集器以及当前回收的内存区域的不同，还可能会有一些对象临时加入，共同构成 GC Roots 集合。</p></li></ul><p>虽然我们上面提到了两种判断对象回收的方法，但无论是引用计数法还是判断 GC Roots 都离不开<code>引用</code>这一层关系。</p><p>这里涉及到到强引用、软引用、弱引用、虚引用的引用关系，你可以阅读作者的这一篇文章</p>',40),E={href:"https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&mid=2247495968&idx=1&sn=48de091f4fabdf682a9f8b5ddd8db936&chksm=c04ae67ef73d6f68935382dcaa0bd4d538a9e0b45ee49500ee7e2356cc24dba750b197960477&token=1191632986&lang=zh_CN#rd",target:"_blank",rel:"noopener noreferrer"},u=i(`<h2 id="如何判断一个不再使用的类" tabindex="-1"><a class="header-anchor" href="#如何判断一个不再使用的类" aria-hidden="true">#</a> 如何判断一个不再使用的类？</h2><p>判断一个类型属于&quot;不再使用的类&quot;需要满足下面这三个条件</p><ul><li>这个类所有的实例已经被回收，也就是 Java 堆中不存在该类及其任何这个类字累的实例</li><li>加载这个类的类加载器已经被回收，但是类加载器一般很难会被回收，除非这个类加载器是为了这个目的设计的，比如 OSGI、JSP 的重加载等，否则通常很难达成。</li><li>这个类对应的 Class 对象没有任何地方被引用，无法在任何时刻通过反射访问这个类的属性和方法。</li></ul><p>虚拟机允许对满足上面这三个条件的无用类进行回收操作。</p><h2 id="jvm-分代收集理论有哪些" tabindex="-1"><a class="header-anchor" href="#jvm-分代收集理论有哪些" aria-hidden="true">#</a> JVM 分代收集理论有哪些？</h2><p>一般商业的虚拟机，大多数都遵循了<strong>分代收集</strong>的设计思想，分代收集理论主要有两条假说。</p><p>第一个是<strong>强分代假说</strong>，强分代假说指的是 JVM 认为绝大多数对象的生存周期都是朝生夕灭的；</p><p>第二个是<strong>弱分代假说</strong>，弱分代假说指的是只要熬过越多次垃圾收集过程的对象就越难以回收（看来对象也会长心眼）。</p><p>就是基于这两个假说理论，JVM 将<code>堆</code>区划分为不同的区域，再将需要回收的对象根据其熬过垃圾回收的次数分配到不同的区域中存储。</p><p>JVM 根据这两条分代收集理论，把堆区划分为**新生代(Young Generation)<strong>和</strong>老年代(Old Generation)**这两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，剩下没有死去的对象会直接晋升到老年代中。</p><p>上面这两个假说没有考虑对象的引用关系，而事实情况是，对象之间会存在引用关系，基于此又诞生了第三个假说，即<strong>跨代引用假说(Intergeneration Reference Hypothesis)</strong>，跨代引用相比较同代引用来说仅占少数。</p><p>正常来说存在相互引用的两个对象应该是同生共死的，不过也会存在特例，如果一个新生代对象跨代引用了一个老年代的对象，那么垃圾回收的时候就不会回收这个新生代对象，更不会回收老年代对象，然后这个新生代对象熬过一次垃圾回收进入到老年代中，这时候跨代引用才会消除。</p><p>根据跨代引用假说，我们不需要因为老年代中存在少量跨代引用就去直接扫描整个老年代，也不用在老年代中维护一个列表记录有哪些跨代引用，实际上，可以直接在新生代中维护一个<strong>记忆集(Remembered Set)</strong>，由这个记忆集把老年代划分称为若干小块，标识出老年代的哪一块会存在跨代引用。</p><p>记忆集的图示如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu3tdyghmqj60l407wdfz02.jpg" alt="image-20210903223603191"></p><p>从图中我们可以看到，记忆集中的每个元素分别对应内存中的一块连续区域是否有跨代引用对象，如果有，该区域会被标记为“脏的”（dirty），否则就是“干净的”（clean）。这样在垃圾回收时，只需要扫描记忆集就可以简单地确定跨代引用的位置，是个典型的空间换时间的思路。</p><h2 id="聊一聊-jvm-中的垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#聊一聊-jvm-中的垃圾回收算法" aria-hidden="true">#</a> 聊一聊 JVM 中的垃圾回收算法？</h2><p>在聊具体的垃圾回收算法之前，需要明确一点，哪些对象需要被垃圾收集器进行回收？也就是说需要先判断哪些对象是&quot;垃圾&quot;？</p><p>判断的标准我在上面<strong>如何判断对象已经死亡</strong>的问题中描述了，有两种方式，一种是引用计数法，这种判断标准就是给对象添加一个引用计数器，引用这个对象会使计数器的值 + 1，引用失效后，计数器的值就会 -1。但是这种技术无法解决对象之间的循环引用问题。</p><p>还有一种方式是 GC Roots，GC Roots 这种方式是以 Root 根节点为核心，逐步向下搜索每个对象的引用，搜索走过的路径被称为引用链，如果搜索过后这个对象不存在引用链，那么这个对象就是无用对象，可以被回收。GC Roots 可以解决循环引用问题，所以一般 JVM 都采用的是这种方式。</p><p>解决循环引用代码描述：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> test<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
        b<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于 GC Roots 的这种思想，发展出了很多垃圾回收算法，下面我们就来聊一聊这些算法。</p><h3 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法" aria-hidden="true">#</a> 标记-清除算法</h3><p>**标记-清除(Mark-Sweep)**这个算法可以说是最早最基础的算法了，标记-清除顾名思义分为两个阶段，即标记和清除阶段：首先标记处所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。当然也可以标记存活的对象，回收未被标记的对象。这个标记的过程就是垃圾判定的过程。</p><p>后续大部分垃圾回收算法都是基于标记-算法思想衍生的，只不过后续的算法弥补了标记-清除算法的缺点，那么它由什么缺点呢？主要有两个</p><ul><li><strong>执行效率不稳定</strong>，因为假如说堆中存在大量无用对象，而且大部分需要回收的情况下，这时必须进行大量的标记和清除，导致标记和清除这两个过程的执行效率随对象的数量增长而降低。</li><li><strong>内存碎片化</strong>，标记-清除算法会在堆区产生大量不连续的内存碎片。碎片太多会导致在分配大对象时没有足够的空间，不得不进行一次垃圾回收操作。</li></ul><p>标记算法的示意图如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu4rqyosksj60je0cp3yz02.jpg" alt="image-20210904182457721"></p><h3 id="标记-复制算法" tabindex="-1"><a class="header-anchor" href="#标记-复制算法" aria-hidden="true">#</a> 标记-复制算法</h3><p>由于标记-清除算法极易产生内存碎片，研究人员提出了标记-复制算法，标记-复制算法也可以简称为复制算法，复制算法是一种<strong>半区复制</strong>，它会将内存大小划分为相等的两块，每次只使用其中的一块，用完一块再用另外一块，然后再把用过的一块进行清除。虽然解决了部分内存碎片的问题，但是复制算法也带来了新的问题，即<strong>复制开销</strong>，不过这种开销是可以降低的，如果内存中大多数对象是无用对象，那么就可以把少数的存活对象进行复制，再回收无用的对象。</p><p>不过复制算法的缺陷也是显而易见的，那就是内存空间缩小为原来的一半，空间浪费太明显。标记-复制算法示意图如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu4rqrk1bzj60kx0cj3z102.jpg" alt="image-20210904182444311"></p><p>现在 Java 虚拟机大多数都是用了这种算法来回收新生代，因为经过研究表明，新生代对象由 98% 都熬不过第一轮收集，因此不需要按照 1 ： 1 的比例来划分新生代的内存空间。</p><p>基于此，研究人员提出了一种 Appel 式回收，Appel 式回收的具体做法是把新生代分为一块较大的 <em>Eden</em> 空间和两块 <em>Survivor</em> 空间，每次分配内存都只使用 Eden 和其中的一块 Survivor 空间，发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已使用过的 Survivor 空间。</p><p>在主流的 HotSpot 虚拟机中，默认的 Eden 和 Survivor 大小比例是 8：1，也就是每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间，所以会浪费掉 10% 的空间。这个 8：1 只是一个理论值，也就是说，不能保证每次都有不超过 10% 的对象存活，所以，当进行垃圾回收后如果 Survivor 容纳不了可存活的对象后，就需要其他内存空间来进行<strong>帮助</strong>，这种方式就叫做<strong>内存担保(Handle Promotion)</strong> ，通常情况下，作为担保的是老年代。</p><h3 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法" aria-hidden="true">#</a> 标记-整理算法</h3><p>标记-复制算法虽然解决了内存碎片问题，但是没有解决复制对象存在大量开销的问题。为了解决复制算法的缺陷，充分利用内存空间，提出了标记-整理算法。该算法标记阶段和标记-清除一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu50b154tgj30jg0cr0t5.jpg" alt="image-20210904232102284"></p><h2 id="什么是记忆集-什么是卡表-记忆集和卡表有什么关系" tabindex="-1"><a class="header-anchor" href="#什么是记忆集-什么是卡表-记忆集和卡表有什么关系" aria-hidden="true">#</a> 什么是记忆集，什么是卡表？记忆集和卡表有什么关系？</h2><p>为了解决跨代引用问题，提出了记忆集这个概念，记忆集是一个在新生代中使用的数据结构，它相当于是记录了一些指针的集合，指向了老年代中哪些对象存在跨代引用。</p><p>记忆集的实现有不同的粒度</p><ul><li><strong>字长精度</strong>：每个记录精确到一个字长，机器字长就是处理器的寻址位数，比如常见的 32 位或者 64 位处理器，这个精度决定了机器访问物理内存地址的指针长度，字中包含跨代指针。</li><li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里含有跨代指针。</li><li><strong>卡精度</strong>：每个记录精确到一块内存区域，区域内含有跨代指针。</li></ul><p>其中卡精度是使用了卡表作为记忆集的实现，关于记忆集和卡表的关系，大家可以想象成是 HashMap 和 Map 的关系。</p><h2 id="什么是卡页" tabindex="-1"><a class="header-anchor" href="#什么是卡页" aria-hidden="true">#</a> 什么是卡页？</h2><p>卡表其实就是一个字节数组</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token constant">CARD_TABLE</span><span class="token punctuation">[</span><span class="token keyword">this</span> address <span class="token operator">&gt;&gt;</span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>字节数组 CARD_TABLE 的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块就是<strong>卡页</strong>，一般来说，卡页都是 2 的 N 次幂字节数，通过上面的代码我们可以知道，卡页一般是 2 的 9 次幂，这也是 HotSpot 中使用的卡页，即 512 字节。</p><p>一个卡页的内存通常包含不止一个对象，只要卡页中有一个对象的字段存在跨代指针，那就将对应卡表的数组元素的值设置为 1，称之为这个元素变<code>脏</code>了，没有标示则为 0 。在垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，然后把他们加入 GC Roots 进行扫描。</p><p>所以，卡页和卡表主要用来解决跨代引用问题的。</p><h2 id="什么是写屏障-写屏障带来的问题" tabindex="-1"><a class="header-anchor" href="#什么是写屏障-写屏障带来的问题" aria-hidden="true">#</a> 什么是写屏障？写屏障带来的问题？</h2><p>如果有其他分代区域中对象引用了本区域的对象，那么其对应的卡表元素就会变脏，这个引用说的就是对象赋值，也就是说卡表元素会变脏发生在对象赋值的时候，那么如何在对象赋值的时候更新维护卡表呢？</p><p>在 HotSpot 虚拟机中使用的是<strong>写屏障(Write Barrier)</strong> 来维护卡表状态的，这个写屏障和我们内存屏障完全不同，希望读者不要搞混了。</p><p>这个写屏障其实就是一个 Aop 切面，在引用对象进行赋值时会产生一个<strong>环形通知(Around)</strong>，环形通知就是切面前后分别产生一个通知，因为这个又是写屏障，所以在赋值前的部分写屏障叫做写前屏障，在赋值后的则叫做写后屏障。</p><p>写屏障会带来两个问题</p><p><strong>无条件写屏障带来的性能开销</strong></p><p>每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，扫描整个老年代相比较，这个开销就低得多了。</p><p>不过，在高并发环境下，写屏障又带来了伪共享（false sharing）问题。</p><p><strong>高并发下伪共享带来的性能开销</strong></p><p>在高并发情况下，频繁的写屏障很容易发生伪共享（false sharing），从而带来性能开销。</p><p>假设 CPU 缓存行大小为 64 字节，由于一个卡表项占 1 个字节，这意味着，64 个卡表项将共享同一个缓存行。</p><p>HotSpot 每个卡页为 512 字节，那么一个缓存行将对应 64 个卡页一共 64*512 = 32K B。</p><p>如果不同线程对对象引用的更新操作，恰好位于同一个 32 KB 区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。</p><p>一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为脏的。</p><p>这就是 JDK 7 中引入的解决方法，引入了一个新的 JVM 参数 <em>-XX:+UseCondCardMark</em>，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。</p><p>简单理解如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>CARD_TABLE <span class="token punctuation">[</span>this address <span class="token operator">&gt;&gt;</span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
  CARD_TABLE <span class="token punctuation">[</span>this address <span class="token operator">&gt;&gt;</span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>与原来的实现相比，只是简单的增加了一个判断操作。</p><p>虽然开启 <em>-XX:+UseCondCardMark</em> 之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现伪共享问题（false sharing）。</p><h2 id="什么是三色标记法-三色标记法会造成哪些问题" tabindex="-1"><a class="header-anchor" href="#什么是三色标记法-三色标记法会造成哪些问题" aria-hidden="true">#</a> 什么是三色标记法？三色标记法会造成哪些问题？</h2><p>根据可达性算法的分析可知，如果要找出存活对象，需要从 GC Roots 开始遍历，然后搜索每个对象是否可达，如果对象可达则为存活对象，在 GC Roots 的搜索过程中，按照<strong>对象和其引用是否被访问过</strong>这个条件会分成下面三种颜色：</p><ul><li>白色：白色表示 GC Roots 的遍历过程中没有被访问过的对象，出现白色显然在可达性分析刚刚开始的阶段，这个时候所有对象都是白色的，如果在分析结束的阶段，仍然是白色的对象，那么代表不可达，可以进行回收。</li><li>灰色：灰色表示对象已经被访问过，但是这个对象的引用还没有访问完毕。</li><li>黑色：黑色表示此对象已经被访问过了，而且这个对象的引用也已经呗访问了。</li></ul><blockquote><p>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</p></blockquote><p>现代的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。</p><p>三色标记法会造成两种问题，这两种问题所出现的环境都是由于<strong>用户环境和收集器并行工作造成的</strong> 。当用户线程正在修改引用关系，此时收集器在回收引用关系，此时就会造成把原本已经消亡的对象标记为存活，如果出现这种状况的话，问题不大，下次再让收集器重新收集一波就完了，但是还有一种情况是把存活的对象标记为死亡，这种状况就会造成不可预知的后果。</p><p>针对上面这两种对象消失问题，业界有两种处理方式，一种是<strong>增量更新(Incremental Update)</strong> ，一种是<strong>原是快照(Snapshot At The Beginning, SATB)</strong>。</p><h2 id="请你介绍一波垃圾收集器" tabindex="-1"><a class="header-anchor" href="#请你介绍一波垃圾收集器" aria-hidden="true">#</a> 请你介绍一波垃圾收集器</h2><p>垃圾收集器是面试的常考，也是必考点，只要涉及到 JVM 的相关问题，都会围绕着垃圾收集器来做一波展开，所以，有必要了解一下这些垃圾收集器。</p><p>垃圾收集器有很多，不同商家、不同版本的J VM 所提供的垃圾收集器可能会有很在差别，我们主要介绍 HotSpot 虚拟机中的垃圾收集器。</p><p>垃圾收集器是垃圾回收算法的具体实现，我们上面提到过，垃圾回收算法有标记-清除算法、标记-整理、标记-复制，所以对应的垃圾收集器也有不同的实现方式。</p><p>我们知道，HotSpot 虚拟机中的垃圾收集都是分代回收的，所以根据不同的分代，可以把垃圾收集器分为</p><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p><p>老年代收集器：Serial Old、Parallel Old、CMS；</p><p>整堆收集器：G1；</p><h3 id="serial-收集器" tabindex="-1"><a class="header-anchor" href="#serial-收集器" aria-hidden="true">#</a> Serial 收集器</h3><p>Serial 收集器是一种新生代的垃圾收集器，它是一个单线程工作的收集器，使用复制算法来进行回收，单线程工作不是说这个垃圾收集器只有一个，而是说这个收集器在工作时，必须暂停其他所有工作线程，这种暴力的暂停方式就是 <strong>Stop The World</strong>，Serial 就好像是寡头垄断一样，只要它一发话，其他所有的小弟（线程）都得给它让路。Serial 收集器的示意图如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guomqgfvepj60fy08bq3702.jpg" alt="image-20210921224244386"></p><blockquote><p>SefePoint 全局安全点：它就是代码中的一段特殊的位置，在所有用户线程到达 SafePoint 之后，用户线程挂起，GC 线程会进行清理工作。</p></blockquote><p>虽然 Serial 有 STW 这种显而易见的缺点，不过，从其他角度来看，Serial 还是很讨喜的，它还有着优于其他收集器的地方，那就是简单而高效，对于内存资源首先的环境，它是所有收集器中额外内存消耗最小的，对于单核处理器或者处理器核心较少的环境来说，Serial 收集器由于没有线程交互开销，所以 Serial 专心做垃圾回收效率比较高。</p><h3 id="parnew-收集器" tabindex="-1"><a class="header-anchor" href="#parnew-收集器" aria-hidden="true">#</a> ParNew 收集器</h3><p>ParNew 是 Serial 的多线程版本，除了同时使用多条线程外，其他参数和机制（STW、回收策略、对象分配规则）都和 Serial 完全一致，ParNew 收集器的示意图如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guoohch3y6j60g809qt9202.jpg" alt="image-20210921234313336"></p><p>虽然 ParNew 使用了多条线程进行垃圾回收，但是在单线程环境下它绝对不会比 Serial 收集效率更高，因为多线程存在线程交互的开销，但是随着可用 CPU 核数的增加，ParNew 的处理效率会比 Serial 更高效。</p><h3 id="parallel-scavenge-收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge-收集器" aria-hidden="true">#</a> Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的，而且它也能够并行收集，这么看来，表面上 Parallel Scavenge 于 ParNew 非常相似，那么它们之间有什么区别呢？</p><p>Parallel Scavenge 的关注点主要在<strong>达到一个可控制的吞吐量上面</strong>。吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比。也就是</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gupp4zy1dcj60ih03bjrl02.jpg" alt="image-20210922205128446"></p><p>这里给大家举一个吞吐量的例子，如果执行用户代码的时间 + 运行垃圾收集的时间总共耗费了 100 分钟，其中垃圾收集耗费掉了 1 分钟，那么吞吐量就是 99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量，良好的响应速度可以提升用户体验，而高吞吐量可以最高效率利用处理器资源。</p><h3 id="serial-old-收集器" tabindex="-1"><a class="header-anchor" href="#serial-old-收集器" aria-hidden="true">#</a> Serial Old 收集器</h3><p>前面介绍了一下 Serial，我们知道它是一个新生代的垃圾收集，使用了标记-复制算法。而这个 Serial Old 收集器却是 Serial 的老年版本，它同样也是一个单线程收集器，使用的是<strong>标记-整理</strong>算法，Serial Old 收集器有两种用途：一种是在 JDK 5 和之前的版本与 Parallel Scavenge 收集器搭配使用，另外一种用法就是作为 <code>CMS</code> 收集器的备选，CMS 垃圾收集器我们下面说，Serial Old 的收集流程如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gupq6hqk31j30n009sgml.jpg" alt="image-20210922212732454"></p><h3 id="parallel-old-收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old-收集器" aria-hidden="true">#</a> Parallel Old 收集器</h3><p>前面我们介绍了 Parallel Scavenge 收集器，现在来介绍一下 Parallel Old 收集器，它是 Parallel Scavenge 的老年版本，支持多线程并发收集，基于标记 - 整理算法实现，JDK 6 之后出现，吞吐量优先可以考虑 Parallel Scavenge + Parallel Old 的搭配</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gupqbi1vyqj60mk09qgmn02.jpg" alt="image-20210922213221449"></p><h3 id="cms-收集器" tabindex="-1"><a class="header-anchor" href="#cms-收集器" aria-hidden="true">#</a> CMS 收集器</h3><p><code>CMS</code>收集器的主要目标是获取最短的回收停顿时间，它的全称是 <em>Concurrent Mark Sweep</em>，从这个名字就可以知道，这个收集器是基于标记 - 清除算法实现的，而且支持并发收集，它的运行过程要比上面我们提到的收集器复杂一些，它的工作流程如下：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>对于上面这四个步骤，初始标记和并发标记都需要 <em>Stop The World</em>，初始标记只是标记一下和 GC Roots 直接关联到的对象，速度较快；并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程。这个过程时间比较长但是不需要停顿用户线程，也就是说与垃圾收集线程一起并发运行。并发标记的过程中，可能会有错标或者漏标的情况，此时就需要在重新标记一下，最后是并发清除阶段，清理掉标记阶段中判断已经死亡的对象。</p><p>CMS 的收集过程如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gups75urlgj60o108oq3z02.jpg" alt="image-20210922223723196"></p><p>CMS 是一款非常优秀的垃圾收集器，但是没有任何收集器能够做到完美的程度，CMS 也是一样，CMS 至少有三个缺点：</p><ul><li><p>CMS 对处理器资源非常敏感，在并发阶段，虽然不会造成用户线程停顿，但是却会因为占用一部分线程而导致应用程序变慢，降低总吞吐量。</p></li><li><p>CMS 无法处理<strong>浮动垃圾</strong>，有可能出现<em>Concurrent Mode Failure</em>失败进而导致另一次完全 <em>Stop The World</em>的 <em>Full GC</em> 产生。</p><blockquote><p>什么是浮动垃圾呢？由于并发标记和并发清理阶段，用户线程仍在继续运行，所以程序自然而然就会伴随着新的垃圾不断出现，而且这一部分垃圾出现在标记结束之后，CMS 无法处理这些垃圾，所以只能等到下一次垃圾回收时在进行清理。这一部分垃圾就被称为浮动垃圾。</p></blockquote></li><li><p>CMS 最后一个缺点是并发-清除的通病，也就是会有大量的空间碎片出现，这将会给分配大对象带来困难。</p></li></ul><h3 id="garbage-first-收集器" tabindex="-1"><a class="header-anchor" href="#garbage-first-收集器" aria-hidden="true">#</a> Garbage First 收集器</h3><p>Garbage First 又被称为 <em>G1 收集器</em>，它的出现意味着垃圾收集器走过了一个里程碑，为什么说它是里程碑呢？因为 G1 这个收集器是一种面向局部的垃圾收集器，HotSpot 团队开发这个垃圾收集器为了让它替换掉 CMS 收集器，所以到后来，JDK 9 发布后，G1 取代了 Parallel Scavenge + Parallel Old 组合，成为服务端默认的垃圾收集器，而 CMS 则不再推荐使用。</p><p>之前的垃圾收集器存在回收区域的局限性，因为之前这些垃圾收集器的目标范围要么是整个新生代、要么是整个老年代，要么是整个 Java 堆（Full GC），而 G1 跳出了这个框架，它可以面向堆内存的任何部分来组成<strong>回收集(Collection Set，CSet)</strong>，衡量垃圾收集的不再是哪个分代，这就是 G1 的 <em>Mixed GC</em> 模式。</p><p>G1 是基于 Region 来进行回收的，Region 就是堆内存中任意的布局，每一块 Region 都可以根据需要扮演 Eden 空间、Survivor 空间或者老年代空间，收集器能够对不同的 Region 角色采用不同的策略来进行处理。Region 中还有一块特殊的区域，这块区域就是 <em>Humongous</em> 区域，它是专门用来存储大对象的，G1 认为只要大小超过了 Region 容量一半的对象即可判定为大对象。如果超过了 Region 容量的大对象，将会存储在连续的 Humongous Region 中，G1 大多数行为都会吧 Humongous Region 作为老年代来看待。</p><p>G1 保留了新生代（Eden Suvivor）和老年代的概念，但是新生代和老年代不再是固定的了。它们都是一系列区域的动态集合。</p><p>G1 收集器的运作过程可以分为以下四步：</p><ul><li>初始标记：这个步骤也仅仅是标记一下 GC Roots 能够直接关联到的对象；并修改 TAMS 指针的值（每一个 Region 都有两个 RAMS 指针），似的下一阶段用户并发运行时，能够在可用的 Region 中分配对象，这个阶段需要暂停用户线程，但是时间很短。这个停顿是借用 Minor GC 的时候完成的，所以可以忽略不计。</li><li>并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象。当对象图扫描完成后，重新处理 SATB 记录下的在并发时有引用的对象；</li><li>最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段结束后遗留下来的少量 <em>SATB</em> 记录（一种原始快照，用来记录并发标记中某些对象）</li><li>筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择多个 Region 构成回收集，然后把决定要回收的那一部分 Region 存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作设计对象的移动，所以必须要暂停用户线程，由多条收集器线程并行收集</li></ul><p>从上面这几个步骤可以看出，除了并发标记外，其余三个阶段都需要暂停用户线程，所以，这个 G1 收集器并非追求<strong>低延迟</strong>，官方给出的设计目标是<strong>在延迟可控的情况下尽可能的提高吞吐量</strong>，担任全功能收集器的重任。</p><p>下面是 G1 回收的示意图</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guqx6fa79ij60o009075e02.jpg" alt="image-20210923221512041"></p><p>G1 收集器同样也有缺点和问题：</p><ul><li>第一个问题就是 Region 中存在跨代引用的问题，我们之前知道可以用记忆集来解决跨代引用问题，不过 Region 中的跨代引用要复杂很多；</li><li>第二个问题就是如何保证收集线程与用户线程互不干扰的运行？CMS 使用的是增量更新算法，G1 使用的是原始快照（SATB），G1 为 Region 分配了两块 TAMS 指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时心分配的对象地址都必须在这两个指针位置以上。如果内存回收速度赶不上内存分配速度，G1 收集器也要冻结用户线程执行，导致 Full GC 而产生长时间的 STW。</li><li>第三个问题是无法建立可预测的停顿模型。</li></ul><h2 id="jvm-常用命令介绍" tabindex="-1"><a class="header-anchor" href="#jvm-常用命令介绍" aria-hidden="true">#</a> JVM 常用命令介绍</h2><p>下面介绍一下 JVM 中常用的调优、故障处理等工具。</p><ol><li><em>jps</em> ：虚拟机进程工具，全称是 <em>JVM Process Status Tool</em>，它的功能和 Linux 中的 <em>ps</em> 类似，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类 <em>Main Class</em> 所在的本地虚拟机唯一 ID，虽然功能比较单一，但是这个命令绝对是使用最高频的一个命令。</li><li><em>jstat</em>：虚拟机统计信息工具，用于监视虚拟机各种运行状态的信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。</li><li><em>jinfo</em>：Java 配置信息工具，全称是 <em>Configuration Info for Java</em>，它的作用是可以事实调整虚拟机各项参数。</li><li><em>jmap</em>：Java 内存映像工具，全称是 <em>Memory Map For Java</em>，它用于生成转储快照，用来排查内存占用情况</li><li><em>jhat</em>：虚拟机堆转储快照分析工具，全称是 <em>JVM Heap Analysis Tool</em>，这个指令通常和 jmap 一起搭配使用，jhat 内置了一个 HTTP/Web 服务器，生成转储快照后可以在浏览器中查看。不过，一般还是 jmap 命令使用的频率比较高。</li><li><em>jstack</em>：Java 堆栈跟踪工具，全称是 <em>Stack Trace for Java</em> ，顾名思义，这个命令用来追踪堆栈的使用情况，用于虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合。</li></ol><h2 id="什么是双亲委派模型" tabindex="-1"><a class="header-anchor" href="#什么是双亲委派模型" aria-hidden="true">#</a> 什么是双亲委派模型？</h2><p>JVM 类加载默认使用的是<strong>双亲委派模型</strong>，那么什么是双亲委派模型呢？</p><p>这里我们需要先介绍一下三种类加载器：</p><ul><li>启动类加载器，<em>Bootstrap Class Loader</em>，这个类加载器是 C++ 实现的，它是 JVM 的一部分，这个类加载器负责加载存放在 <em>&lt;JAVA_HOME&gt;\\lib</em> 目录，启动类加载器无法被 Java 程序直接引用。这也就是说，JDK 中的常用类的加载都是由启动类加载器来完成的。</li><li>扩展类加载器，<em>Extension Class Loader</em>，这个类加载器是 Java 实现的，它负责加载 <em>&lt;JAVA_HOME&gt;\\lib\\ext</em> 目录。</li><li>应用程序类加载器，<em>Application Class Loader</em>，这个类加载器是由 <em>sum.misc.Launcher$AppClassLoader</em> 来实现，它负责加载 <em>ClassPath</em> 上所有的类库，如果应用程序中没有定义自己的类加载器，默认使用就是这个类加载器。</li></ul><p>所以，我们的 Java 应用程序都是由这三种类加载器来相互配合完成的，当然，用户也可以自己定义类加载器，即 <em>User Class Loader</em>，这几个类加载器的模型如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gus4i6mvukj61290u0ade02.jpg" alt="image-20210924231418026"></p><p>上面这几类类加载器构成了不同的层次结构，当我们需要加载一个类时，子类加载器并不会马上去加载，而是依次去请求父类加载器加载，一直往上请求到最高类加载器：启动类加载器。当启动类加载器加载不了的时候，依次往下让子类加载器进行加载。这就是双亲委派模型。</p><h2 id="双亲委派模型的缺陷" tabindex="-1"><a class="header-anchor" href="#双亲委派模型的缺陷" aria-hidden="true">#</a> 双亲委派模型的缺陷？</h2><p>在双亲委派模型中，子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。这就导致了双亲委派模型并不能解决所有的类加载器问题。</p><p>Java 提供了很多外部接口，这些接口统称为 <em>Service Provider Interface, SPI</em>，允许第三方实现这些接口，而这些接口却是 Java 核心类提供的，由 Bootstrap Class Loader 加载，而一般的扩展接口是由 Application Class Loader 加载的，Bootstrap Class Loader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 Application Class Loader，因为它是最顶层的类加载器。</p><h2 id="双亲委派机制的三次破坏" tabindex="-1"><a class="header-anchor" href="#双亲委派机制的三次破坏" aria-hidden="true">#</a> 双亲委派机制的三次破坏</h2><p>虽然双亲委派机制是 Java 强烈推荐给开发者们的类加载器的实现方式，但是并没有强制规定你必须就要这么实现，所以，它一样也存在被破坏的情况，实际上，历史上一共出现三次双亲委派机制被破坏的情况：</p><ul><li>双亲委派机制第一次被破坏发生在双亲委派机制出现之前，由于双亲委派机制 JDK 1.2 之后才引用的，但类加载的概念在 Java 刚出现的时候就有了，所以引用双亲委派机制之前，设计者们必须兼顾开发者们自定义的一些类加载器的代码，所以在 JDK 1.2 之后的 java.lang.ClassLoader 中添加了一个新的 <em>findClass</em> 方法，引导用户编写类加载器逻辑的时候重写这个 findClass 方法，而不是基于 <em>loadClass</em>编写。</li><li>双亲委派机制第二次被破坏是由于它自己模型导致的，由于它只能向上（基础）加载，越基础的类越由上层加载器加载，所以如果基础类型又想要调用用户的代码，该怎么办？这也就是我们上面那个问题所说的 SPI 机制。那么 JDK 团队是如何做的呢？它们引用了一个 <strong>线程上下文类加载器(Thread Context ClassLoader)</strong>，这个类加载器可以通过 java.lang.Thread 类的 <em>setContextClassLoader</em> 进行设置，如果创建时线程还未设置，它将会从父线程中继承，如果全局没有设置类加载器的话，这个 ClassLoader 就是默认的类加载器。这种行为虽然是一种犯规行为，但是 Java 代码中的 <strong>JNDI、JDBC</strong> 等都是使用这种方式来完成的。直到 JDK 6 ，引用了 <em>java.util.ServiceLoader</em>，使用 <strong>META-INF/services</strong> + 责任链的设计模式，才解决了 SPI 的这种加载机制。</li><li>双亲委派机制第三次被破坏是由于用户对程序的动态需求使热加载、热部署的引入所致。由于时代的变化，我们希望 Java 能像鼠标键盘一样实现热部署，即时加载（load class），引入了 OSGI，OSGI 实现热部署的关键在于它自定义类加载器机制的实现，OSGI 中的每一个 <em>Bundle</em> 也就是模块都有一个自己的类加载器。当需要更换 Bundle 时，就直接把 Bundle 连同类加载器一起替换掉就能够实现热加载。在 OSGI 环境下，类加载器不再遵从双亲委派机制，而是使用了一种更复杂的加载机制。</li></ul><h2 id="常见的-jvm-调优参数有哪些" tabindex="-1"><a class="header-anchor" href="#常见的-jvm-调优参数有哪些" aria-hidden="true">#</a> 常见的 JVM 调优参数有哪些？</h2><ul><li>-Xms256m：初始化堆大小为 256m；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-Xmn50m：新生代的大小50m；</li><li>-XX:+PrintGCDetails 打印 gc 详细信息；</li><li>-XX:+HeapDumpOnOutOfMemoryError 在发生OutOfMemoryError错误时，来 dump 出堆快照；</li><li>-XX:NewRatio=4 设置年轻的和老年代的内存比例为 1:4；</li><li>-XX:SurvivorRatio=8 设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>-XX:+UseSerialGC 新生代和老年代都用串行收集器 Serial + Serial Old</li><li>-XX:+UseParNewGC 指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>-XX:+UseParallelGC 新生代使用 Parallel Scavenge，老年代使用 Serial Old</li><li>-XX:+UseParallelOldGC：新生代 ParallelScavenge + 老年代 ParallelOld 组合；</li><li>-XX:+UseConcMarkSweepGC：新生代使用 ParNew，老年代的用 CMS；</li><li>-XX:NewSize：新生代最小值；</li><li>-XX:MaxNewSize：新生代最大值</li><li>-XX:MetaspaceSize 元空间初始化大小</li><li>-XX:MaxMetaspaceSize 元空间最大值</li></ul>`,142);function m(v,B){const l=t("ExternalLinkIcon");return p(),r("div",null,[c,e("p",null,[a("关于为什么这么分配的内存，我们可以从 "),d,a(" 中的"),e("a",g,[a("markOop.hpp"),s(l)]),a("类中的枚举窥出端倪")]),h,e("p",null,[e("a",E,[a("小心点，别被当成垃圾回收了。"),s(l)])]),u])}const A=n(o,[["render",m],["__file","jvm-interviewanswer.html.vue"]]);export{A as default};
