import{_ as o,r as i,o as d,c as n,a as e,b as a,d as l,e as r}from"./app-3RcBQnkC.js";const c={},h=r('<h1 id="分布式系统-cap-定理-p-代表什么含义" tabindex="-1"><a class="header-anchor" href="#分布式系统-cap-定理-p-代表什么含义" aria-hidden="true">#</a> 分布式系统 CAP 定理 P 代表什么含义</h1><p>作者之前在看 CAP 定理时抱有很大的疑惑，CAP 定理的定义是指在分布式系统中三者只能满足其二，也就是存在分布式 CA 系统的。作者在网络上查阅了很多关于 CAP 文章，虽然这些文章对于 P 的解释五花八门，但总结下来这些观点大多都是指 P 是不可缺少的，也就是说在分布式系统只能是 AP 或者 CP，这种理论与我之前所认识的理论（存在分布式 CA 系统）是冲突的，所以才有了疑惑。</p><blockquote><p>这个定理起源于加州大学柏克莱分校（University of California, Berkeley）的计算机科学家埃里克·布鲁尔在 2000 年的分布式计算原理研讨会（PODC）上提出的一个猜想。 在 2002 年，麻省理工学院（MIT）的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为一个定理。</p></blockquote><h3 id="什么是-cap-定理-cap-theorem" tabindex="-1"><a class="header-anchor" href="#什么是-cap-定理-cap-theorem" aria-hidden="true">#</a> 什么是 CAP 定理（CAP theorem）</h3><p>在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer&#39;s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li><li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。）</li></ul><h3 id="分区容错性-partition-tolerance" tabindex="-1"><a class="header-anchor" href="#分区容错性-partition-tolerance" aria-hidden="true">#</a> 分区容错性（Partition tolerance）</h3><p>理解 CAP 理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质。</p><ul><li>P 指的是分区容错性，分区现象产生后需要容错，容错是指在 A 与 C 之间选择。如果分布式系统没有分区现象（没有出现不一致不可用情况） 本身就没有分区 ，既然没有分区则就更没有分区容错性 P。</li><li>无论我设计的系统是 AP 还是 CP 系统如果没有出现不一致不可用。 则该系统就处于 CA 状态</li><li>P 的体现前提是得有分区情况存在</li></ul>',9),s={href:"https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86",target:"_blank",rel:"noopener noreferrer"},p=r('<h2 id="几个常用的-cap-框架对比" tabindex="-1"><a class="header-anchor" href="#几个常用的-cap-框架对比" aria-hidden="true">#</a> 几个常用的 CAP 框架对比</h2><table><thead><tr><th>框架</th><th>所属</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td></tr><tr><td>Zookeeper</td><td>CP</td></tr><tr><td>Consul</td><td>CP</td></tr></tbody></table><h3 id="eureka" tabindex="-1"><a class="header-anchor" href="#eureka" aria-hidden="true">#</a> Eureka</h3><blockquote><p>Eureka 保证了可用性，实现最终一致性。</p></blockquote><p>Eureka 所有节点都是平等的所有数据都是相同的，且 Eureka 可以相互交叉注册。<br> Eureka client 使用内置轮询负载均衡器去注册，有一个检测间隔时间，如果在一定时间内没有收到心跳，才会移除该节点注册信息；如果客户端发现当前 Eureka 不可用，会切换到其他的节点，如果所有的 Eureka 都跪了，Eureka client 会使用最后一次数据作为本地缓存；所以以上的每种设计都是他不具备<code>一致性</code>的特性。</p><p>注意：因为 EurekaAP 的特性和请求间隔同步机制，在服务更新时候一般会手动通过 Eureka 的 api 把当前服务状态设置为<code>offline</code>，并等待 2 个同步间隔后重新启动，这样就能保证服务更新节点对整体系统的影响</p><h3 id="zookeeper" tabindex="-1"><a class="header-anchor" href="#zookeeper" aria-hidden="true">#</a> Zookeeper</h3><blockquote><p>强一致性</p></blockquote><p>Zookeeper 在选举 leader 时会停止服务，只有成功选举 leader 成功后才能提供服务，选举时间较长；内部使用 paxos 选举投票机制，只有获取半数以上的投票才能成为 leader，否则重新投票，所以部署的时候最好集群节点不小于 3 的奇数个（但是谁能保证跪掉后节点也是奇数个呢）；Zookeeper 健康检查一般是使用 tcp 长链接，在内部网络抖动时或者对应节点阻塞时候都会变成不可用，这里还是比较危险的；</p><h3 id="consul" tabindex="-1"><a class="header-anchor" href="#consul" aria-hidden="true">#</a> Consul</h3><p>和 Zookeeper 一样数据 CP</p><p>Consul 注册时候只有过半的节点都写入成功才认为注册成功；leader 挂掉时，重新选举期间整个 Consul 不可用,保证了强一致性但牺牲了可用性<br> 有很多 blog 说 Consul 属于 ap，官方已经确认他为 CP 机制 原文地址：https://www.consul.io/docs/intro/vs/serf</p>',12);function u(k,C){const t=i("ExternalLinkIcon");return d(),n("div",null,[h,e("blockquote",null,[e("p",null,[a("文章来源："),e("a",s,[a("维基百科 CAP 定理"),l(t)])])]),p])}const b=o(c,[["render",u],["__file","distributed-system-cap.html.vue"]]);export{b as default};
