import{_ as e,o as t,c as i,e as a}from"./app-3RcBQnkC.js";const l={},r=a('<h1 id="a-5-性能" tabindex="-1"><a class="header-anchor" href="#a-5-性能" aria-hidden="true">#</a> A.5 性能</h1><p>下图给出核心与树 API、ClassWriter 选项和分析框架的相对性能（越短越快）：</p><p><img src="http://asm.itstack.org/assets/img/2020/A.5-1.png" alt=""></p><p>引用时间 100 对应于直接链接到 ClassWriter 的 ClassReader。“加计时器”和“移除序列”测试对应于 AddTimerAdapter 和 RemoveGetFieldPutFieldAdapter（斜体表示使用 2.2.4 节所述的优化，粗体表示使用树 API）。总转换时间分解为三个部分：类分析（下）、类转换或分析（中间）和类的写入（上）。对于每个测试，测量值都是分析、转换和写入一个字节数组所需要的时间，也就是从磁盘加载类并将它们加载到 JVM 所需要的时间未考虑在内。为 获得这些结果，将每个测试对于 JDK 7 rt.jar 上的 18600 多个类运行 10 次，并采用最佳运行时获得的性能。</p><p>快速分析一下这些结果表明：</p><ul><li>90%的转换时间用于类分析和写入。</li><li>“复制常量池”优化可提速 15-20%。</li><li>基于树的转换要比基于访问器的慢大约 25%。</li><li>COMPUTE_MAXS 选项不会耗时太多。</li><li>COMPUTE_FRAMES 选项耗时很多⇒进行增量帧更新。</li><li>分析包的成本非常高！</li></ul>',6),s=[r];function n(c,d){return t(),i("div",null,s)}const _=e(l,[["render",n],["__file","A.5xingnen.html.vue"]]);export{_ as default};
