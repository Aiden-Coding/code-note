import{_ as e,o as t,c as s,e as r}from"./app-3RcBQnkC.js";const n="/code-note/assets/distributed-system-request-sequence-p7E4eKfJ.png",a={},o=r('<h1 id="分布式服务接口请求的顺序性如何保证" tabindex="-1"><a class="header-anchor" href="#分布式服务接口请求的顺序性如何保证" aria-hidden="true">#</a> 分布式服务接口请求的顺序性如何保证？</h1><h2 id="面试官心理分析" tabindex="-1"><a class="header-anchor" href="#面试官心理分析" aria-hidden="true">#</a> 面试官心理分析</h2><p>其实分布式系统接口的调用顺序，也是个问题，一般来说是不用保证顺序的。但是<strong>有时候</strong>可能确实是需要<strong>严格的顺序</strong>保证。给大家举个例子，你服务 A 调用服务 B，先插入再删除。好，结果俩请求过去了，落在不同机器上，可能插入请求因为某些原因执行慢了一些，导致删除请求先执行了，此时因为没数据所以啥效果也没有；结果这个时候插入请求过来了，好，数据插入进去了，那就尴尬了。</p><p>本来应该是 “先插入 -&gt; 再删除”，这条数据应该没了，结果现在 “先删除 -&gt; 再插入”，数据还存在，最后你死都想不明白是怎么回事。</p><p>所以这都是分布式系统一些很常见的问题。</p><h2 id="面试题剖析" tabindex="-1"><a class="header-anchor" href="#面试题剖析" aria-hidden="true">#</a> 面试题剖析</h2><p>首先，一般来说，个人建议是，你们从业务逻辑上设计的这个系统最好是不需要这种顺序性的保证，因为一旦引入顺序性保障，比如使用<strong>分布式锁</strong>，会<strong>导致系统复杂度上升</strong>，而且会带来<strong>效率低下</strong>，热点数据压力过大等问题。</p><p>下面我给个我们用过的方案吧，简单来说，首先你得用 Dubbo 的一致性 hash 负载均衡策略，将比如某一个订单 id 对应的请求都给分发到某个机器上去，接着就是在那个机器上，因为可能还是多线程并发执行的，你可能得立即将某个订单 id 对应的请求扔一个<strong>内存队列</strong>里去，强制排队，这样来确保他们的顺序性。</p><p><img src="'+n+'" alt="distributed-system-request-sequence"></p><p>但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成<strong>热点</strong>怎么办？解决这些问题又要开启后续一连串的复杂技术方案...... 曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？</p><p>最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是其它什么，避免这种问题的产生。</p>',11),d=[o];function i(c,h){return t(),s("div",null,d)}const u=e(a,[["render",i],["__file","distributed-system-request-sequence.html.vue"]]);export{u as default};
