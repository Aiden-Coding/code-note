import{_ as e,o as a,c as i,e as n}from"./app-3RcBQnkC.js";const d={},s=n(`<h1 id="如何在大量的数据中找出不重复的整数" tabindex="-1"><a class="header-anchor" href="#如何在大量的数据中找出不重复的整数" aria-hidden="true">#</a> 如何在大量的数据中找出不重复的整数？</h1><h3 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述" aria-hidden="true">#</a> 题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h3 id="解答思路" tabindex="-1"><a class="header-anchor" href="#解答思路" aria-hidden="true">#</a> 解答思路</h3><h4 id="方法一-分治法" tabindex="-1"><a class="header-anchor" href="#方法一-分治法" aria-hidden="true">#</a> 方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二-位图法" tabindex="-1"><a class="header-anchor" href="#方法二-位图法" aria-hidden="true">#</a> 方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0 0 0 0 0 0 0 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0 0 0 0 1 0 1 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>依次遍历，结束后，位数组是这样的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0 1 1 0 1 1 1 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>每个为 1 的位，它的下标都表示了一个数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for i in range(8):
    if bits[i] == 1:
        print(i)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2<sup>32</sup>。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>00 表示这个数字没出现过；</li><li>01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>10 表示这个数字出现了多次。</li></ul><p>那么这 2<sup>32</sup> 个整数，总共所需内存为 2<sup>32</sup>*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><p>当然，本题中特别说明：<strong>内存不足以容纳这 2.5 亿个整数</strong>，2.5 亿个整数的内存大小为：2.5e8/1024/1024/1024 * 4=3.72GB， 如果内存大于 1GB，是可以通过位图法解决的。</p><h3 id="方法总结" tabindex="-1"><a class="header-anchor" href="#方法总结" aria-hidden="true">#</a> 方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法，当然前提是：内存要满足位图法所需要的存储空间。</p>`,26),r=[s];function t(l,c){return a(),i("div",null,r)}const o=e(d,[["render",t],["__file","find-no-repeat-number.html.vue"]]);export{o as default};
