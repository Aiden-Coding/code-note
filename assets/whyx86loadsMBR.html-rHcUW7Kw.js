import{_ as o,o as i,c as e,e as l}from"./app-3RcBQnkC.js";const p={},a=l('<h1 id="为什么-x86-中-bios-会把-mbr-放在-0x7c00-地址处" tabindex="-1"><a class="header-anchor" href="#为什么-x86-中-bios-会把-mbr-放在-0x7c00-地址处" aria-hidden="true">#</a> 为什么 x86 中 BIOS 会把 MBR 放在 0x7c00 地址处？</h1><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-x86-%E4%B8%AD-bios-%E4%BC%9A%E6%8A%8A-mbr-%E6%94%BE%E5%9C%A8-0x7c00-%E5%9C%B0%E5%9D%80%E5%A4%84">为什么 x86 中 BIOS 会把 MBR 放在 0x7c00 地址处？</a><ul><li><a href="#0x7c00-%E9%A6%96%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%9C%A8-ibm-pc-5150-rom-bios-int-19h-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD">0x7C00 首次出现在 IBM PC 5150 ROM BIOS INT 19h 处理程序中</a></li><li><a href="#0x7c00-%E7%9A%84%E8%B5%B7%E6%BA%90">0x7c00 的起源</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-cpu-monitor-%E8%A6%81%E6%8A%8A-bootloader-%E5%8A%A0%E8%BD%BD%E5%88%B0-0x200-">为什么 CPU Monitor 要把 bootloader 加载到 0x200 ?</a></li></ul></li><li><a href="#%E8%B0%81%E5%86%B3%E5%AE%9A%E4%BA%86-0x7c00">谁决定了 0x7c00?</a></li></ul></li></ul><p>这是一个很值得拿来探讨一下的问题。</p><p>为什么 x86 中 BIOS 会把 MBR 放在 0x7c00 这个地址上呢？针对这个问题，你可能有两个疑惑点：</p><blockquote><p>我读过所有的 x86 程序开发手册，但是都没有找到 0x7c00 这个魔数。</p></blockquote><p>首先 0x7c00 这个魔数和 x86 CPU 无关，所以你在 intel 特定的 CPU 手册里面找不到也能说得通。然后你会好奇，那是谁决定了这个数字？</p><blockquote><p>0x7c00 是十进制的 32kib - 1024b，这个数字是什么意思？</p></blockquote><p>其实任何人都可以决定这个数字，但是，问题的关键是为什么会选择一个这样中间的地址？</p><p>所以现在围绕 0x7c00 就有两个需要讨论的问题</p><blockquote><ol><li>谁决定了 0x7c00 这个数字</li><li>0x7c00 = 32 kib - 1024b 是什么意思？</li></ol></blockquote><p>问题需要追溯到 IBM PC 5150 了，它是 x86 的祖先！</p><h2 id="_0x7c00-首次出现在-ibm-pc-5150-rom-bios-int-19h-处理程序中" tabindex="-1"><a class="header-anchor" href="#_0x7c00-首次出现在-ibm-pc-5150-rom-bios-int-19h-处理程序中" aria-hidden="true">#</a> 0x7C00 首次出现在 IBM PC 5150 ROM BIOS INT 19h 处理程序中</h2><p>如果你了解过 x86 的历史，那么你就会知道 IBM PC 5150是 x86（32位）IBM PC/AT 的祖先。这款电脑于 1981 年 8 月发布，采用了 8088（16）位和 16 kib RAM 的最低内存型号。BIOS 和 Microsoft BASIC 存储在 ROM 中。</p><p>开机上电时，BIOS 会进行 POST 开机自检，然后调用 INT 19h 中断。在 INT 19 h 中断例程中，BIOS 会检查从哪里启动操作系统，是从硬盘，软盘还是固定磁盘。如果计算机有任何可用的磁盘，BIOS 就会将磁盘的第一个扇区 512 字节加载到 0x7c00 处。</p><p>所以你现在知道了为什么在 x86 文档中找不到这个神奇的数字了，因为这个数字属于 BIOS 规范。</p><h2 id="_0x7c00-的起源" tabindex="-1"><a class="header-anchor" href="#_0x7c00-的起源" aria-hidden="true">#</a> 0x7c00 的起源</h2><p>SCP（一家公司）的 “86-DOS”（1980年）是 IBM PC DOS 1.0 的参考操作系统。86-DOS（最早叫 QDOS）是适用于 8086/8088 CPU 的 CP/M 兼容操作系统。在 1979 年，Digital Research Inc（数字搜索公司）还没有开发出 8086/8088 CPU 的 CP/M 操作系统。</p><blockquote><p>其实 Digital Research Inc 这家公司本来有机会能在计算机高速发展的年代占据先机，但是碍于其目光短浅最后败给了微软。</p><p>大家知道，当时 Paul Allen 和 Bill Gates 开发出来了 BASIC 解释器并成立了微软公司，1980年10月，IBM公司决定推出基于Intel 8086芯片的PC。它找到 Digital Research 公司，要求获得授权使用 CP/M 系统。但是协议没有谈成。于是，IBM 又去找微软公司，要求微软为它提供操作系统。</p><p>当时，微软没有操作系统产品，但是 Bill Gates 知道 SCP 公司正在开发 QDOS。微软支付2.5万美元给SCP，获得了 QDOS 的使用许可。</p><p>后来 Bill Gates 看见了巨大的商机，索性直接把 QDOS 买下来了，于是 QDOS 成为了微软的财产，后来 QDOS 改名为 MS-DOS 。</p><p>这段完全是 cxuan 强行拓展的，与正文无关。</p></blockquote><p>SCP 卖了两块 S-100 的板子，第一个是 8086 CPU 的板子，第二个是 &quot;CPU Monitor&quot;的板子。CPU Monitor 程序提供了 bootloader 引导加载器和 debugger 调试器。CPU Monitor 的 bootloader 会把 MBR 加载到 &quot;0x200&quot; ，而非 &quot;0x7c00&quot;，1981年，IBM PC DOS 是 8086/8088 的下一个类似 CP/M 的操作系统。</p><p>所以，0x7c00 第一次出现在 IBM PC 5150 ROM BIOS 中，而 SCP 的 CPU Monitor 会将引导程序加载至 0x200 而非 0x7c00 处。</p><p>那么问题又来了。。。。。。</p><h3 id="为什么-cpu-monitor-要把-bootloader-加载到-0x200" tabindex="-1"><a class="header-anchor" href="#为什么-cpu-monitor-要把-bootloader-加载到-0x200" aria-hidden="true">#</a> 为什么 CPU Monitor 要把 bootloader 加载到 0x200 ?</h3><p>关于 0x200 有三个原因：</p><ol><li>8086 中断向量使用 0x0 - 0x3FF 。</li><li>86 - DOS 会被加载到 0x400 处。</li><li>86 - DOS 并不会使用 0x200 - 0x3FF 之间的中断向量。</li></ol><p>这些原因意味着 0x200-0x3FF 需要保留，不能妨碍操作系统，无论 86-DOS 或用户应用程序要加载到哪里。</p><p>所以 Tim Paterson（86 - DOS 的开发者）选择了 0x200 这个地址作为 MBR 的加载地址。</p><h2 id="谁决定了-0x7c00" tabindex="-1"><a class="header-anchor" href="#谁决定了-0x7c00" aria-hidden="true">#</a> 谁决定了 0x7c00?</h2><p>所以决定 0x7c00 这个地址的是 IBM PC 5150 BIOS 的开发团队 (Dr. David Bradley)。如上所述，这个神奇的数字诞生于1981年，“IBM PC/at Compat” PC/BIOS 供应商没有因为 BIOS 和操作系统的向后兼容性而改变这个值。</p><p>也不是 Intel（8086/8088）或者是微软（操作系统厂商）决定的。</p><p>##0x7c00 = 32 kib - 1024b 是什么意思？</p><p>IBM PC 5150 最小的内容模型只有 16 kib 的 RAM，所以你可能会有疑问。</p><blockquote><p>最小内存型号仅仅 16 kib 能从软盘加载操作系统吗？BIOS 会将 MBR 加载到 32 kib - 1024 b ，但是物理 RAM 显然不够。</p></blockquote><p>这种情况显然缺乏考虑，BM PC 5150 ROM BIOS 开发团队的成员，David Bradley 博士说到：</p><blockquote><p>DOS 1.0 都需要至少 32 kb，所以我们不用担心尝试以 16 kb 启动。</p></blockquote><p>BIOS 的开发者团队决定使用 0x7c00 这个地址是因为下面几个原因：</p><ol><li>他们想要给 32 Kib 操作系统的加载留下足够的空间。</li><li>8086/8088 使用 0x0 - 0x3FF 作为中断向量地址，并且 BIOS 的数据区在这个地址后面。</li><li>boot 引导扇区是 512 字节，引导程序的堆栈/数据区域需要的空间要比 512 字节多。</li><li>因此，选择 0x7C00，即 32 KiB的最后 1024B。</li></ol><p>一旦操作系统加载并启动，启动扇区将永远不会使用，直到电源重置。因此，操作系统和应用程序可以自由使用32 KiB 的最后1024B。</p><p><img src="https://www.cxuan.vip/image-20230816220232763.png" alt=""></p><p>说点人话：</p><p>我们可以来计算机一下内存空间的占用情况：</p><p>0x0 - 0x3FF 用来做中断向量，所以只剩下 0x400 - 0x7FFF（32 kb） 可用。</p><p>为了把更多的内存空间给操作系统，MBR 就被放在了 32 Kib 的尾部，由于一个扇区占用 512 字节，MBR 本身也会产生数据，所以留给 MBR 和其数据区的空间就变为了 1024 字节。</p><p>于是 0x7FFF - 1024 + 1 = 0x7c00 。</p><p>这就是 0x7C00 的起源和原因，这个神奇的数字在 PC/AT Compat BIOS INT 19h 处理程序中存活了大约三十年。</p>',44),c=[a];function t(B,x){return i(),e("div",null,c)}const b=o(p,[["render",t],["__file","whyx86loadsMBR.html.vue"]]);export{b as default};
