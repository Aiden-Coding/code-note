import{_ as a,o as e,c as i,e as r}from"./app-3RcBQnkC.js";const h={},l=r('<h1 id="微服务治理策略" tabindex="-1"><a class="header-anchor" href="#微服务治理策略" aria-hidden="true">#</a> 微服务治理策略</h1><h2 id="服务的注册和发现" tabindex="-1"><a class="header-anchor" href="#服务的注册和发现" aria-hidden="true">#</a> 服务的注册和发现</h2><p>解决问题：集中管理服务</p><p>解决方法：</p><ul><li>Eureka</li><li>Zookeeper</li></ul><h2 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡" aria-hidden="true">#</a> 负载均衡</h2><p>解决问题：降低服务器硬件压力</p><p>解决方法：</p><ul><li>Nginx</li><li>Ribbon</li></ul><h2 id="通讯" tabindex="-1"><a class="header-anchor" href="#通讯" aria-hidden="true">#</a> 通讯</h2><p>解决问题：各个服务之间的沟通桥梁</p><p>解决方法：</p><ul><li>REST（同步）</li><li>RPC（同步）</li><li>MQ（异步）</li></ul><h2 id="配置管理" tabindex="-1"><a class="header-anchor" href="#配置管理" aria-hidden="true">#</a> 配置管理</h2><p>解决问题：随着服务的增加配置也在增加，如何管理各个服务的配置。</p><p>解决方法：</p><ul><li>Nacos</li><li>Spring Cloud Config</li><li>Apollo</li></ul><h2 id="容错和服务降级" tabindex="-1"><a class="header-anchor" href="#容错和服务降级" aria-hidden="true">#</a> 容错和服务降级</h2><p>解决问题：在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可以，没有做服务容错的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。</p><p>解决方法：</p><ul><li>Hystrix</li></ul><h2 id="服务依赖关系" tabindex="-1"><a class="header-anchor" href="#服务依赖关系" aria-hidden="true">#</a> 服务依赖关系</h2><p>解决问题：多个服务之间来回依赖，启动关系的不明确。</p><p>解决方法：应用分层。</p><h2 id="服务文档" tabindex="-1"><a class="header-anchor" href="#服务文档" aria-hidden="true">#</a> 服务文档</h2><p>解决问题：降低沟通成本</p><p>解决方法：</p><ul><li>Swagger</li><li>Java doc</li></ul><h2 id="服务安全问题" tabindex="-1"><a class="header-anchor" href="#服务安全问题" aria-hidden="true">#</a> 服务安全问题</h2><p>解决问题：敏感数据的安全性</p><p>解决方法：</p><ul><li>Oauth</li><li>Shiro</li><li>Spring Security</li></ul><h2 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制" aria-hidden="true">#</a> 流量控制</h2><p>解决问题：避免一个服务上的流量过大拖垮整个服务体系</p><p>解决方法：</p><ul><li>Hystrix</li></ul><h2 id="自动化测试" tabindex="-1"><a class="header-anchor" href="#自动化测试" aria-hidden="true">#</a> 自动化测试</h2><p>解决问题：提前预知异常，确定服务是否可用</p><p>解决方法：</p><ul><li>junit</li></ul><h2 id="服务上线-下线的流程" tabindex="-1"><a class="header-anchor" href="#服务上线-下线的流程" aria-hidden="true">#</a> 服务上线，下线的流程</h2><p>解决问题：避免服务随意的上线下线</p><p>解决方法：新服务上线需要经过管理人员审核，服务下线需要告知各个调用方进行修改，直到没有调用该服务才可以进行下线。</p><h2 id="兼容性" tabindex="-1"><a class="header-anchor" href="#兼容性" aria-hidden="true">#</a> 兼容性</h2><p>解决问题：服务开发持续进行如何做到兼容。</p><p>解决方法：通过版本号的形式进行管理，修改完成进行回归测试。</p><h2 id="服务编排" tabindex="-1"><a class="header-anchor" href="#服务编排" aria-hidden="true">#</a> 服务编排</h2><p>解决问题：解决服务依赖问题的一种方式</p><p>解决方法：</p><ul><li>Docker</li><li>K8s</li></ul><h2 id="资源调度" tabindex="-1"><a class="header-anchor" href="#资源调度" aria-hidden="true">#</a> 资源调度</h2><p>解决问题：每个服务的资源占用量不同，如何分配</p><p>解决方法：</p><ul><li>JVM 隔离</li><li>Classload 隔离</li><li>硬件隔离</li></ul><h2 id="容量规划" tabindex="-1"><a class="header-anchor" href="#容量规划" aria-hidden="true">#</a> 容量规划</h2><p>解决问题：随着时间增长，调用逐步增加，什么时候追加机器。</p><p>解决方法：统计每日调用量和响应时间，根据机器情况设置阈值，超过阈值就可以追加机器。</p>',57),d=[l];function n(p,c){return e(),i("div",null,d)}const s=a(h,[["render",n],["__file","micro-service-governance.html.vue"]]);export{s as default};
