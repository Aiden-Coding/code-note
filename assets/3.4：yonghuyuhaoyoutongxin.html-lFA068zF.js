import{_ as o,r as a,o as l,c as r,a as e,b as n,d as s,f as c}from"./app-3RcBQnkC.js";const _={},h=e("h1",{id:"_3-4-用户与好友通信",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-4-用户与好友通信","aria-hidden":"true"},"#"),n(" 3.4：用户与好友通信")],-1),i=e("br",null,null,-1),d={href:"https://bugstack.cn",target:"_blank",rel:"noopener noreferrer"},u=e("blockquote",null,[e("p",null,"沉淀、分享、成长，让自己和他人都能有所收获！")],-1),p=e("h2",{id:"一、前言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#一、前言","aria-hidden":"true"},"#"),n(" 一、前言")],-1),f=e("p",null,"经过我们一系列基础工作的开发，写到这里终于可以要去实现两个用户之间的通信了。可以先想一下我们都做了那些基础工作才到这里；加好友、好友列表、对话通知。是这三大部分的完成，为下一步好友之间的通信打下基础。",-1),m=e("p",null,"那么，好友之间的通信基本需要的是，好友需要在线，因为只有这样才能拿到好友的 channel，也就是通信管道。当客户端 A 发送消息到服务端，服务端找到被接收消息的 B 的通信取到，开始将消息发送过去。",-1),x=e("h2",{id:"二、流程设计",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#二、流程设计","aria-hidden":"true"},"#"),n(" 二、流程设计")],-1),b=e("ul",null,[e("li",null,"用户发送的前提是，已经选中了与好友通信的窗口。那么此时就可以拿到好友的 ID，再点击发送消息的时候再将；好友 ID、消息、时间、个人 ID，一起发送给服务端。"),e("li",null,"服务端收到数据后，首先是将消息使用多线程进行异步落库留存。接下来会判断好友是否在线，是使用好友 ID 来从服务端的 Map 结构中获取通信渠道 Channel。"),e("li",null,"最后获取到好友的 Channel 后，将消息发送给好友。好友收到消息后，通过 UI 的接口，使消息展示到界面上。")],-1);function g(k,I){const t=a("ExternalLinkIcon");return l(),r("div",null,[h,e("p",null,[n("作者：小傅哥 "),i,n("博客："),e("a",d,[n("https://bugstack.cn"),s(t)])]),u,p,f,m,x,c(" ![](/images/article/project/im/project-im-3.4-01.png) "),b])}const B=o(_,[["render",g],["__file","3.4：yonghuyuhaoyoutongxin.html.vue"]]);export{B as default};
