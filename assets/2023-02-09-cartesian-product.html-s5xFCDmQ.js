import{_ as e,r as p,o as c,c as o,a as n,b as s,d as t,e as l}from"./app-3RcBQnkC.js";const i={},u=n("h1",{id:"《程序员数学-笛卡尔积》-多集合结果",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#《程序员数学-笛卡尔积》-多集合结果","aria-hidden":"true"},"#"),s(" 《程序员数学：笛卡尔积》- 多集合结果")],-1),r=n("br",null,null,-1),k={href:"https://bugstack.cn",target:"_blank",rel:"noopener noreferrer"},d=n("br",null,null,-1),m={href:"https://github.com/fuzhengwei/java-algorithms",target:"_blank",rel:"noopener noreferrer"},v=l(`<blockquote><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h2 id="一、前言" tabindex="-1"><a class="header-anchor" href="#一、前言" aria-hidden="true">#</a> 一、前言</h2><p>在集合论中，笛卡尔积是一种数学运算，它从多个集合中返回一个集合（或乘积集或简单的乘积）。也就是说，对于集合 A 和 B，笛卡尔积 A × B 是所有有序对 (a, b) 的集合，其中 a ∈ A 和 b ∈ B。</p><p>它把每个集合中的元素看作一维，并组合成多维的矩阵。例如，假设有两个集合A和B，其中A = {a1, a2}，B = {b1, b2}，那么笛卡尔积就是：A x B = {(a1, b1), (a1, b2), (a2, b1), (a2, b2)}。笛卡尔积可以用来解决许多数学问题，也可以用于编程和计算机科学中。</p><h2 id="二、扑克牌场景" tabindex="-1"><a class="header-anchor" href="#二、扑克牌场景" aria-hidden="true">#</a> 二、扑克牌场景</h2><p>一副扑克牌有52张，13种数字和4种花色组成。其实这就是一个笛卡尔积的体现。</p><div align="center"><img src="https://bugstack.cn/images/article/algorithm/logic/cartesian-product-01.png?raw=true" width="550px"></div><p>标准扑克牌 {A , K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2} 形成一个 13 元素集。牌套{♠, ♥ , ♦ , ♣}形成一个四元素集。这些集合的笛卡尔积返回一个包含 52 个有序对的 52 元素集合，对应于所有 52 张可能的扑克牌。</p><p><em>Ranks</em> × <em>Suits</em> 返回 {(A, ♠), (A, ♥ ), (A, ♦ ), (A, ♣), (K, ♠), …, (3, ♣), (2 , ♠), (2, ♥ ), (2, ♦ ), (2, ♣)}。</p><p><em>Suits</em> × <em>Ranks</em> 返回一组形式 {(♠, A), (♠, K), (♠, Q), (♠, J), (♠, 10), …, (♣, 6), (♣ , 5), (♣, 4), (♣, 3), (♣, 2)}。</p><p>这两个集合是不同的，甚至是不相交的，但是它们之间存在一个自然的双射，在该双射下，(3, ♣) 对应于 (♣, 3) 等等。</p><h2 id="三、实现笛卡尔积" tabindex="-1"><a class="header-anchor" href="#三、实现笛卡尔积" aria-hidden="true">#</a> 三、实现笛卡尔积</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CartesianProduct</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">cartesianProduct</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> setA<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> setB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Check if input sets are not empty.</span>
        <span class="token comment">// Otherwise return null since we can&#39;t generate Cartesian Product out of them.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>setA <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> setB <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> setA<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> setB<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Init product set.</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Now, let&#39;s go through all elements of a first and second set and form all possible pairs.</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> elementA <span class="token operator">:</span> setA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> elementB <span class="token operator">:</span> setB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Add current product pair to the product set.</span>
                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> currentPair <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                currentPair<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>elementA<span class="token punctuation">)</span><span class="token punctuation">;</span>
                currentPair<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>elementB<span class="token punctuation">)</span><span class="token punctuation">;</span>
                product<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentPair<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Return cartesian product set.</span>
        <span class="token keyword">return</span> product<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该方法的参数是两个列表：&quot;setA&quot; 和 &quot;setB&quot;。在方法开始处，它检查了两个列表是否为空，如果任意一个列表为空，则返回空值（null）。</p><p>如果两个列表都不为空，则在内部循环中计算两个列表的笛卡尔积：第一个循环遍历第一个列表，第二个循环遍历第二个列表。两个循环的每次迭代都会生成一个当前的产品对，该产品对由两个元素组成：一个元素是第一个列表的当前元素，另一个元素是第二个列表的当前元素。这个产品对存储在 &quot;product&quot; 列表中，并在循环结束时返回。</p><p>因此，该方法将两个列表的笛卡尔积作为一个列表中的产品对返回。</p><hr>`,17),b={href:"https://en.wikipedia.org/wiki/Cartesian_product",target:"_blank",rel:"noopener noreferrer"};function h(g,f){const a=p("ExternalLinkIcon");return c(),o("div",null,[u,n("p",null,[s("作者：小傅哥 "),r,s("博客："),n("a",k,[s("https://bugstack.cn"),t(a)]),d,s("源码："),n("a",m,[s("https://github.com/fuzhengwei/java-algorithms"),t(a)])]),v,n("ul",null,[n("li",null,[n("a",b,[s("笛卡尔积"),t(a)])])])])}const w=e(i,[["render",h],["__file","2023-02-09-cartesian-product.html.vue"]]);export{w as default};
