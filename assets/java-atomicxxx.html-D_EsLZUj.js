import{_ as a,o as s,c as e,f as t,e as n}from"./app-3RcBQnkC.js";const o={},p=n('<h1 id="atomicxxx-的用法和实现原理" tabindex="-1"><a class="header-anchor" href="#atomicxxx-的用法和实现原理" aria-hidden="true">#</a> Atomicxxx 的用法和实现原理</h1><ul><li><a href="#atomicxxx-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">Atomicxxx 的用法和实现原理</a><ul><li><a href="#%E4%BA%86%E8%A7%A3-atomicinteger">了解 AtomicInteger</a><ul><li><a href="#atomicinteger-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7">AtomicInteger 的基本属性</a></li><li><a href="#atomicinteger-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">AtomicInteger 的构造方法</a></li><li><a href="#atomicinteger-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95">AtomicInteger 中的方法</a><ul><li><a href="#get--%E5%92%8C-set">Get 和 Set</a></li><li><a href="#incremental-%E6%93%8D%E4%BD%9C">Incremental 操作</a></li><li><a href="#decremental-%E6%93%8D%E4%BD%9C">Decremental 操作</a></li><li><a href="#lazyset-%E6%96%B9%E6%B3%95">LazySet 方法</a></li><li><a href="#getandset-%E6%96%B9%E6%B3%95">GetAndSet 方法</a></li><li><a href="#cas-%E6%96%B9%E6%B3%95">CAS 方法</a></li><li><a href="#addandget">AddAndGet</a></li></ul></li><li><a href="#%E6%B7%B1%E5%85%A5-atomicinteger">深入 AtomicInteger</a><ul><li><a href="#atomicinteger-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">AtomicInteger 的底层实现原理</a></li><li><a href="#%E4%B9%90%E8%A7%82%E9%94%81">乐观锁</a></li><li><a href="#aba-%E9%97%AE%E9%A2%98">ABA 问题</a></li></ul></li></ul></li><li><a href="#%E8%AE%A4%E8%AF%86-atomicboolean">认识 AtomicBoolean</a><ul><li><a href="#atomicboolean-%E5%88%9B%E5%BB%BA">AtomicBoolean 创建</a></li><li><a href="#atomicboolean-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">AtomicBoolean 基本方法</a><ul><li><a href="#get">Get</a></li><li><a href="#compareandset">CompareAndSet</a></li><li><a href="#set">Set</a></li><li><a href="#lazyset">LazySet</a></li><li><a href="#getandset">GetAndSet</a></li></ul></li></ul></li><li><a href="#atomiclong">AtomicLong</a><ul><li><a href="#cas-%E6%96%B9%E6%B3%95-1">CAS 方法</a></li><li><a href="#lazyset-1">LazySet</a></li></ul></li></ul></li></ul><p>i++ 不是线程安全的操作，因为它不是一个原子性操作。</p><p>那么，如果我想要达到类似 i++ 的这种效果，我应该使用哪些集合或者说工具类呢？</p><p>在 JDK1.5 之前，为了确保在多线程下对某<code>基本</code>数据类型或者<code>引用</code>数据类型运算的原子性，必须依赖于外部关键字 <code>synchronized</code>，但是这种情况在 JDK1.5 之后发生了改观，当然你依然可以使用 synchronized 来保证原子性，我们这里所说的一种线程安全的方式是原子性的工具类，比如 <strong>AtomicInteger、AtomicBoolean</strong> 等。这些原子类都是线程安全的工具类，他们同时也是 <code>Lock-Free</code> 的。下面我们就来一起认识一下这些工具类以及 Lock - Free 是个什么概念。</p><h2 id="了解-atomicinteger" tabindex="-1"><a class="header-anchor" href="#了解-atomicinteger" aria-hidden="true">#</a> 了解 AtomicInteger</h2><p><code>AtomicInteger</code> 是 JDK 1.5 新添加的工具类，我们首先来看一下它的继承关系</p><img src="https://s1.ax1x.com/2020/09/20/wosPYV.png" alt="AtomicInteger01" border="0"><p>与 int 的包装类 Integer 一样，都是继承于 <code>Number</code> 类的。</p><img src="https://s1.ax1x.com/2020/09/20/wos4pT.png" alt="AtomicInteger02" border="0"><p>这个 Number 类是基本数据类型的包装类，一般和数据类型有关的对象都会继承于 Number 类。</p><p>它的继承体系很简单，下面我们来看一下它的基本属性和方法</p><h3 id="atomicinteger-的基本属性" tabindex="-1"><a class="header-anchor" href="#atomicinteger-的基本属性" aria-hidden="true">#</a> AtomicInteger 的基本属性</h3><p>AtomicInteger 的基本属性有三个</p><img src="https://s1.ax1x.com/2020/09/20/wTiyJH.png" alt="wTiyJH.png" border="0"><p><code>Unsafe</code> 是 <code>sun.misc</code> 包下面的类，AtomicInteger 主要是依赖于 sun.misc.Unsafe 提供的一些 native 方法保证操作的原子性。</p><p>Unsafe 的 <code>objectFieldOffset</code> 方法可以获取成员属性在内存中的地址相对于对象内存地址的偏移量。说得简单点就是找到这个变量在内存中的地址，便于后续通过内存地址直接进行操作，这个值就是 <code>value</code></p><p>这个我们后面会再细说</p><p><code>value</code> 就是 AtomicIneger 的值。</p><h3 id="atomicinteger-的构造方法" tabindex="-1"><a class="header-anchor" href="#atomicinteger-的构造方法" aria-hidden="true">#</a> AtomicInteger 的构造方法</h3><p>继续往下看，AtomicInteger 的构造方法只有两个，一个是无参数的构造方法，无参数的构造方法默认的 value 初始值是 0 ，带参数的构造方法可以指定初始值。</p><img src="https://s1.ax1x.com/2020/09/20/wosWt0.png" alt="AtomicInteger04" border="0"><h3 id="atomicinteger-中的方法" tabindex="-1"><a class="header-anchor" href="#atomicinteger-中的方法" aria-hidden="true">#</a> AtomicInteger 中的方法</h3><p>下面我们就来聊一下 AtomicInteger 中的方法。</p><h4 id="get-和-set" tabindex="-1"><a class="header-anchor" href="#get-和-set" aria-hidden="true">#</a> Get 和 Set</h4><p>我们首先来看一下最简单的 get 、set 方法：</p><p><code>get()</code> : 获取当前 AtomicInteger 的值</p><p><code>set()</code> : 设置当前 AtomicInteger 的值</p><p>get() 可以原子性的读取 AtomicInteger 中的数据，set() 可以原子性的设置当前的值，因为 get() 和 set() 最终都是作用于 value 变量，而 value 是由 <code>volatile</code> 修饰的，所以 get 、set 相当于都是对内存进行读取和设置。如下图所示</p><img src="https://s1.ax1x.com/2020/09/20/wosRkq.png" alt="AtomicInteger05" border="0"><p>我们上面提到了 i++ 和 i++ 的非原子性操作，我们说可以使用 AtomicInteger 中的方法进行替换。</p><h4 id="incremental-操作" tabindex="-1"><a class="header-anchor" href="#incremental-操作" aria-hidden="true">#</a> Incremental 操作</h4><p>AtomicInteger 中的 <code>Incremental</code> 相关方法可以满足我们的需求</p><ul><li><code>getAndIncrement()</code> : 原子性的增加当前的值，并把结果返回。相当于 <code>i++</code> 的操作。</li></ul>',34),c=n(`<p>为了验证是不是线程安全的，我们用下面的例子进行测试</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TAtomicTest</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>

    <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>atomicInteger<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">TAtomicTest</span> tAtomicTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TAtomicTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>tAtomicTest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>tAtomicTest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过输出结果你会发现它是一个线程安全的操作，你可以修改 i 的值，但是最后的结果仍然是 i - 1，因为先取值，然后再 + 1，它的示意图如下。</p><img src="https://s1.ax1x.com/2020/09/20/wosg7n.png" alt="AtomicInteger06" border="0"><ul><li><code>incrementAndGet</code> 与此相反，首先执行 + 1 操作，然后返回自增后的结果，该操作方法能够确保对 value 的原子性操作。如下图所示</li></ul><img src="https://s1.ax1x.com/2020/09/20/wosc0s.png" alt="AtomicInteger07" border="0"><h4 id="decremental-操作" tabindex="-1"><a class="header-anchor" href="#decremental-操作" aria-hidden="true">#</a> Decremental 操作</h4><p>与此相对，x-- 或者 x = x - 1 这样的自减操作也是原子性的。我们仍然可以使用 AtomicInteger 中的方法来替换</p><ul><li><code>getAndDecrement</code> : 返回当前类型的 int 值，然后对 value 的值进行自减运算。下面是测试代码</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TAtomicTestDecrement</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>

    <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10000</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>atomicInteger<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">TAtomicTestDecrement</span> tAtomicTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TAtomicTestDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>tAtomicTest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>tAtomicTest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是 getAndDecrement 的示意图</p><img src="https://s1.ax1x.com/2020/09/20/wos6mj.png" alt="AtomicInteger08" border="0"><ul><li><code>decrementAndGet</code>：同样的，decrementAndGet 方法就是先执行递减操作，然后再获取 value 的值，示意图如下</li></ul><img src="https://s1.ax1x.com/2020/09/20/wossXQ.png" alt="AtomicInteger09" border="0"><h4 id="lazyset-方法" tabindex="-1"><a class="header-anchor" href="#lazyset-方法" aria-hidden="true">#</a> LazySet 方法</h4><p>volatile 有内存屏障你知道吗？</p><p>内存屏障是啥啊？</p><blockquote><p>内存屏障，也称<code>内存栅栏</code>，内存栅障，屏障指令等， 是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。也是一个让CPU 处理单元中的内存状态对其它处理单元可见的一项技术。</p></blockquote><p>CPU 使用了很多优化，使用缓存、指令重排等，其最终的目的都是为了性能，也就是说，当一个程序执行时，只要最终的结果是一样的，指令是否被重排并不重要。所以指令的执行时序并不是顺序执行的，而是乱序执行的，这就会带来很多问题，这也促使着内存屏障的出现。</p><p>语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。</p><p>内存屏障的开销非常轻量级，但是再小也是有开销的，LazySet 的作用正是如此，它会以普通变量的形式来读写变量。</p><p>也可以说是：<strong>懒得设置屏障了</strong></p><img src="https://s1.ax1x.com/2020/09/20/wosD1S.png" alt="AtomicInteger10" border="0"><h4 id="getandset-方法" tabindex="-1"><a class="header-anchor" href="#getandset-方法" aria-hidden="true">#</a> GetAndSet 方法</h4><p>以原子方式设置为给定值并返回旧值。</p><p>它的源码就是调用了一下 unsafe 中的 getAndSetInt 方法，如下所示</p><img src="https://s1.ax1x.com/2020/09/20/woswff.png" alt="AtomicInteger11" border="0"><p>就是先进行循环，然后调用 <code>getIntVolatile</code> 方法，这个方法我在 cpp 中没有找到，找到的小伙伴们记得及时告诉让我学习一下。</p><p>循环直到 compareAndSwapInt 返回 false，这就说明使用 CAS 并没有更新为新的值，所以 var5 返回的就是最新的内存值。</p><h4 id="cas-方法" tabindex="-1"><a class="header-anchor" href="#cas-方法" aria-hidden="true">#</a> CAS 方法</h4><p>我们一直常说的 CAS 其实就是 <code>CompareAndSet</code> 方法，这个方法顾名思义，就是 <strong>比较并更新</strong> 的意思，当然这是字面理解，字面理解有点偏差，其实人家的意思是先比较，如果满足那么再进行更新。</p><img src="https://s1.ax1x.com/2020/09/20/wosBp8.png" alt="AtomicInteger12" border="0"><p>上面给出了 CAS Java 层面的源码，JDK 官方给它的解释就是 <strong>如果当前值等于 expect 的值，那么就以原子性的方式将当前值设置为 update 给定值</strong>，这个方法会返回一个 boolean 类型，如果是 true 就表示比较并更新成功，否则表示失败。</p><p>CAS 同时也是一种无锁并发机制，也称为 <code>Lock Free</code>，所以你觉得 Lock Free 很高大上吗？并没有。</p><p>下面我们构建一个加锁解锁的 <code>CASLock</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">CASLock</span> <span class="token punctuation">{</span>

    <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> currentThread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>

        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isLock<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">&quot;加锁失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        currentThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>currentThread <span class="token operator">+</span> <span class="token string">&quot; tryLock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">int</span> lockValue <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>lockValue <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>currentThread <span class="token operator">==</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>currentThread <span class="token operator">+</span> <span class="token string">&quot; unlock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">CASLock</span> casLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CASLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    casLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    casLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们构建了一个 CASLock，在 <code>tryLock</code> 方法中，我们先使用 CAS 方法进行更新，如果更新不成功则抛出异常，并把当前线程设置为加锁线程。在 <code>unLock</code> 方法中，我们先判断当前值是否为 0 ，如果是 0 就是我们愿意看到的结果，直接返回。否则是 1，则表示当前线程还在加锁，我们再来判断一下当前线程是否是加锁线程，如果是则执行解锁操作。</p><p>那么我们上面提到的 compareAndSet，它其实可以解析为如下操作</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 伪代码</span>

<span class="token comment">// 当前值</span>
<span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span><span class="token punctuation">{</span>
  <span class="token comment">// 继续向下执行</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以拿生活场景中的买票举例子，你去景区旅游肯定要持票才能进，如果你拿着是假票或者不符合景区的票肯定是能够被识别出来的，如果你没有拿票拿你也肯定进不去景区。</p><p>废话少说，这就祭出来 compareAndSet 的示意图</p><img src="https://s1.ax1x.com/2020/09/29/0eTD1A.png" alt="0eTD1A.png" border="0"><ul><li><code>weakCompareAndSet</code>: 妈的非常认真看了好几遍，发现 JDK1.8 的这个方法和 compareAndSet 方法完全一摸一样啊，坑我。。。</li></ul><img src="https://s1.ax1x.com/2020/09/20/wosYmd.png" alt="AtomicInteger15" border="0"><p>但是真的是这样么？并不是，JDK 源码很博大精深，才不会设计一个重复的方法，你想想 JDK 团队也不是会犯这种低级团队，但是原因是什么呢？</p><p>《Java 高并发详解》这本书给出了我们一个答案</p><img src="https://s1.ax1x.com/2020/09/20/wosr6g.png" alt="AtomicInteger16" border="0"><h4 id="addandget" tabindex="-1"><a class="header-anchor" href="#addandget" aria-hidden="true">#</a> AddAndGet</h4><p>AddAndGet 和 getAndIncrement、getAndAdd、incrementAndGet 等等方法都是使用了 do ... while + CAS 操作，其实也就相当于是一个自旋锁，如果 CAS 修改成功就会一直循环，修改失败才会返回。示意图如下</p><img src="https://s1.ax1x.com/2020/09/20/wosGOH.png" alt="AtomicInteger17" border="0"><h3 id="深入-atomicinteger" tabindex="-1"><a class="header-anchor" href="#深入-atomicinteger" aria-hidden="true">#</a> 深入 AtomicInteger</h3><p>我们上面探讨了 AtomicInteger 的具体使用，同时我们知道 AtomicInteger 是依靠 volatile 和 CAS 来保证原子性的，那么我们下面就来分析一下为什么 CAS 能够保证原子性，它的底层是什么？AtomicInteger 与乐观锁又有什么关系呢？</p><h4 id="atomicinteger-的底层实现原理" tabindex="-1"><a class="header-anchor" href="#atomicinteger-的底层实现原理" aria-hidden="true">#</a> AtomicInteger 的底层实现原理</h4><p>我们再来瞧瞧这个可爱的 <code>compareAndSetL(CAS)</code> 方法，为什么就这两行代码就保证原子性了？</p><img src="https://s1.ax1x.com/2020/09/20/wos86e.png" alt="AtomicInteger18" border="0"><p>我们可以看到，这个 CAS 方法相当于是调用了 unsafe 中的 <code>compareAndSwapInt</code> 方法，我们进到 unsafe 方能发中看一下具体实现。</p><img src="https://s1.ax1x.com/2020/09/20/wos3lD.png" alt="AtomicInteger19" border="0"><p>compareAndSwapInt 是 <code>sun.misc</code> 中的方法，这个方法是一个 <code>native</code> 方法，它的底层是 C/C++ 实现的，所以我们需要看 C/C++ 的源码。</p><p>知道 C/C++ 的牛逼之处了么。使用 Java 就是玩应用和架构的，C/C++ 是玩服务器、底层的。</p><p>compareAndSwapInt 的源码在 <code>jdk8u-dev/hotspot/src/share/vm/prims/unsafe.app</code> 路径下，它的源码实现是</p><img src="https://s1.ax1x.com/2020/09/20/wosMY6.png" alt="AtomicInteger20" border="0"><p>也就是 <code>Unsafe_CompareAndSwapInt</code> 方法，我们找到这个方法</p><img src="https://s1.ax1x.com/2020/09/20/wosKFx.png" alt="AtomicInteger21" border="0"><p>C/C++ 源码我也看不懂，但是这不妨碍我们找到关键代码 <code>Atomic::cmpxchg</code> ，cmpxchg 是 x86 CPU 架构的汇编指令，它的主要作用就是比较并交换操作数。我们继续往下跟找一下这个指令的定义。</p><p>我们会发现对应不同的 os，其底层实现方式不一样</p><img src="https://s1.ax1x.com/2020/09/20/wos1SO.png" alt="AtomicInteger22" border="0"><p>我们找到 Windows 的实现方式如下</p><img src="https://s1.ax1x.com/2020/09/20/wosQfK.png" alt="AtomicInteger23" border="0"><p>我们继续向下找，它其实定义的是第 216 行的代码，我们找进去</p><img src="https://s1.ax1x.com/2020/09/20/wosnT1.png" alt="AtomicInteger24" border="0"><p>此时就需要汇编指令和寄存器相关的知识了。</p><p>上面的 <code>os::is-MP()</code> 是多处理操作系统的接口，下面是 __asm ，它是 C/C++ 的关键字，用于调用内联汇编程序。</p><p>__asm 中的代码是汇编程序，大致来说就是把 dest、exchange_value 、compare_value 的值都放在寄存器中，下面的 <code>LOCK_IF_MP</code> 中代码的大致意思就是</p><img src="https://s1.ax1x.com/2020/09/20/wosmwR.png" alt="AtomicInteger25" border="0"><p>如果是多处理器的话就会执行 lock，然后进行比较操作。其中的 cmp 表示比较，mp 表示的就是 <code>MultiProcess</code>，<code>je</code> 表示相等跳转，L0 表示的是标识位。</p><p>我们回到上面的汇编指令，我们可以看到，CAS 的底层就是 <code>cmpxchg</code> 指令。</p><h4 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁" aria-hidden="true">#</a> 乐观锁</h4><p>你有没有这个疑问，为什么 AtomicInteger 可以获取当前值，那为什么还会出现 <code>expectValue</code> 和 <code>value</code> 不一致的情况呢？</p><p>因为 AtomicInteger 只是一个原子性的工具类，它不具有排他性，它不像是 <code>synchronized</code> 或者是 <code>lock</code> 一样具有互斥和排他性，还记得 AtomicInteger 中有两个方法 get 和 set 吗？它们只是用 <code>volatile </code> 修饰了一下，而 volatile 不具有原子性，所以可能会存在 expectValue 和 value 的当前值不一致的情况，因此可能会出现重复修改。</p><p>针对上面这种情况的解决办法有两种，一种是使用 <code>synchronized</code> 和 <code>lock</code> 等类似的加锁机制，这种锁具有独占性，也就是说同一时刻只能有一个线程来进行修改，这种方式能够保证原子性，但是相对开销比较大，这种锁也叫做悲观锁。另外一种解决办法是使用<code>版本号</code>或者是 <code>CAS 方法</code>。</p><p><strong>版本号</strong></p><p>版本号机制是在数据表中加上一个 <code>version</code> 字段来实现的，表示数据被修改的次数，当执行写操作并且写入成功后，version = version + 1，当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>CAS 方法</strong></p><p>还有一种方式就是 CAS 了，我们上面用了大量的篇幅来介绍 CAS 方法，那么我们认为你现在已经对其运行机制有一定的了解了，我们就不再阐述它的运行机制了。</p><p>任何事情都是有利也有弊，软件行业没有完美的解决方案只有最优的解决方案，所以乐观锁也有它的弱点和缺陷，那就是 ABA 问题。</p><h4 id="aba-问题" tabindex="-1"><a class="header-anchor" href="#aba-问题" aria-hidden="true">#</a> ABA 问题</h4><p>ABA 问题说的是，如果一个变量第一次读取的值是 A，准备好需要对 A 进行写操作的时候，发现值还是 A，那么这种情况下，能认为 A 的值没有被改变过吗？可以是由 A -&gt; B -&gt; A 的这种情况，但是 AtomicInteger 却不会这么认为，它只相信它看到的，它看到的是什么就是什么。举个例子来说</p><p>假如现在有一个单链表，如下图所示</p><img src="https://s1.ax1x.com/2020/09/20/wosem9.png" alt="AtomicInteger26" border="0"><p>A.next = B ，B.next = null，此时有两个线程 T1 和 T2 分别从单链表中取出 A ，由于一些特殊原因，T2 把 A 改为 B ，然后又改为 A ，此时 T1 执行 CAS 方法，发现单链表仍然是 A ，就会执行 CAS 方法，虽然结果没错，但是这种操作会造成一些潜在的问题。</p><img src="https://s1.ax1x.com/2020/09/20/wosEy4.png" alt="AtomicInteger27" border="0"><p>此时还是一个单链表，两个线程 T1 和 T2 分别从单链表中取出 A ，然后 T1 把链表改为 ACD 如下图所示</p><img src="https://s1.ax1x.com/2020/09/20/wosVOJ.png" alt="AtomicInteger28" border="0"><p>此时 T2，发现内存值还是 A ，就会把 A 的值尝试替换为 B ，因为 B 的引用是 null，此时就会造成 C、D 处于游离态</p><img src="https://s1.ax1x.com/2020/09/20/wosCF0.png" alt="AtomicInteger29" border="0"><p>JDK 1.5 以后的 <code>AtomicStampedReference </code>类就提供了此种能力，其中的 <code>compareAndSet</code> 方法就是首先检查当前值是否等于预期值，判断的标准就是当前引用和邮戳分别和预期引用和邮戳相等，如果全部相等，则以原子方式设置为给定的更新值。</p><img src="https://s1.ax1x.com/2020/09/20/woskSU.png" alt="AtomicInteger30" border="0"><p>好了，上面就是 Java 代码流程了，看到 native 我们知道又要撸 cpp 了。开撸</p><img src="https://s1.ax1x.com/2020/09/20/wosiWT.png" alt="AtomicInteger31" border="0"><p>简单解释一下就是 <code>UnsafeWrapper</code> 就是包装器，换个名字而已。然后经过一些 JNI 的处理，因为 compareAndSwapOject 比较的是引用，所以需要经过 C++ 面向对象的转换。最主要的方法是 <code>atomic_compare_exchange_oop</code></p><img src="https://s1.ax1x.com/2020/09/20/wosAlF.png" alt="AtomicInteger32" border="0"><p>可以看到，又出现了熟悉的词汇 <code>cmpxchg</code> ，也就是说 compareAndSwapOject 使用的还是 cmpxchg 原子性指令，只是它经过了一系列转换。</p><p>我们上面介绍到了 AtomicInteger 是一种原子性的工具类，它的底层是依靠 CAS + Volatile 关键字来实现的原子性和可见性。那么作为八种基本数据类型的原子工具类，我们此篇文章就来介绍一下另外一个原子工具类那就是 <code>AtomicBoolean</code>，通常情况下，AtomicBoolean 用于原子性的更新状态标示位。</p><h2 id="认识-atomicboolean" tabindex="-1"><a class="header-anchor" href="#认识-atomicboolean" aria-hidden="true">#</a> 认识 AtomicBoolean</h2><p>AtomicBoolean 的用法和 AtomicInteger 的非常相似，我们具体来看一下。</p><img src="https://s1.ax1x.com/2020/09/29/0eofQ1.png" alt="AtomicBoolean001" border="0"><p>为什么 AtomicInteger 可以继承 Number 类而 AtomicBoolean 却没有继承于 Number 类呢？</p><p>我们先来看下 <code>Number</code> 类是什么吧</p><img src="https://s1.ax1x.com/2020/09/29/0eoRzR.png" alt="AtomicBoolean002" border="0"><p>JDK 源码给出了我们解释</p><p>Number 类是 JDK 平台的超类，同时也是一个抽象类，它可以转换为具体数值的类，比如原始类型 <strong>byte、double、float、int、long 和 short</strong>。</p><blockquote><p>注意：可以看到只有六中基本数据类型，并没有 char 和 boolean。</p></blockquote><p>也就是说，Number 类是基本数据类型 byte、double、float、int、long 和 short 包装类的超类，Number 类只进行方法的定义，不提供方法的具体实现，具体的实现交给子类去做。</p><img src="https://s1.ax1x.com/2020/09/29/0eo2W9.png" alt="AtomicBoolean003" border="0" style="zoom:50%;"><p>不同的数值之间的转换会存在数值丢失的问题，JDK 源码也给出了我们说明</p><img src="https://s1.ax1x.com/2020/09/29/0eoci4.png" alt="AtomicBoolean004" border="0"><p>简单证明一下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Double</span> d1 <span class="token operator">=</span> <span class="token number">3.1214</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d1<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，还有两种基本数据类型 char 和 boolean ，char 和 boolean 的包装类又分别是啥呢？它们为什么没有被划分为 Number 超类中呢？</p><p>char 类型的包装类其实是 <code>character</code></p><img src="https://s1.ax1x.com/2020/09/29/0eoyoF.png" alt="AtomicBoolean005" border="0"><p>而 boolean 类型的包装类是 Boolean。</p><p>Char 是字符，它可以代表任何值，而不单单是数字，Boolean 只有两个数值：<code>TRUE</code> 和 <code>FALSE</code>，而 Boolean 在传输的过程中会被当作整数来看待，没有必要再继承于 Number 类。</p><p>在了解完 Number 之后，我们继续回到 AtomicBoolean 类的讨论上来。</p><h3 id="atomicboolean-创建" tabindex="-1"><a class="header-anchor" href="#atomicboolean-创建" aria-hidden="true">#</a> AtomicBoolean 创建</h3><p>AtomicBoolean 用于原子性的更新标志值，它不能作为 boolean 的包装类 Boolean 的替代。</p><p>AtomicBoolean 的创建有两种，一种是无参的构造方法；一种是带参数的构造方法，如果 boolean 是 true 的话，那么 value 的值就是 1， 否则就是 0。</p><p>和 AtomicInteger 的构造方法一摸一样，只不过 AtomicInteger 的值可以是任意的，而 AtomicBoolean 的值只能是 true 和 false。</p><img src="https://s1.ax1x.com/2020/09/29/0eogJJ.png" alt="AtomicBoolean006" border="0"><h3 id="atomicboolean-基本方法" tabindex="-1"><a class="header-anchor" href="#atomicboolean-基本方法" aria-hidden="true">#</a> AtomicBoolean 基本方法</h3><p>AtomicBoolean 中的方法很少，下面一起来认识一下。</p><h4 id="get" tabindex="-1"><a class="header-anchor" href="#get" aria-hidden="true">#</a> Get</h4><p>AtomicBoolean 你看起来像是一个 Boolean 类型的值，但是其内部仍然使用 value 这个 int 值来进行存储，int 的值只能是 1 或 0 ，分别对应 true 或 false。</p><img src="https://s1.ax1x.com/2020/09/29/0eosdU.png" alt="AtomicBoolean007" border="0" style="zoom:50%;"><p>所以如果当前值是 1 就返回 true，如果是 0 就返回 false。</p><p>而 AtomicInteger 中的 get 方法只是返回当前值。</p><h4 id="compareandset" tabindex="-1"><a class="header-anchor" href="#compareandset" aria-hidden="true">#</a> CompareAndSet</h4><p>AtomicBoolean 也有 CAS 方法，而且和 AtomicInteger 中的 <code>compareAndSet</code> 底层都是使用的 <code>unfase.compareAndSwapInt</code> 方法，也就是说是，如果你的值只是使用的 0 和 1 ，那么不管是使用 AtomicBoolean 还是 AtomicInteger 达到的效果一样。</p><img src="https://s1.ax1x.com/2020/09/29/0eorZT.png" alt="AtomicBoolean008" border="0"><h4 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h4><p>JDK 给出的解释是无条件的设置为当前值。AtomicInteger 也是一样的。</p><img src="https://s1.ax1x.com/2020/09/29/0eo0s0.png" alt="AtomicBoolean009" border="0"><h4 id="lazyset" tabindex="-1"><a class="header-anchor" href="#lazyset" aria-hidden="true">#</a> LazySet</h4><p>就连 lazySet 都和 AtomicInteger 底层使用的方法也一样。只是 AtomicBoolean 比 AtomicInteger 多了一层判断</p><img src="https://s1.ax1x.com/2020/09/29/0eoBLV.png" alt="AtomicBoolean010" border="0"><h4 id="getandset" tabindex="-1"><a class="header-anchor" href="#getandset" aria-hidden="true">#</a> GetAndSet</h4><p>AtomicBoolean 中的 getAndSet 方法还是和 AtomicInteger 中的有点区别的。</p><img src="https://s1.ax1x.com/2020/09/29/0eowMq.png" alt="AtomicBoolean011" border="0"><p>AtomicBoolean 的底层和方法和 AtomicInteger 一样，如果了解了 AtomicInteger 之后，那么 AtomicBoolean 也就没问题了。AtomicBoolean 本身没多少东西。但是 AtomicBoolean 很适合做开关，因为 AtomicBoolean 中的值只有 1 和 0 。</p><h2 id="atomiclong" tabindex="-1"><a class="header-anchor" href="#atomiclong" aria-hidden="true">#</a> AtomicLong</h2><p>与 AtomicInteger 一样，AtomicLong 也是继承于 Number 类的，AtomicLong 里面的方法几乎和 AtomicInteger 一样，不过 AtomicLong 底层源码可不一样。</p><p>对比如下</p><table><thead><tr><th>方法</th><th>AtomicInteger 底层</th><th>AtomicLong 底层</th></tr></thead><tbody><tr><td>lazySet</td><td>putOrderedLong</td><td>putOrderedInt</td></tr><tr><td>getAndSet</td><td>getAndSetLong</td><td>getAndSetInt</td></tr><tr><td>compareAndSet</td><td>compareAndSwapLong</td><td>compareAndSwapInt</td></tr><tr><td>getAndIncrement 等等</td><td>getAndAddLong</td><td>getAndAddInt</td></tr></tbody></table><p>可以看到，虽然只有一词之差，但是其中的 C/C++ 源码可是相差很多，这次我们简单介绍一下 AtomicLong 的底层实现。</p><h3 id="cas-方法-1" tabindex="-1"><a class="header-anchor" href="#cas-方法-1" aria-hidden="true">#</a> CAS 方法</h3><p>下面我们一起来看一下 CAS 的区别</p><img src="https://s1.ax1x.com/2020/09/29/0eoazn.png" alt="AtomicBoolean012" border="0"><p>在 /jdk8u-dev/hotspot/src/share/vm/prims/unsafe.cpp 中定义了 CAS 中的方法 <code>UNSAFE_ENTRY</code>。如下所示</p><img src="https://s1.ax1x.com/2020/09/29/0eoHFe.png" alt="AtomicBoolean013" border="0"><p>相比于 <code>compareAndSwapInt</code> 方法，在 unsafe.cpp 中，compareAndSwapLong 方法包含了<code>条件编译</code> SUPPORTS_NATIVE_CX8，这是啥？</p><p>我们在 AtomicLong 的 .java 文件中也能看到定义</p><img src="https://s1.ax1x.com/2020/09/29/0eoURs.png" alt="AtomicBoolean014" border="0"><p>JDK 源码给出了我们解释</p><p><code>VM_SUPPORTS_LONG_CAS</code> 是 JVM 的一项用来记录，用来记录是否长期支持无锁的 <code>compareAndSwap</code> 方法。尽管 Unsafe.compareAndSwapLong 在有锁和无锁情况下都支持，但是应该在 Java 级别处理某些构造，以避免锁定用户可见的锁。</p><p>从代码可以看到，<code>UNSAFE_ENTRY</code> 方法首先会判断是否支持 <code>SUPPORTS_NATIVE_CX8</code>，啥意思呢？它的意思就是判断机器是否支持 8 字节的 <code>cmpxchg</code> 这个 CPU 指令。如果硬件不支持，就会判断 JVM 是否支持，如果 JVM 也不支持，就表明这个操作不是 <code>Lock Free</code> 的。此时JVM 会使用显示锁例如 <code>synchronized</code> 来接管。这也是上面这段 cpp 源码的解释。</p><blockquote><p>比如 32 位 CPU 肯定不支持 8 字节 64 位数字的 cpmxchg 指令</p></blockquote><p>那么如何判断系统是否支持 8 字节的 cmpxchg 指令呢？或许用下面这段代码可以证明</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

  <span class="token class-name">Class</span> klass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;java.util.concurrent.atomic.AtomicLong&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Field</span> field <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;VM_SUPPORTS_LONG_CAS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> <span class="token class-name">VMSupportsCS8</span> <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getBoolean</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">VMSupportsCS8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token class-name">VMSupportsCS8</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">&quot;Unexpected value for VMSupportsCS8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码摘自/jdk8u-dev/jdk/test/java/util/concurrent/atomic/VMSupportsCS8.java</p><blockquote><p>JDK 源码真是个好东西。</p></blockquote><h3 id="lazyset-1" tabindex="-1"><a class="header-anchor" href="#lazyset-1" aria-hidden="true">#</a> LazySet</h3><p>lazySet 的底层调用的是 <code>unsafe.putOrderedLong</code> 方法，它的底层源码是</p><img src="https://s1.ax1x.com/2020/09/29/0eo4L6.png" alt="AtomicBoolean015" border="0"><p>可以看到，也出现了 SUPPORTS_NATIVE_CX8 这个判断，如果硬件支持的话，那么就会长期使用 CAS + Volatile 这种 Lock Free 的方式来保证原子性，下面的 <code>SET_FIELD_VOLATILE</code> 同时也证明了这一点，就是使用 volatile 内存语义来保证可见性。</p><p>否则就会判断 JVM 是否支持 ，如果 JVM 不值得话，也会使用 <code>synchronized</code> 进行锁定。</p><p>其他的方法其实大同小异了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivkbczxoj31l20t8al5.jpg" alt="image-20210716163352584"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivl4khz9j31d60h8mze.jpg" alt="image-20210716163433337"></p>`,178);function i(l,r){return s(),e("div",null,[p,t(' <img src="/Users/mr.l/Library/Application Support/typora-user-images/image-20200911085857825.png" alt="image-20200911085857825" style="zoom:67%;" /> '),c])}const d=a(o,[["render",i],["__file","java-atomicxxx.html.vue"]]);export{d as default};
